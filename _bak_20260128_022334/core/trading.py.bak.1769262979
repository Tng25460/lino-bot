from __future__ import annotations

import json
import os
import time
from dataclasses import dataclass, asdict
from typing import Any, Dict, List, Optional, Tuple

from config import settings


@dataclass
class Position:
    mint: str
    entry_price: float          # prix d'entrée (USD ou "price" du scanner)
    high_price: float           # plus haut vu depuis l'entrée
    sol_spent: float            # taille en SOL (ce qu'on a tenté d'acheter)
    opened_at: float
    buy_tx: Optional[str] = None
    status: str = "OPEN"        # OPEN / CLOSED
    closed_at: Optional[float] = None
    close_reason: Optional[str] = None
    sell_tx: Optional[str] = None


class TradingEngine:
    def __init__(self, wallet, logger, positions_file: str, mode: str):
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file
        self.mode = (mode or "PAPER").upper().strip()

        self.last_buy_ts: float = 0.0

        # Anti double-buy encore plus fort
        self._pending_buys: set[str] = set()       # mint en cours d'achat (évite double déclenchement)
        self._mint_last_action: Dict[str, float] = {}  # last buy/sell par mint (cooldown par mint)

        from core.real_executor import RealExecutor
        from core.paper_executor import PaperExecutor

        if self.mode == "REAL":
            self.executor = RealExecutor(wallet, logger)
        else:
            self.executor = PaperExecutor(wallet, logger)

        self.logger.info("[TradingEngine] Initialisé (mode=%s, SL + trailing activé).", self.mode)

        # crée le fichier positions si absent
        self._ensure_positions_file()

    # ----------------------------
    # Fichier positions.json
    # ----------------------------
    def _ensure_positions_file(self) -> None:
        path = self.positions_file
        d = os.path.dirname(path)
        if d and not os.path.isdir(d):
            os.makedirs(d, exist_ok=True)
        if not os.path.exists(path):
            self._save_state({"open": {}, "closed": []})

    def _load_state(self) -> Dict[str, Any]:
        try:
            with open(self.positions_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            return {"open": {}, "closed": []}
        except Exception as e:
            self.logger.error("[POSITIONS] load error: %s", e, exc_info=True)
            return {"open": {}, "closed": []}

    def _save_state(self, state: Dict[str, Any]) -> None:
        tmp = self.positions_file + ".tmp"
        with open(tmp, "w", encoding="utf-8") as f:
            json.dump(state, f, ensure_ascii=False, indent=2)
        os.replace(tmp, self.positions_file)

    def _get_open_positions(self, state: Dict[str, Any]) -> Dict[str, Position]:
        out: Dict[str, Position] = {}
        for mint, pd in (state.get("open") or {}).items():
            try:
                out[mint] = Position(**pd)
            except Exception:
                # si format cassé, on skip
                continue
        return out

    def _set_open_positions(self, state: Dict[str, Any], open_pos: Dict[str, Position]) -> None:
        state["open"] = {m: asdict(p) for m, p in open_pos.items()}

    # ----------------------------
    # Paramètres stratégie
    # ----------------------------
    def _sl_pct(self) -> float:
        # SL -10% (0.10)
        return float(getattr(settings, "STOP_LOSS_PCT", 0.10) or 0.10)

    def _trail_from_high_pct(self) -> float:
        # trailing -10% du plus haut
        return float(getattr(settings, "TRAILING_FROM_HIGH_PCT", 0.10) or 0.10)

    def _max_positions(self) -> int:
        return int(getattr(settings, "MAX_POSITIONS", 1) or 1)

    def _buy_cooldown_global(self) -> float:
        return float(getattr(settings, "BUY_COOLDOWN_SECONDS", 0) or 0)

    def _mint_cooldown(self) -> float:
        # cooldown par mint pour éviter rachat d'un token vendu / ou spam d'achat
        return float(getattr(settings, "MINT_COOLDOWN_SECONDS", 900) or 900)  # 15 min par défaut

    # ----------------------------
    # Utilitaires prix depuis overviews
    # ----------------------------
    def _extract_mint_price_dex(self, ov: Dict[str, Any]) -> Tuple[Optional[str], Optional[float], str]:
        mint: Optional[str] = ov.get("mint") or ov.get("token") or ov.get("address")
        price = ov.get("price_usd") or ov.get("price")
        dex = (ov.get("dex_id") or "").lower().strip()
        if price is not None:
            try:
                price = float(price)
            except Exception:
                price = None
        return mint, price, dex

    # ----------------------------
    # SELL LOGIC
    # ----------------------------
    async def _maybe_sell_positions(self, overviews: List[Dict[str, Any]], state: Dict[str, Any]) -> None:
        open_pos = self._get_open_positions(state)
        if not open_pos:
            return

        # map mint->price
        price_map: Dict[str, float] = {}
        for ov in (overviews or []):
            mint, price, _dex = self._extract_mint_price_dex(ov)
            if mint and price and price > 0:
                price_map[mint] = price

        sl_pct = self._sl_pct()
        trail_pct = self._trail_from_high_pct()

        for mint, pos in list(open_pos.items()):
            current = price_map.get(mint)
            if not current:
                continue

            # update high
            if current > pos.high_price:
                pos.high_price = current

            sl_price = pos.entry_price * (1.0 - sl_pct)

            # Trailing "TP" : on vend si on a déjà été au-dessus de l'entrée
            # et que le prix retombe de 10% depuis le plus haut
            trail_active = pos.high_price > pos.entry_price
            trail_price = pos.high_price * (1.0 - trail_pct) if trail_active else None

            reason = None
            if current <= sl_price:
                reason = f"STOP_LOSS (-{sl_pct*100:.0f}%)"
            elif trail_active and trail_price is not None and current <= trail_price:
                reason = f"TRAILING (-{trail_pct*100:.0f}% from high)"

            if not reason:
                open_pos[mint] = pos
                continue

            self.logger.info(
                "[SELL] Trigger mint=%s current=%.10f entry=%.10f high=%.10f sl=%.10f trail=%s reason=%s",
                mint, current, pos.entry_price, pos.high_price, sl_price,
                (f"{trail_price:.10f}" if trail_price else "n/a"),
                reason,
            )

            try:
                # IMPORTANT: RealExecutor doit implémenter sell(). PaperExecutor l'a déjà.
                res = self.executor.sell(mint)  # on vend tout le mint (executor se charge de trouver le montant)
                if hasattr(res, "__await__"):
                    res = await res

                pos.status = "CLOSED"
                pos.closed_at = time.time()
                pos.close_reason = reason
                if isinstance(res, dict):
                    pos.sell_tx = res.get("tx")
                elif isinstance(res, str):
                    pos.sell_tx = res

                # archive en closed
                state.setdefault("closed", []).append(asdict(pos))
                open_pos.pop(mint, None)

                self._mint_last_action[mint] = time.time()

                self.logger.info("[SELL OK] mint=%s tx=%s reason=%s", mint, pos.sell_tx, reason)

            except Exception as e:
                self.logger.error("[SELL ERROR] %s: %s", mint, e, exc_info=True)
                open_pos[mint] = pos

        self._set_open_positions(state, open_pos)

    # ----------------------------
    # BUY LOGIC
    # ----------------------------
    async def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        self.logger.info("[DBG_ENTER] on_overviews called, n=%s", (len(overviews) if overviews else 0))
        now = time.time()

        state = self._load_state()
        open_pos = self._get_open_positions(state)

        # 1) D'abord, gérer les ventes
        await self._maybe_sell_positions(overviews, state)
        open_pos = self._get_open_positions(state)

        # 2) Ensuite, acheter si possible
        did_buy = False

        # limite positions
        if len(open_pos) >= self._max_positions():
            self._save_state(state)
            self._print_portfolio(state)
            return

        # cooldown global
        cooldown = self._buy_cooldown_global()
        if cooldown > 0 and (now - float(self.last_buy_ts or 0.0) < cooldown):
            self._save_state(state)
            self._print_portfolio(state)
            return

        for ov in (overviews or []):
            if did_buy:
                break

            mint, price, dex = self._extract_mint_price_dex(ov)
            if not mint or not price or price <= 0:
                continue

            # REAL: Raydium only
            if self.mode == "REAL" and dex and dex != "raydium":
                self.logger.info("[SKIP] dex=%s mint=%s (REAL=Raydium only)", dex, mint)
                continue

            # anti double-buy: déjà en position ?
            if mint in open_pos:
                self.logger.info("[SKIP] mint=%s déjà OPEN (anti double-buy)", mint)
                continue

            # anti double-buy: achat en cours ?
            if mint in self._pending_buys:
                self.logger.info("[SKIP] mint=%s pending buy (anti double-buy)", mint)
                continue

            # anti double-buy: cooldown par mint
            last_action = float(self._mint_last_action.get(mint, 0.0))
            mint_cd = self._mint_cooldown()
            if mint_cd > 0 and (now - last_action < mint_cd):
                self.logger.info("[SKIP] mint=%s mint-cooldown (%ss)", mint, int(mint_cd))
                continue

            self.logger.info(
                "[DBG_PRE_RISK] mint=%s liq=%s mc=%s price=%s dex=%s",
                mint, ov.get("liquidity_usd"), ov.get("marketcap_usd"), ov.get("price_usd"), dex
            )

            ok, reason = risk_checker.allow_buy(ov)
            self.logger.info("[DBG_RISK] mint=%s ok=%s reason=%s", mint, ok, reason)
            if not ok:
                self.logger.info("[BUY] Skip %s (risk: %s)", mint, reason)
                continue

            sol_amount = float(getattr(settings, "BUY_AMOUNT_SOL", 0.0) or 0.0)
            if sol_amount <= 0:
                self.logger.info("[BUY] sol_amount <= 0, skip")
                continue

            self.logger.info(
                "[BUY] Signal %s price~%.10f size=%.4f SOL mode=%s",
                mint, float(price), sol_amount, self.mode
            )

            self._pending_buys.add(mint)
            try:
                res = self.executor.buy(mint, sol_amount, float(price))
                if hasattr(res, "__await__"):
                    res = await res

                buy_tx = None
                if isinstance(res, dict):
                    buy_tx = res.get("tx")
                elif isinstance(res, str):
                    buy_tx = res

                # enregistrer position
                pos = Position(
                    mint=mint,
                    entry_price=float(price),
                    high_price=float(price),
                    sol_spent=float(sol_amount),
                    opened_at=time.time(),
                    buy_tx=buy_tx,
                )
                open_pos[mint] = pos
                self._set_open_positions(state, open_pos)
                self._save_state(state)

                self.last_buy_ts = now
                self._mint_last_action[mint] = now
                did_buy = True

                self.logger.info("[BUY OK] %s tx=%s", mint, buy_tx)

            except Exception as e:
                self.logger.error("[BUY ERROR] %s: %s", mint, e, exc_info=True)

            finally:
                self._pending_buys.discard(mint)

        self._save_state(state)
        self._print_portfolio(state)

    def _print_portfolio(self, state: Optional[Dict[str, Any]] = None) -> None:
        state = state or self._load_state()
        open_pos = self._get_open_positions(state)
        closed = state.get("closed") or []

        self.logger.info(
            "[PORTFOLIO] mode=%s open=%d closed=%d",
            self.mode, len(open_pos), len(closed)
        )
        for mint, p in open_pos.items():
            self.logger.info(
                "[OPEN] mint=%s entry=%.10f high=%.10f sol=%.4f age=%ss",
                mint, p.entry_price, p.high_price, p.sol_spent, int(time.time() - p.opened_at)
            )
