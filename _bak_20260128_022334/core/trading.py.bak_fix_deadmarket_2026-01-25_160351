from __future__ import annotations

import json
import os
import time
from typing import Any, Dict, List, Optional, Tuple

from config import settings
import requests
import builtins


def _now() -> float:
    return time.time()


def _safe_float(x: Any, default: float = 0.0) -> float:
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default


def _clamp(x: float, lo: float, hi: float) -> float:
    return max(lo, min(hi, x))

def _safe_num(x, default=0.0):
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default

def _score_overview(ov: Dict[str, Any]) -> float:
    """
    Score momentum léger (API-free).
    Utilise si dispo:
      - priceChange_5m (%)
      - volume_5m (USD)
      - buys_5m / sells_5m
      - liquidity_usd
    """
    pc5 = _safe_num(ov.get("priceChange_5m"), 0.0)
    vol5 = _safe_num(ov.get("volume_5m"), 0.0)
    buys = _safe_num(ov.get("buys_5m"), 0.0)
    sells = _safe_num(ov.get("sells_5m"), 0.0)
    liq = _safe_num(ov.get("liquidity_usd"), 0.0)

    import math
    # ratio buys/sells (évite division par 0)
    ratio = buys / max(1.0, sells)

    # Score (simple mais efficace)
    score = (
        1.3 * pc5
        + 0.8 * math.log1p(vol5)
        + 0.6 * math.log1p(buys)
        + 0.4 * (ratio - 1.0) * 10.0
        - 0.2 * math.log1p(1.0 / max(1.0, liq))  # pénalise liquidité trop faible
    )
    return float(score)

def _volatility_from_ov(ov: Dict[str, Any]) -> float:
    """
    Volatilité proxy (en %): max(|pc5|, |pc1h|) si dispo.
    """
    pc5 = abs(_safe_num(ov.get("priceChange_5m"), 0.0))
    pc1 = abs(_safe_num(ov.get("priceChange_1h"), 0.0))
    return float(max(pc5, pc1))



class TradingEngine:

    def _recent_sells_path(self) -> str:
        import os
        positions_file = getattr(self, "positions_file", "positions.json")
        base_dir = os.path.dirname(positions_file) or "."
        return os.path.join(base_dir, "recent_sells.json")
    def _load_recent_sells(self) -> None:
        import os, json, time
        try:
            path = self._recent_sells_path()
            if not os.path.exists(path):
                # pas de fichier = ok
                self._recent_sells = getattr(self, "_recent_sells", {}) or {}
                if getattr(self, "logger", None):
                    self.logger.info(f"[COOLDOWN] no recent_sells.json at {path}")
                return

            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f) or {}

            # data attendu: mint -> last_sell_ts (float/int)
            now = time.time()
            cleaned = {}
            for mint, ts in (data or {}).items():
                try:
                    tsf = float(ts)
                    # on garde seulement des timestamps plausibles
                    if tsf > 0 and tsf < now + 3600:
                        cleaned[str(mint)] = tsf
                except Exception:
                    continue

            self._recent_sells = cleaned
            if getattr(self, "logger", None):
                self.logger.info(f"[COOLDOWN] loaded recent sells: {len(cleaned)} from {path}")
        except Exception as e:
            # jamais crasher au boot
            self._recent_sells = getattr(self, "_recent_sells", {}) or {}
            if getattr(self, "logger", None):
                self.logger.warning(f"[COOLDOWN] failed to load recent sells: {e}")
    def _save_recent_sells(self) -> None:
        import os, json
        try:
            path = self._recent_sells_path()
            os.makedirs(os.path.dirname(path) or ".", exist_ok=True)

            tmp = path + ".tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(getattr(self, "_recent_sells", {}) or {}, f, indent=2, sort_keys=True)
            os.replace(tmp, path)

            if getattr(self, "logger", None):
                self.logger.info(f"[COOLDOWN] saved recent sells: {len(getattr(self,'_recent_sells',{}) or {})} to {path}")
        except Exception as e:
            if getattr(self, "logger", None):
                self.logger.warning(f"[COOLDOWN] failed to save recent sells: {e}")
    def __init__(self, wallet, logger, positions_file: str, mode: str):
        self._recent_sells = getattr(self, '_recent_sells', {})
        # cooldown persistence (across restarts)
        self._load_recent_sells()
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file or "positions.json"
        self.mode = (mode or "PAPER").upper().strip()

        from core.real_executor import RealExecutor
        from core.paper_executor import PaperExecutor

        self.executor = RealExecutor(wallet, logger) if self.mode == "REAL" else PaperExecutor(wallet, logger)

        # stratégie
        self.sl_pct = float(getattr(settings, "STOP_LOSS_PCT", 0.15))  # -10%
        self.trailing_pct = float(getattr(settings, "TRAILING_FROM_HIGH_PCT", 0.03))  # -10% depuis high
        self._price_log_cache = {}  # mint -> (entry, high, now, ts)

        # anti spam
        self.last_buy_ts_global: float = 0.0
        self.last_buy_ts_by_mint: Dict[str, float] = {}
        self.buy_inflight: set[str] = set()
        self.sell_inflight: set[str] = set()

        # state
        self.positions: Dict[str, Dict[str, Any]] = {}
        self._load_positions()

        self.logger.info(
            "[TradingEngine] Initialisé (mode=%s, SL=%s%%, trailing=%s%% du high). positions_file=%s",
            self.mode,
            int(self.sl_pct * 100),
            int(self.trailing_pct * 100),
            self.positions_file,
        )

    # ---------------- persistence ----------------
    def _load_positions(self) -> None:
        try:
            if os.path.exists(self.positions_file):
                with open(self.positions_file, "r", encoding="utf-8") as f:
                    self.positions = json.load(f) or {}
            else:
                self.positions = {}
        except Exception as e:
            self.logger.error("[POSITIONS] load error: %s", e, exc_info=True)
            self.positions = {}

    def _save_positions(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.positions_file), exist_ok=True)
        except Exception:
            # si positions_file est juste "positions.json" (pas de dossier)
            pass

        tmp = self.positions_file + ".tmp"
        try:
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(self.positions, f, indent=2, sort_keys=True)
            os.replace(tmp, self.positions_file)
        except Exception as e:
            self.logger.error("[POSITIONS] save error: %s", e, exc_info=True)
            try:
                if os.path.exists(tmp):
                    os.remove(tmp)
            except Exception:
                pass

    # ---------------- helpers ----------------
    def _is_open(self, mint: str) -> bool:
        p = self.positions.get(mint) or {}
        return (p.get("status") == "OPEN")

    def _open_positions(self) -> Dict[str, Dict[str, Any]]:
        return {m: p for m, p in (self.positions or {}).items() if p.get("status") == "OPEN"}

    def _update_high(self, pos: Dict[str, Any], price: float) -> None:
        high = _safe_float(pos.get("high_price"), _safe_float(pos.get("entry_price"), 0.0))
        if price > high:
            pos["high_price"] = price

    def _should_sell(self, pos: Dict[str, Any], price: float) -> Tuple[bool, str]:
        entry = _safe_float(pos.get("entry_price"), 0.0)
        if entry <= 0.0 or price <= 0.0:
            return False, "no_price"

        # Stop/trailing adaptatifs si enregistrés au buy
        sl_pct = float(pos.get("sl_pct")) if pos.get("sl_pct") is not None else float(self.sl_pct)
        tr_pct = float(pos.get("trailing_pct")) if pos.get("trailing_pct") is not None else float(self.trailing_pct)

        # clamp sécurité (évite valeurs absurdes)
        sl_pct = _clamp(sl_pct, 0.01, 0.95)
        tr_pct = _clamp(tr_pct, 0.005, 0.95)

        # --- STOP LOSS ---
        # ex: sl_pct=0.15 => stop à -15%
        if price <= entry * (1.0 - sl_pct):
            return True, "STOP_LOSS"

        # --- TRAILING FROM HIGH (avec activation) ---
        high = _safe_float(pos.get("high_price"), entry)

        act = float(getattr(settings, "TRAILING_ACTIVATION_PCT", 0.10))
        act = _clamp(act, 0.0, 5.0)

        trailing_active = (high >= entry * (1.0 + act))
        if trailing_active and high > 0 and price <= high * (1.0 - tr_pct):
            return True, "TRAILING_FROM_HIGH"

        return False, "hold"

    async def _fetch_price_usd_jupiter(self, mint: str) -> Optional[float]:
        """
        Fetch prix USD via Jupiter (si le scanner ne renvoie pas le mint).
        Supporte JUPITER_API_KEY + base url.
        """
        try:
            import httpx

            base = os.getenv("JUPITER_BASE_URL", getattr(settings, "JUPITER_BASE_URL", "https://api.jup.ag"))
            api_key = os.getenv("JUPITER_API_KEY", getattr(settings, "JUPITER_API_KEY", "")) or ""
            headers = {}
            if api_key:
                headers["x-api-key"] = api_key

            # endpoint "price/v3" (ids)
            url = base.rstrip("/") + "/price/v3"
            params = {"ids": mint, "t": str(time.time_ns())}
            async with httpx.AsyncClient(timeout=10.0, headers=headers) as client:
                r = await client.get(url, params=params)
                r.raise_for_status()
                js = r.json()
                # [JUP_PRICE] debug: show blockId when available
                try:
                    item_dbg = js.get(mint) if isinstance(js, dict) else None
                    bid = (item_dbg or {}).get("blockId") if isinstance(item_dbg, dict) else None
                    if getattr(self, "logger", None):
                        self.logger.info("[JUP_PRICE] mint=%s blockId=%s", mint, bid)
                        # ANTI_STALE_JUP_BLOCKID: si Jupiter renvoie le même blockId trop souvent, fallback DexScreener
                        try:
                            last = getattr(self, "_jup_last_block", {}) or {}
                            same = getattr(self, "_jup_same_count", {}) or {}
                            prev = last.get(mint)
                            if prev is not None and str(prev) == str(block_id):
                                same[mint] = int(same.get(mint, 0) or 0) + 1
                            else:
                                same[mint] = 0
                            last[mint] = block_id
                            self._jup_last_block = last
                            self._jup_same_count = same
                            # après 2 répétitions (3 ticks identiques), on tente DexScreener
                            if int(same.get(mint, 0) or 0) >= 2:
                                px_ds = float(self._fetch_price_dexscreener(mint) or 0.0)
                                if px_ds > 0:
                                    if getattr(self, "logger", None):
                                        self.logger.info("[PRICE] fallback dexscreener (stale jup) mint=%s px=%s", mint, px_ds)
                                    return px_ds
                        except Exception:
                            pass

                except Exception:
                    pass
                # [JUP_PRICE_V3_PARSE]
                # Jupiter Price v3: réponse = {mint: {usdPrice: ...}}
                try:
                    if isinstance(js, dict) and mint in js and isinstance(js[mint], dict):
                        v = js[mint].get('usdPrice') or js[mint].get('price') or js[mint].get('priceUsd')
                        if v is not None:
                            return float(v)
                except Exception:
                    pass
                # compat ancienne forme (si jamais)
                data = js.get('data') if isinstance(js, dict) else None
                if isinstance(data, dict) and mint in data and isinstance(data[mint], dict):
                    v = data[mint].get('usdPrice') or data[mint].get('price') or data[mint].get('priceUsd')
                    if v is not None:
                        return float(v)
            # formats possibles:
            # { "data": { "<mint>": { "price": 0.123 } } }
            data = js.get("data") or {}
            row = data.get(mint) or {}
            price = row.get("price")
            if price is None:
                # parfois liste/structure différente
                return None
            return float(price)
        except Exception:
            return None

    # ---------------- core loop ----------------
    async def _fetch_dex_txns_m5(self, mint: str) -> int:
        """Retourne buys+sells sur 5m via DexScreener (0 si inconnu)."""
        try:
            url = f"https://api.dexscreener.com/latest/dex/tokens/{mint}"
            async with httpx.AsyncClient(timeout=10.0) as client:
                r = await client.get(url)
                if r.status_code != 200:
                    return 0
                js = r.json() or {}
                pairs = js.get('pairs') or []
                if not pairs:
                    return 0
                # best liquidity
                def liq(p):
                    try:
                        return float((p.get('liquidity') or {}).get('usd') or 0.0)
                    except Exception:
                        return 0.0
                best = max(pairs, key=liq)
                tx = (best.get('txns') or {}).get('m5') or {}
                buys = int(tx.get('buys') or 0)
                sells = int(tx.get('sells') or 0)
                return buys + sells
        except Exception:
            return 0

    async def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        """
        1) Met à jour / vend les positions (SL / trailing)
           - prix via overviews si dispo
           - sinon fetch Jupiter si position ouverte
        2) Tente un BUY (1 seul max par cycle) si pas déjà en position sur ce mint
        """
        overviews = overviews or []
        self.logger.info("[DBG_ENTER] on_overviews called, n=%s", len(overviews))

        # map mint->price depuis scanner
        price_map: Dict[str, float] = {}
        for ov in overviews:
            mint = ov.get("mint") or ov.get("token") or ov.get("address")
            px = ov.get("price_usd") or ov.get("price")
            if mint and px not in (None, 0, 0.0):
                price_map[str(mint)] = _safe_float(px, 0.0)

        # 1) manage sells
        await self._manage_positions(price_map)

        # 2) buy (au plus 1 par tick)
        await self._maybe_buy(overviews, risk_checker)

        self._print_portfolio()


    def _fetch_price_dexscreener(self, mint: str) -> float:
        """Fallback price via DexScreener. Returns 0.0 if unavailable."""
        try:
            url = f"https://api.dexscreener.com/latest/dex/tokens/{mint}"
            r = requests.get(url, timeout=12)
            if r.status_code != 200:
                return 0.0
            j = r.json() or {}
            pairs = j.get('pairs') or []
            best_px = 0.0
            best_liq = 0.0
            for pr in pairs:
                try:
                    liq = builtins.float(((pr.get('liquidity') or {}).get('usd')) or 0.0)
                    pxs = pr.get('priceUsd')
                    if pxs is None:
                        continue
                    px = builtins.float(pxs or 0.0)
                    if px > 0 and liq >= best_liq:
                        best_liq = liq
                        best_px = px
                except Exception:
                    continue
            return builtins.float(best_px or 0.0)
        except Exception:
            return 0.0

    async def _manage_positions(self, price_map: Dict[str, float]) -> None:
        opens = self._open_positions()
        if not opens:
            return

        for mint, pos in opens.items():
            # prix: scanner d'abord, sinon Jupiter
            # [PRICE] fallback DexScreener if no scanner/jupiter price
            try:
                sm = str(mint)
                if builtins.float(price_map.get(sm) or 0.0) <= 0.0:
                    px_ds = builtins.float(self._fetch_price_dexscreener(sm) or 0.0)
                    if px_ds > 0:
                        price_map[sm] = px_ds
                        if getattr(self, 'logger', None):
                            # [PRICE] dedup (avoid duplicate lines)
                            try:
                                _m = str(mint)
                                _entry = builtins.float(_safe_float(pos.get('entry_price'), 0.0))
                                _high  = builtins.float(_safe_float(pos.get('high_price'), 0.0))
                                _now   = builtins.float(price)
                                _prev = (getattr(self, '_price_log_cache', {}) or {}).get(_m)
                                # prev = (entry, high, now, ts)
                                if (not _prev) or (_prev[0]!=_entry) or (_prev[1]!=_high) or (_prev[2]!=_now) or ((time.time()-builtins.float(_prev[3] or 0))>2.0):
                                    self._price_log_cache[_m] = (_entry, _high, _now, time.time())
                                    self.logger.info('[PRICE] fallback dexscreener mint=%s px=%s', sm, px_ds)
                            except Exception:

                                pass
            except Exception as e:
                if getattr(self, 'logger', None):
                    self.logger.warning('[PRICE] fallback error mint=%s err=%s', mint, e)

            price = _safe_float(price_map.get(mint), 0.0)
            if price <= 0.0:
                price = _safe_float(await self._fetch_price_usd_jupiter(mint) or 0.0, 0.0)

            # [PRICE] debug (live)
            try:
                if isinstance(pos, dict):
                    pos['last_price_usd'] = builtins.float(price or 0.0)
                    # persist pour voir le prix bouger dans positions.json
                    self.positions[mint] = pos
                    self._save_positions()
                # [PRICE] dedup (avoid duplicate lines)
                try:
                    _m = str(mint)
                    _entry = builtins.float(_safe_float(pos.get('entry_price'), 0.0))
                    _high  = builtins.float(_safe_float(pos.get('high_price'), 0.0))
                    _now   = builtins.float(price)
                    _prev = (getattr(self, '_price_log_cache', {}) or {}).get(_m)
                    # prev = (entry, high, now, ts)
                    if (not _prev) or (_prev[0]!=_entry) or (_prev[1]!=_high) or (_prev[2]!=_now) or ((time.time()-builtins.float(_prev[3] or 0))>2.0):
                        self._price_log_cache[_m] = (_entry, _high, _now, time.time())
                        self.logger.info('[PRICE] mint=%s entry=%s high=%s now=%s', mint, _safe_float(pos.get('entry_price'),0.0), _safe_float(pos.get('high_price'),0.0), price)
                except Exception:
                    self.logger.info('[PRICE] mint=%s entry=%s high=%s now=%s', mint, _safe_float(pos.get('entry_price'),0.0), _safe_float(pos.get('high_price'),0.0), price)

            except Exception as e:
                self.logger.warning('[PRICE] debug failed mint=%s err=%s', mint, e)
            try:
                if isinstance(pos, dict):
                    pos['last_price_usd'] = builtins.float(price or 0.0)
                    # persist pour voir le prix bouger dans positions.json
                    self.positions[mint] = pos
                    self._save_positions()
                # [PRICE] dedup (avoid duplicate lines)
                try:
                    _m = str(mint)
                    _entry = builtins.float(_safe_float(pos.get('entry_price'), 0.0))
                    _high  = builtins.float(_safe_float(pos.get('high_price'), 0.0))
                    _now   = builtins.float(price)
                    _prev = (getattr(self, '_price_log_cache', {}) or {}).get(_m)
                    # prev = (entry, high, now, ts)
                    if (not _prev) or (_prev[0]!=_entry) or (_prev[1]!=_high) or (_prev[2]!=_now) or ((time.time()-builtins.float(_prev[3] or 0))>2.0):
                        self._price_log_cache[_m] = (_entry, _high, _now, time.time())
                        self.logger.info('[PRICE] mint=%s entry=%s high=%s now=%s', mint, _safe_float(pos.get('entry_price'),0.0), _safe_float(pos.get('high_price'),0.0), price)
                except Exception:
                    self.logger.info('[PRICE] mint=%s entry=%s high=%s now=%s', mint, _safe_float(pos.get('entry_price'),0.0), _safe_float(pos.get('high_price'),0.0), price)

            except Exception as e:
                self.logger.warning('[PRICE] debug failed mint=%s err=%s', mint, e)
            if price <= 0.0:
                continue
            # [DEAD_MARKET] si 0 trades trop longtemps => exit
            try:
                no_trades_sec = builtins.float(getattr(settings, 'DEAD_MARKET_NO_TRADES_SECONDS', builtins.float(os.getenv('DEAD_MARKET_NO_TRADES_SECONDS','0'))))
                sell_pct = builtins.float(getattr(settings, 'DEAD_MARKET_SELL_PCT', builtins.float(os.getenv('DEAD_MARKET_SELL_PCT','1.0'))))
                if no_trades_sec and no_trades_sec > 0:
                    txns = await self._fetch_dex_txns_m5(str(mint))
                    now_ts = _now()
                    last_trade_ts = builtins.float(pos.get('last_trade_ts') or 0.0)
                    if txns > 0:
                        pos['last_trade_ts'] = now_ts
                    else:
                        if last_trade_ts <= 0:
                            pos['last_trade_ts'] = now_ts
                        elif (now_ts - last_trade_ts) >= no_trades_sec:
                            if mint not in self.sell_inflight:
                                self.sell_inflight.add(mint)
                                try:
                                    self.logger.info('[SELL] %s reason=%s (no trades %.0fs) pct=%.3f', mint, 'NO_TRADES_TIMEOUT', (now_ts-last_trade_ts), sell_pct)
                                    res = self.executor.sell(mint, pct=sell_pct)
                                    if hasattr(res, '__await__'):
                                        res = await res
                                    pos['status'] = 'CLOSED'
                                    pos['closed_ts'] = _now()
                                    pos['exit_price'] = price
                                    pos['exit_reason'] = 'NO_TRADES_TIMEOUT'
                                    self.positions[mint] = pos
                                    self._save_positions()
                                    self.logger.info('[SELL OK] %s reason=%s', mint, 'NO_TRADES_TIMEOUT')
                                    self._recent_sells[mint] = time.time()
                                    self._save_recent_sells()
                                except Exception as e:
                                    self.logger.error('[SELL ERROR] %s: %s', mint, e, exc_info=True)
                                finally:
                                    self.sell_inflight.discard(mint)
                            continue
            except Exception as e:
                self.logger.warning('[DEAD_MARKET] check failed mint=%s err=%s', mint, e)


            # update ATH
            self._update_high(pos, price)

            do_sell, reason = self._should_sell(pos, price)
            if not do_sell:
                continue

            if mint in self.sell_inflight:
                continue

            self.sell_inflight.add(mint)
            try:
                self.logger.info(
                    "[SELL] %s reason=%s entry=%s high=%s now=%s",
                    mint,
                    reason,
                    _safe_float(pos.get("entry_price"), 0.0),
                    _safe_float(pos.get("high_price"), 0.0),
                    price,
                )

                res = self.executor.sell(mint)
                if hasattr(res, "__await__"):
                    res = await res

                pos["status"] = "CLOSED"
                pos["closed_ts"] = _now()
                pos["exit_price"] = price
                pos["exit_reason"] = reason

                self.positions[mint] = pos
                self._save_positions()

                self.logger.info("[SELL OK] %s reason=%s", mint, reason)
                self._recent_sells[mint] = time.time()
                self._save_recent_sells()
            except Exception as e:
                self.logger.error("[SELL ERROR] %s: %s", mint, e, exc_info=True)
            finally:
                self.sell_inflight.discard(mint)

    async def _maybe_buy(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        now = _now()

        # cooldown global
        cooldown_global = builtins.float(getattr(settings, "BUY_COOLDOWN_SECONDS", 0))
        if cooldown_global > 0 and (now - builtins.float(self.last_buy_ts_global or 0.0) < cooldown_global):
            return

        sol_amount = builtins.float(getattr(settings, "BUY_AMOUNT_SOL", 0.0))
        if sol_amount <= 0:
            return

        # -------- SELECTION BRAIN --------
        # Filtres (env/settings) – valeurs par défaut raisonnables
        min_pc5 = builtins.float(getattr(settings, "MIN_PRICE_CHANGE_5M", builtins.float(os.getenv("MIN_PRICE_CHANGE_5M", "6"))))
        min_vol5 = builtins.float(getattr(settings, "MIN_VOLUME_5M", builtins.float(os.getenv("MIN_VOLUME_5M", "3000"))))
        min_ratio = builtins.float(getattr(settings, "MIN_BUY_SELL_RATIO", builtins.float(os.getenv("MIN_BUY_SELL_RATIO", "1.2"))))
        max_open = int(getattr(settings, "MAX_OPEN_POSITIONS", int(os.getenv("MAX_OPEN_POSITIONS", "2"))))

        # limite positions ouvertes
        if len(self._open_positions()) >= max_open:
            return

        def _passes_filters(ov: Dict[str, Any]) -> bool:
            pc5 = _safe_num(ov.get("priceChange_5m"), 0.0)
            vol5 = _safe_num(ov.get("volume_5m"), 0.0)
            buys = _safe_num(ov.get("buys_5m"), 0.0)
            sells = _safe_num(ov.get("sells_5m"), 0.0)
            ratio = buys / max(1.0, sells)
            # si on n'a pas les métriques (None partout), on autorise mais score faible
            if ov.get("priceChange_5m") is None and ov.get("volume_5m") is None:
                return True
            return (pc5 >= min_pc5 and vol5 >= min_vol5 and ratio >= min_ratio)

        # On trie par score décroissant
        overviews = sorted((overviews or []), key=_score_overview, reverse=True)

        did_buy = False

        for ov in overviews:
            if did_buy:
                break

            mint: Optional[str] = ov.get("mint") or ov.get("token") or ov.get("address")
            price = ov.get("price_usd") or ov.get("price")
            dex = (ov.get("dex_id") or "").lower().strip()

            if not mint or price in (None, 0, 0.0):
                continue
            mint = str(mint)

            # REAL: Raydium only
            if self.mode == "REAL" and dex and dex != "raydium":
                continue

            # anti double-buy: déjà OPEN ?
            if self._is_open(mint):
                continue

            # anti inflight
            if mint in self.buy_inflight:
                continue

            # cooldown par mint (optionnel mais très efficace)
            cooldown_mint = builtins.float(getattr(settings, "BUY_COOLDOWN_PER_MINT_SECONDS", 900))  # 15 min default
            last_m = builtins.float(self.last_buy_ts_by_mint.get(mint) or 0.0)
            if cooldown_mint > 0 and (now - last_m < cooldown_mint):
                continue

            self.logger.info(
                "[DBG_PRE_RISK] mint=%s liq=%s mc=%s price=%s dex=%s",
                mint, ov.get("liquidity_usd"), ov.get("marketcap_usd"), ov.get("price_usd"), dex
            )

            ok, reason = risk_checker.allow_buy(ov)
            self.logger.info("[DBG_RISK] mint=%s ok=%s reason=%s", mint, ok, reason)
            if not ok:
                continue

            px = _safe_float(price, 0.0)
            if px <= 0:
                continue

            self.buy_inflight.add(mint)
            try:
                self.logger.info("[BUY] Signal %s price~%.10f size=%.4f SOL mode=%s", mint, px, sol_amount, self.mode)

                res = self.executor.buy(mint, sol_amount, px)
                if hasattr(res, "__await__"):
                    res = await res

                # on marque la position
                self.positions[mint] = {
                    "mint": mint,
                    "status": "OPEN",
                    "entry_price": px,
                    "high_price": px,
                    "opened_ts": now,
                    "mode": self.mode,
                }
                self._save_positions()

                self.last_buy_ts_global = now
                self.last_buy_ts_by_mint[mint] = now
                did_buy = True

                self.logger.info("[BUY OK] %s", mint)

                # --- persist OPEN position (enables SELL logic) ---
                self.positions[mint] = {
                    "status": "OPEN",
                    "entry_price": float(price),
                    "high_price": float(price),
                    "buy_ts": now,
                    "sol_amount": sol_amount,
                }
                self._save_positions()
                self.logger.info("[POSITION OPENED] %s entry=%s", mint, price)

            except Exception as e:
                self.logger.error("[BUY ERROR] %s: %s", mint, e, exc_info=True)
            finally:
                self.buy_inflight.discard(mint)

    def _print_portfolio(self) -> None:
        opens = self._open_positions()
        open_n = len(opens)
        closed_n = len([p for p in (self.positions or {}).values() if p.get("status") == "CLOSED"])

        # petit résumé positions ouvertes
        if open_n > 0:
            # log compact
            sample = list(opens.items())[:3]
            s = ", ".join([f"{m[:4]}.. entry={_safe_float(p.get('entry_price'),0):.6g} high={_safe_float(p.get('high_price'),0):.6g}" for m, p in sample])
            self.logger.info("[OPEN_POS] n=%d %s", open_n, s)

        self.logger.info(
            "[PORTFOLIO] mode=%s open=%d closed=%d positions_file=%s",
            self.mode, open_n, closed_n, self.positions_file
        )
