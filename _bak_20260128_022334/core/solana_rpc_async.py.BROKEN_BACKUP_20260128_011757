from __future__ import annotations

import base64
from dataclasses import dataclass
from typing import Optional, Tuple, Dict, Any

from solana.rpc.async_api import AsyncClient

TOKEN_PROGRAM_ID = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
TOKEN_2022_PROGRAM_ID = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"

def _u32_le(b: bytes, o: int) -> int:
    return int.from_bytes(b[o:o+4], "little")

def _pubkey_str(b: bytes) -> str:
    # base58 would be nicer, but we only need presence/absence;
    # return hex-ish fallback to keep it simple.
    return b.hex()

@dataclass
class MintAuthorities:
    owner_program: str
    mint_authority_present: bool
    freeze_authority_present: bool

class SolanaRpcHelper:
    def __init__(self, rpc_url: str):
        self.rpc_url = rpc_url
        self._rpc = AsyncClient(rpc_url)

    async def aclose(self) -> None:
        try:
            await self._rpc.close()
        except Exception:
            pass

    async def get_mint_authorities(self, mint: str) -> MintAuthorities:
        """
        Fetch mint account and parse SPL Mint layout.
        Layout (82 bytes):
          u32 mint_auth_option
          32 mint_auth
          u64 supply
          u8 decimals
          u8 is_initialized
          u32 freeze_auth_option
          32 freeze_auth
        """
        resp = await self._rpc.get_account_info(mint, encoding="base64")
        val = resp.value
        if not val:
            raise RuntimeError("MINT_NOT_FOUND")

        owner = str(val.owner)
        data_b64 = val.data[0] if isinstance(val.data, (list, tuple)) else val.data
        raw = base64.b64decode(data_b64)

        if len(raw) < 82:
            raise RuntimeError(f"BAD_MINT_LAYOUT len={len(raw)}")

        mint_opt = _u32_le(raw, 0)
        freeze_opt = _u32_le(raw, 46)

        return MintAuthorities(
            owner_program=owner,
            mint_authority_present=(mint_opt != 0),
            freeze_authority_present=(freeze_opt != 0),
        )
PY && \

# 2) RiskChecker: filtres perf + anti-rug RPC (mint/freeze + block Token-2022)
cat > /home/tng25/lino/core/risk_checks.py <<'PY'
from __future__ import annotations

import os
import time
from dataclasses import dataclass
from typing import Any, Dict, Tuple, Optional

from config import settings
from core.solana_rpc_async import SolanaRpcHelper, TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID

def _now() -> float:
    return time.time()

@dataclass
class RiskChecker:
    """
    Anti-rug "utile + rapide" :
      - Min liquidité / Max marketcap
      - Blocage Token-2022 (par défaut)
      - Refuse MintAuthority / FreezeAuthority (très gros red flags)
      - Cache RPC par mint (évite spam RPC)
    """
    logger: Any
    rpc_url: str

    def __post_init__(self) -> None:
        self._rpc = SolanaRpcHelper(self.rpc_url)
        self._cache: Dict[str, Tuple[float, Tuple[bool, str]]] = {}
        self._cache_ttl = float(os.getenv("RUGCHECK_CACHE_TTL", "1800"))  # 30 min

        # settings via env (si tu veux)
        self.block_token_2022 = os.getenv("BLOCK_TOKEN_2022", "1").strip() != "0"

    async def aclose(self) -> None:
        await self._rpc.aclose()

    async def allow_buy(self, ov: Dict[str, Any]) -> Tuple[bool, str]:
        data = ov.get("data") or {}
        mint = str(data.get("address") or data.get("mint") or "")
        if not mint:
            return False, "mint manquant"

        # 1) filtres "cheap & fast" (Birdeye)
        liq = float(data.get("liquidity") or 0.0)
        mc = float(data.get("marketCap") or 0.0)

        min_liq = float(os.getenv("MIN_LIQUIDITY_USD", str(settings.MIN_LIQUIDITY_USD)))
        max_mc = float(os.getenv("MAX_MARKET_CAP_USD", str(settings.MAX_MARKET_CAP_USD)))

        if liq < min_liq:
            return False, f"liquidity trop faible ({liq:.0f} < {min_liq:.0f})"
        if mc > max_mc:
            return False, f"marketcap trop élevé ({mc:.0f} > {max_mc:.0f})"

        # cache anti-rug
        hit = self._cache.get(mint)
        if hit and (_now() - hit[0] < self._cache_ttl):
            return hit[1]

        # 2) checks RPC (mint/freeze + owner program)
        try:
            auth = await self._rpc.get_mint_authorities(mint)
        except Exception as e:
            res = (False, f"RUGCHECK_RPC_FAIL {e}")
            self._cache[mint] = (_now(), res)
            return res

        # block token-2022
        if self.block_token_2022 and auth.owner_program == TOKEN_2022_PROGRAM_ID:
            res = (False, "token-2022 bloqué (mode safe)")
            self._cache[mint] = (_now(), res)
            return res

        # must be classic token program (optionnel, mais safe)
        if auth.owner_program not in (TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID):
            res = (False, f"owner program inconnu: {auth.owner_program}")
            self._cache[mint] = (_now(), res)
            return res

        # mint/freeze authority present => gros red flags
        if auth.mint_authority_present:
            res = (False, "mint authority active (risque mint infini)")
            self._cache[mint] = (_now(), res)
            return res
        if auth.freeze_authority_present:
            res = (False, "freeze authority active (risque freeze wallet)")
            self._cache[mint] = (_now(), res)
            return res

        res = (True, "ok")
        self._cache[mint] = (_now(), res)
        return res
PY && \

# 3) Patch trading.py : s'assure qu'on await bien risk_checker.allow_buy(ov)
python3 - <<'PY'
from pathlib import Path

p = Path("/home/tng25/lino/core/trading.py")
s = p.read_text(encoding="utf-8")

# force l'await (corrige les versions précédentes)
s = s.replace("ok_risk, why_risk = risk_checker.allow_buy(ov)", "ok_risk, why_risk = await risk_checker.allow_buy(ov)")
s = s.replace("ok_risk, why_risk = await risk_checker.allow_buy_async(ov)", "ok_risk, why_risk = await risk_checker.allow_buy(ov)")

p.write_text(s, encoding="utf-8")
print("✅ OK: trading.py -> risk_checker.allow_buy() est await")
PY && \

# 4) Patch main.py : instancie RiskChecker(logger, rpc_url) et ferme proprement
python3 - <<'PY'
from pathlib import Path
import re

p = Path("/home/tng25/lino/src/main.py")
s = p.read_text(encoding="utf-8")

# RiskChecker() -> RiskChecker(logger=logger, rpc_url=settings.RPC_URL)
s = re.sub(r"risks\s*=\s*RiskChecker\(\s*\)", "risks = RiskChecker(logger=logger, rpc_url=settings.RPC_URL)", s)

# ensure we await scanner.aclose() if present
s = s.replace("scanner.close()", "await scanner.aclose()")

# also close risks rpc
if "await risks.aclose()" not in s:
    s = s.replace("await scanner.aclose()", "await scanner.aclose()\n            await risks.aclose()")

p.write_text(s, encoding="utf-8")
print("✅ OK: main.py -> RiskChecker(logger, rpc_url) + close async")
PY && \

# 5) Compile quick sanity
python3 -m py_compile /home/tng25/lino/core/solana_rpc_async.py /home/tng25/lino/core/risk_checks.py /home/tng25/lino/core/trading.py /home/tng25/lino/src/main.py && \

# 6) Launch (MIN_LIQUIDITY_USD=1000 + stable scanner)
export MODE="REAL" \
DRY_RUN_REAL="1" \
FAKE_BIRDEYE="0" \
BIRDEYE_API_KEY="5feef98f995849888347f9f5c63a3dec" \
RPC_URL="https://api.mainnet-beta.solana.com" \
GLOBAL_RPS="0.10" \
MAX_CONCURRENCY="1" \
NEW_LISTING_LIMIT="3" \
SCAN_INTERVAL_SECONDS="35" \
MIN_LIQUIDITY_USD="1000" \
MAX_MARKET_CAP_USD="300000" \
BUY_AMOUNT_SOL="0.002" \
MAX_POSITIONS="1" \
MAX_BUYS_PER_CYCLE="1" \
BUY_COOLDOWN_SECONDS="180" \
STOP_LOSS_PCT="0.10" \
TRAILING_ACTIVATION_PCT="0.07" \
TRAILING_FROM_HIGH_PCT="0.05" \
BLOCK_TOKEN_2022="1" && \
python -u src/main.py

