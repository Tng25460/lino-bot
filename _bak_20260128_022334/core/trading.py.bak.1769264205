from __future__ import annotations

import json
import os
import time
from dataclasses import dataclass, asdict
from typing import Any, Dict, List, Optional, Tuple

from config import settings


def _now() -> float:
    return time.time()


def _f(x, default=0.0) -> float:
    try:
        return float(x)
    except Exception:
        return float(default)


def _safe_mkdir_for_file(path: str) -> None:
    d = os.path.dirname(os.path.abspath(path))
    if d and not os.path.exists(d):
        os.makedirs(d, exist_ok=True)


@dataclass
class Position:
    mint: str
    dex: str
    entry_price_usd: float
    entry_ts: float
    sol_in: float
    buy_sig: Optional[str] = None

    # suivi prix
    last_price_usd: float = 0.0
    highest_price_usd: float = 0.0

    # état
    status: str = "OPEN"  # OPEN/CLOSED
    exit_price_usd: Optional[float] = None
    exit_ts: Optional[float] = None
    sell_sig: Optional[str] = None
    close_reason: Optional[str] = None

    def update_price(self, p: float) -> None:
        p = _f(p, 0.0)
        if p <= 0:
            return
        self.last_price_usd = p
        if self.highest_price_usd <= 0:
            self.highest_price_usd = p
        if p > self.highest_price_usd:
            self.highest_price_usd = p


class PositionsStore:
    """
    positions.json format:
    {
      "open": { "<mint>": {Position...}, ... },
      "closed": [ {Position...}, ... ],
      "meta": { ... }
    }
    """
    def __init__(self, path: str, logger):
        self.path = path
        self.logger = logger
        self.open: Dict[str, Position] = {}
        self.closed: List[Dict[str, Any]] = []
        self.meta: Dict[str, Any] = {}
        self.load()

    def load(self) -> None:
        if not self.path:
            return
        if not os.path.exists(self.path):
            return
        try:
            raw = json.loads(open(self.path, "r", encoding="utf-8").read())
            self.open = {}
            for mint, pd in (raw.get("open") or {}).items():
                self.open[mint] = Position(**pd)
            self.closed = list(raw.get("closed") or [])
            self.meta = dict(raw.get("meta") or {})
        except Exception as e:
            self.logger.error("[POSITIONS] load error: %s", e, exc_info=True)

    def save(self) -> None:
        if not self.path:
            return
        try:
            _safe_mkdir_for_file(self.path)
            data = {
                "open": {m: asdict(p) for m, p in self.open.items()},
                "closed": self.closed,
                "meta": self.meta,
            }
            tmp = self.path + ".tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            os.replace(tmp, self.path)
        except Exception as e:
            self.logger.error("[POSITIONS] save error: %s", e, exc_info=True)

    def has_open(self, mint: str) -> bool:
        return mint in self.open and self.open[mint].status == "OPEN"

    def add_open(self, p: Position) -> None:
        self.open[p.mint] = p
        self.save()

    def close(self, mint: str, exit_price: float, reason: str, sell_sig: Optional[str] = None) -> None:
        p = self.open.get(mint)
        if not p:
            return
        p.status = "CLOSED"
        p.exit_price_usd = _f(exit_price, 0.0) if exit_price else p.last_price_usd
        p.exit_ts = _now()
        p.sell_sig = sell_sig
        p.close_reason = reason
        self.closed.append(asdict(p))
        # remove from open
        self.open.pop(mint, None)
        self.save()


class TradingEngine:
    def __init__(self, wallet, logger, positions_file: str, mode: str):
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file or "positions.json"
        self.mode = (mode or "PAPER").upper().strip()

        from core.real_executor import RealExecutor
        from core.paper_executor import PaperExecutor

        self.executor = RealExecutor(wallet, logger) if self.mode == "REAL" else PaperExecutor(wallet, logger)

        self.positions = PositionsStore(self.positions_file, logger)

        # anti double-buy
        self._buy_inflight: set[str] = set()
        self._last_attempt_by_mint: Dict[str, float] = {}
        self._last_global_buy_ts: float = 0.0

        self.logger.info("[TradingEngine] Initialisé (mode=%s, SL -10%%, trailing -10%% depuis ATH).", self.mode)

    # -------------------------
    # Stratégie SL / Trailing
    # -------------------------
    def _get_params(self) -> Tuple[float, float]:
        sl_pct = _f(getattr(settings, "STOP_LOSS_PCT", 0.10), 0.10)  # 0.10 = -10%
        trailing_from_high = _f(getattr(settings, "TRAILING_FROM_HIGH_PCT", 0.10), 0.10)  # 0.10 = -10% depuis ATH
        return sl_pct, trailing_from_high

    def _trailing_activated(self, p: Position) -> bool:
        # activation à +10% (fixe comme demandé)
        activation_pct = 0.10
        return p.highest_price_usd >= p.entry_price_usd * (1.0 + activation_pct)

    def _should_sell(self, p: Position) -> Tuple[bool, str]:
        sl_pct, trail_pct = self._get_params()

        # Besoin d'un prix
        cur = p.last_price_usd
        if cur <= 0:
            return False, ""

        # STOP LOSS -10% depuis entrée
        if cur <= p.entry_price_usd * (1.0 - sl_pct):
            return True, f"SL hit (-{sl_pct*100:.0f}%)"

        # TRAILING : si activé (+10% atteint) puis -10% depuis plus haut => sell
        if self._trailing_activated(p):
            if cur <= p.highest_price_usd * (1.0 - trail_pct):
                return True, f"TRAIL hit (-{trail_pct*100:.0f}% from ATH)"

        return False, ""

    # -------------------------
    # Anti double-buy
    # -------------------------
    def _block_double_buy(self, mint: str) -> Tuple[bool, str]:
        if self.positions.has_open(mint):
            return True, "already_open"

        if mint in self._buy_inflight:
            return True, "buy_inflight"

        # évite spam retry sur un token qui fail / qui vient d’être tenté
        retry_cooldown = float(getattr(settings, "BUY_RETRY_COOLDOWN_SECONDS", 180))
        last = self._last_attempt_by_mint.get(mint, 0.0)
        if retry_cooldown > 0 and (_now() - last) < retry_cooldown:
            return True, f"retry_cooldown({retry_cooldown}s)"

        return False, ""

    def _global_buy_cooldown_ok(self) -> bool:
        cooldown = float(getattr(settings, "BUY_COOLDOWN_SECONDS", 0))
        if cooldown <= 0:
            return True
        return (_now() - float(self._last_global_buy_ts or 0.0)) >= cooldown

    # -------------------------
    # Loop principale
    # -------------------------
    async def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        n = (len(overviews) if overviews else 0)
        self.logger.info("[DBG_ENTER] on_overviews called, n=%s", n)

        # 1) Mettre à jour les prix des positions open à partir des overviews
        by_mint: Dict[str, Dict[str, Any]] = {}
        for ov in (overviews or []):
            mint = ov.get("mint") or ov.get("token") or ov.get("address")
            if mint:
                by_mint[mint] = ov

        for mint, pos in list(self.positions.open.items()):
            ov = by_mint.get(mint)
            if not ov:
                continue
            price = ov.get("price_usd") or ov.get("price")
            pos.update_price(_f(price, 0.0))

        # 2) SELL CHECKS d’abord (SL/trailing)
        for mint, pos in list(self.positions.open.items()):
            do_sell, reason = self._should_sell(pos)
            if not do_sell:
                continue

            self.logger.info(
                "[SELL] Signal %s cur=%.10f entry=%.10f high=%.10f reason=%s",
                mint, pos.last_price_usd, pos.entry_price_usd, pos.highest_price_usd, reason
            )

            try:
                res = self.executor.sell(mint)  # REAL: sell() calcule le balance; PAPER: gère en interne
                if hasattr(res, "__await__"):
                    res = await res

                sell_sig = None
                if isinstance(res, str):
                    sell_sig = res

                self.positions.close(mint, pos.last_price_usd, reason, sell_sig=sell_sig)
                self.logger.info("[SELL OK] %s sig=%s", mint, sell_sig)

            except Exception as e:
                self.logger.error("[SELL ERROR] %s: %s", mint, e, exc_info=True)

        # 3) BUY si place dispo
        max_pos = int(getattr(settings, "MAX_POSITIONS", 1) or 1)
        if len(self.positions.open) >= max_pos:
            self._print_portfolio()
            return

        if not self._global_buy_cooldown_ok():
            self._print_portfolio()
            return

        # 4) Parcours overviews -> buy 1 seul token par tick
        did_buy = False
        for ov in (overviews or []):
            if did_buy:
                break

            mint: Optional[str] = ov.get("mint") or ov.get("token") or ov.get("address")
            price = ov.get("price_usd") or ov.get("price")
            dex = (ov.get("dex_id") or "").lower().strip()

            if not mint or price in (None, 0, 0.0):
                continue

            # REAL: Raydium only
            if self.mode == "REAL" and dex and dex != "raydium":
                self.logger.info("[SKIP] dex=%s mint=%s (REAL=Raydium only)", dex, mint)
                continue

            block, why = self._block_double_buy(mint)
            if block:
                self.logger.info("[BUY] Skip %s (%s)", mint, why)
                continue

            ok, reason = risk_checker.allow_buy(ov)
            self.logger.info("[DBG_RISK] mint=%s ok=%s reason=%s", mint, ok, reason)
            if not ok:
                continue

            sol_amount = float(getattr(settings, "BUY_AMOUNT_SOL", 0.0))
            if sol_amount <= 0:
                self.logger.info("[BUY] Skip %s (BUY_AMOUNT_SOL<=0)", mint)
                continue

            self.logger.info(
                "[BUY] Signal %s price~%.10f size=%.4f SOL mode=%s",
                mint, float(price), sol_amount, self.mode
            )

            self._buy_inflight.add(mint)
            self._last_attempt_by_mint[mint] = _now()

            try:
                res = self.executor.buy(mint, sol_amount, float(price))
                if hasattr(res, "__await__"):
                    res = await res

                buy_sig = res if isinstance(res, str) else None

                p = Position(
                    mint=mint,
                    dex=dex or "unknown",
                    entry_price_usd=float(price),
                    entry_ts=_now(),
                    sol_in=sol_amount,
                    buy_sig=buy_sig,
                    last_price_usd=float(price),
                    highest_price_usd=float(price),
                )
                self.positions.add_open(p)

                self._last_global_buy_ts = _now()
                did_buy = True

                self.logger.info("[BUY OK] %s tx=%s", mint, buy_sig)

            except Exception as e:
                self.logger.error("[BUY ERROR] %s: %s", mint, e, exc_info=True)

            finally:
                self._buy_inflight.discard(mint)

        self._print_portfolio()

    def _print_portfolio(self) -> None:
        # calc PnL approx (USD) via entry/last
        open_cnt = len(self.positions.open)
        closed_cnt = len(self.positions.closed)

        pnl_open = 0.0
        for p in self.positions.open.values():
            if p.entry_price_usd > 0 and p.last_price_usd > 0:
                pnl_open += (p.last_price_usd / p.entry_price_usd - 1.0) * 100.0

        self.logger.info(
            "[PORTFOLIO] mode=%s open=%d closed=%d avg_open_pnl=%.2f%% positions_file=%s",
            self.mode, open_cnt, closed_cnt, (pnl_open / open_cnt if open_cnt else 0.0), self.positions_file
        )
