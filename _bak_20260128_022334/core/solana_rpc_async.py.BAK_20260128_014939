from __future__ import annotations

import asyncio
import time
from dataclasses import dataclass
from typing import Any, Dict, Optional

import aiohttp

TOKEN_PROGRAM_ID = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
TOKEN_2022_PROGRAM_ID = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"


@dataclass
class RpcResponseError(Exception):
    message: str
    data: Any = None

    def __str__(self) -> str:
        return self.message if self.data is None else f"{self.message} | data={self.data}"


class SolanaRPCAsync:
    """
    Minimal async JSON-RPC client for Solana.
    - rate limit (rps)
    - concurrency cap
    - clean close/aclose
    """

    def __init__(
        self,
        rpc_url: str,
        *,
        timeout_s: float = 20.0,
        rps: float = 8.0,
        max_concurrency: int = 8,
    ):
        self.rpc_url = rpc_url
        self.timeout_s = float(timeout_s)
        self.rps = float(rps)
        self.sem = asyncio.Semaphore(int(max_concurrency))

        self._session: Optional[aiohttp.ClientSession] = None
        self._last_call_ts = 0.0
        self._lock = asyncio.Lock()

    async def _get_session(self) -> aiohttp.ClientSession:
        if self._session is None or self._session.closed:
            timeout = aiohttp.ClientTimeout(total=self.timeout_s)
            self._session = aiohttp.ClientSession(timeout=timeout)
        return self._session

    async def _throttle(self) -> None:
        if self.rps <= 0:
            return
        min_interval = 1.0 / self.rps
        async with self._lock:
            now = time.time()
            dt = now - self._last_call_ts
            if dt < min_interval:
                await asyncio.sleep(min_interval - dt)
            self._last_call_ts = time.time()

    async def call(self, method: str, params: list) -> Any:
        await self._throttle()
        async with self.sem:
            s = await self._get_session()
            payload = {"jsonrpc": "2.0", "id": 1, "method": method, "params": params}
            async with s.post(self.rpc_url, json=payload) as r:
                j = await r.json(content_type=None)
                if "error" in j and j["error"]:
                    raise RpcResponseError(f"RPC error {method}", j["error"])
                return j.get("result")

    # -------- helpers (return raw 'value' when applicable) --------
    async def get_account_info(self, pubkey: str, *, encoding: str = "jsonParsed") -> Optional[Dict[str, Any]]:
        res = await self.call("getAccountInfo", [pubkey, {"encoding": encoding}])
        if not res:
            return None
        return res.get("value")

    async def get_token_largest_accounts(self, mint: str) -> Optional[list]:
        res = await self.call("getTokenLargestAccounts", [mint])
        if not res:
            return None
        return res.get("value")

    async def close(self) -> None:
        if self._session and not self._session.closed:
            await self._session.close()

    async def aclose(self) -> None:
        await self.close()
