from __future__ import annotations

import os
import sqlite3
import time
from dataclasses import dataclass
from typing import Any, Dict, Iterable, Optional

DEFAULT_DB_PATH = os.getenv("TRADES_DB_PATH", "state/trades.sqlite")


def now_ts() -> int:
    return int(time.time())


def _connect(path: str) -> sqlite3.Connection:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    con = sqlite3.connect(path, timeout=30, isolation_level=None)  # autocommit
    con.row_factory = sqlite3.Row
    con.execute("PRAGMA journal_mode=WAL;")
    con.execute("PRAGMA synchronous=NORMAL;")
    con.execute("PRAGMA foreign_keys=ON;")
    return con


def init_db(path: str = DEFAULT_DB_PATH) -> None:
    con = _connect(path)
    try:
        con.executescript(
            """
            CREATE TABLE IF NOT EXISTS meta (
              k TEXT PRIMARY KEY,
              v TEXT NOT NULL
            );

            CREATE TABLE IF NOT EXISTS positions (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              wallet TEXT NOT NULL,
              mint TEXT NOT NULL,
              symbol TEXT,
              status TEXT NOT NULL CHECK(status IN ('OPEN','CLOSED')),

              qty_token REAL NOT NULL DEFAULT 0,
              entry_price_usd REAL,
              entry_cost_usd REAL,
              entry_ts INTEGER,

              high_price_usd REAL,
              trail_stop_usd REAL,

              tp_done_1 INTEGER NOT NULL DEFAULT 0,
              tp_done_2 INTEGER NOT NULL DEFAULT 0,

              last_price_usd REAL,
              last_update_ts INTEGER,

              close_price_usd REAL,
              close_reason TEXT,
              close_ts INTEGER,

              UNIQUE(wallet, mint, status)
            );

            CREATE TABLE IF NOT EXISTS trades (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              wallet TEXT NOT NULL,
              mint TEXT NOT NULL,
              symbol TEXT,
              side TEXT NOT NULL CHECK(side IN ('BUY','SELL')),
              qty_token REAL NOT NULL DEFAULT 0,

              price_usd REAL,
              notional_usd REAL,

              tx_sig TEXT,
              route TEXT,
              status TEXT NOT NULL CHECK(status IN ('SUBMITTED','CONFIRMED','FAILED')) DEFAULT 'SUBMITTED',
              err TEXT,

              created_ts INTEGER NOT NULL,
              updated_ts INTEGER NOT NULL
            );

            CREATE INDEX IF NOT EXISTS idx_trades_wallet_mint_ts ON trades(wallet, mint, created_ts);
            CREATE INDEX IF NOT EXISTS idx_pos_wallet_status ON positions(wallet, status);
            """
        )
    finally:
        con.close()


@dataclass
class DB:
    path: str = DEFAULT_DB_PATH

    def con(self) -> sqlite3.Connection:
        return _connect(self.path)

    def exec(self, sql: str, params: Iterable[Any] = ()) -> None:
        con = self.con()
        try:
            con.execute(sql, tuple(params))
        finally:
            con.close()

    def one(self, sql: str, params: Iterable[Any] = ()) -> Optional[Dict[str, Any]]:
        con = self.con()
        try:
            cur = con.execute(sql, tuple(params))
            row = cur.fetchone()
            return dict(row) if row else None
        finally:
            con.close()

    def all(self, sql: str, params: Iterable[Any] = ()) -> list[Dict[str, Any]]:
        con = self.con()
        try:
            cur = con.execute(sql, tuple(params))
            return [dict(r) for r in cur.fetchall()]
        finally:
            con.close()


def upsert_open_position(
    db: DB,
    *,
    wallet: str,
    mint: str,
    symbol: str | None,
    qty_token: float,
    entry_price_usd: float | None,
    entry_cost_usd: float | None,
    ts: int,
) -> None:
    # UNIQUE(wallet,mint,status) => une seule position OPEN par mint
    db.exec(
        """
        INSERT INTO positions(
          wallet,mint,symbol,status,
          qty_token,entry_price_usd,entry_cost_usd,entry_ts,
          high_price_usd,trail_stop_usd,
          last_price_usd,last_update_ts
        )
        VALUES(?,?,?,?,?,?,?,?,?,?,?,?)
        ON CONFLICT(wallet,mint,status) DO UPDATE SET
          qty_token=excluded.qty_token,
          entry_price_usd=COALESCE(excluded.entry_price_usd, positions.entry_price_usd),
          entry_cost_usd=COALESCE(excluded.entry_cost_usd, positions.entry_cost_usd),
          entry_ts=COALESCE(excluded.entry_ts, positions.entry_ts),
          last_price_usd=excluded.last_price_usd,
          last_update_ts=excluded.last_update_ts
        """,
        (
            wallet, mint, symbol, "OPEN",
            float(qty_token),
            entry_price_usd,
            entry_cost_usd,
            ts,
            entry_price_usd,
            None,
            entry_price_usd,
            ts,
        ),
    )


def close_position(
    db: DB,
    *,
    wallet: str,
    mint: str,
    close_price_usd: float | None,
    reason: str,
    ts: int,
) -> None:
    db.exec(
        """
        UPDATE positions
        SET status='CLOSED',
            close_price_usd=?,
            close_reason=?,
            close_ts=?,
            last_update_ts=?
        WHERE wallet=? AND mint=? AND status='OPEN'
        """,
        (close_price_usd, reason, ts, ts, wallet, mint),
    )


def update_position_marks(
    db: DB,
    *,
    wallet: str,
    mint: str,
    last_price_usd: float | None,
    high_price_usd: float | None,
    trail_stop_usd: float | None,
    ts: int,
) -> None:
    db.exec(
        """
        UPDATE positions
        SET last_price_usd=COALESCE(?, last_price_usd),
            high_price_usd=COALESCE(?, high_price_usd),
            trail_stop_usd=COALESCE(?, trail_stop_usd),
            last_update_ts=?
        WHERE wallet=? AND mint=? AND status='OPEN'
        """,
        (last_price_usd, high_price_usd, trail_stop_usd, ts, wallet, mint),
    )


def mark_tp_done(db: DB, *, wallet: str, mint: str, which: int) -> None:
    if which == 1:
        db.exec("UPDATE positions SET tp_done_1=1 WHERE wallet=? AND mint=? AND status='OPEN'", (wallet, mint))
    elif which == 2:
        db.exec("UPDATE positions SET tp_done_2=1 WHERE wallet=? AND mint=? AND status='OPEN'", (wallet, mint))
