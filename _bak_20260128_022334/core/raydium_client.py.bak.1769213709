from __future__ import annotations

import os
import re
import base64
from dataclasses import dataclass
from typing import Any, Dict, Optional, List

import httpx

WSOL_MINT = "So11111111111111111111111111111111111111112"
RAYDIUM_SWAP_HOST = "https://transaction-v1.raydium.io"

_BASE58_RE = re.compile(r"^[1-9A-HJ-NP-Za-km-z]{32,44}$")


@dataclass
class RaydiumConfig:
    tx_version: str = "V0"          # "V0" ou "LEGACY"
    slippage_bps: int = 300         # 3.00%
    compute_unit_price_micro_lamports: str = "0"
    test_mode: bool = False         # True => ne broadcast pas


class RaydiumClient:
    def __init__(
        self,
        rpc_url: Optional[str] = None,
        solana_client: Any = None,
        wallet: Any = None,
        logger: Any = None,
        cfg: Optional[RaydiumConfig] = None,
    ):
        self.rpc_url = rpc_url or os.getenv("RPC_URL") or "https://api.mainnet-beta.solana.com"
        self.solana_client = solana_client
        self.wallet = wallet
        self.log = logger
        self.cfg = cfg or RaydiumConfig()

        self._http = httpx.AsyncClient(
            timeout=httpx.Timeout(30.0),
            headers={"accept": "application/json"},
        )

        self._rpc = None
        try:
            from solana.rpc.async_api import AsyncClient
            self._rpc = AsyncClient(self.rpc_url)
        except Exception as e:
            self._warn("[RaydiumClient] RPC AsyncClient non dispo: %s", e)

    async def aclose(self) -> None:
        try:
            await self._http.aclose()
        except Exception:
            pass
        try:
            if self._rpc is not None:
                await self._rpc.close()
        except Exception:
            pass

    def _info(self, msg: str, *args: Any) -> None:
        if self.log and hasattr(self.log, "info"):
            self.log.info(msg, *args)

    def _warn(self, msg: str, *args: Any) -> None:
        if self.log and hasattr(self.log, "warning"):
            self.log.warning(msg, *args)

    def _error(self, msg: str, *args: Any) -> None:
        if self.log and hasattr(self.log, "error"):
            self.log.error(msg, *args)

    def _wallet_pubkey_str(self) -> str:
        if self.wallet is None:
            raise RuntimeError("Wallet manquant (swap REAL impossible).")

        # Wallet.pubkey() (ton cas)
        if hasattr(self.wallet, "pubkey") and callable(getattr(self.wallet, "pubkey")):
            s = str(self.wallet.pubkey()).strip()
            # si c'est "Pubkey(xxx)" on extrait xxx
            m = re.search(r"Pubkey\(([^)]+)\)", s)
            if m:
                s = m.group(1).strip()

            # validation base58 stricte
            if not _BASE58_RE.match(s):
                raise RuntimeError(f"Wallet pubkey invalide pour Raydium (pas base58 clean): {s!r}")
            return s

        # fallback
        for attr in ("public_key", "publicKey", "pubkey"):
            v = getattr(self.wallet, attr, None)
            if v is None:
                continue
            s = str(v).strip()
            m = re.search(r"Pubkey\(([^)]+)\)", s)
            if m:
                s = m.group(1).strip()
            if _BASE58_RE.match(s):
                return s

        raise RuntimeError("Impossible de récupérer une pubkey base58 clean depuis wallet.")

    def _get_signer_keypair(self):
        if self.wallet is None:
            raise RuntimeError("Wallet manquant.")

        kp = getattr(self.wallet, "keypair", None) or getattr(self.wallet, "_keypair", None)
        if kp is None:
            raise RuntimeError("Wallet.keypair introuvable (impossible de signer).")

        # déjà solders?
        try:
            from solders.keypair import Keypair as SoldersKeypair
            if isinstance(kp, SoldersKeypair):
                return kp
        except Exception:
            pass

        raw = None
        for attr in ("secret_key", "secretKey", "to_bytes", "toBytes"):
            v = getattr(kp, attr, None)
            if v is None:
                continue
            try:
                raw = v() if callable(v) else v
                break
            except Exception:
                continue

        if raw is None:
            raw = getattr(self.wallet, "secret_key", None) or getattr(self.wallet, "secret", None)

        if raw is None:
            raise RuntimeError("Impossible d'extraire la secret key pour signer (keypair non compatible).")

        if isinstance(raw, list):
            raw = bytes(raw)
        if isinstance(raw, bytearray):
            raw = bytes(raw)

        from solders.keypair import Keypair as SoldersKeypair
        if len(raw) == 64:
            return SoldersKeypair.from_bytes(raw)
        if len(raw) == 32:
            return SoldersKeypair.from_seed(raw)

        raise RuntimeError(f"Secret key taille inattendue: {len(raw)} (attendu 32 ou 64).")

    async def get_quote(
        self,
        input_mint: str,
        output_mint: str,
        amount: int,
        slippage_bps: Optional[int] = None,
        swap_mode: str = "swap-base-in",
        tx_version: Optional[str] = None,
    ) -> Dict[str, Any]:
        slippage = int(slippage_bps if slippage_bps is not None else self.cfg.slippage_bps)
        txv = (tx_version or self.cfg.tx_version).upper()

        url = f"{RAYDIUM_SWAP_HOST}/compute/{swap_mode}"
        params = {
            "inputMint": input_mint,
            "outputMint": output_mint,
            "amount": int(amount),
            "slippageBps": slippage,
            "txVersion": txv,
        }
        r = await self._http.get(url, params=params)
        r.raise_for_status()
        return r.json()

    async def _build_transactions(
        self,
        swap_response: Dict[str, Any],
        wallet_pubkey: str,
        wrap_sol: bool,
        unwrap_sol: bool,
        input_account: Optional[str] = None,
        output_account: Optional[str] = None,
        tx_version: Optional[str] = None,
    ) -> Dict[str, Any]:
        txv = (tx_version or self.cfg.tx_version).upper()
        url = f"{RAYDIUM_SWAP_HOST}/transaction/swap-base-in"

        payload = {
            "computeUnitPriceMicroLamports": str(self.cfg.compute_unit_price_micro_lamports),
            "swapResponse": swap_response,
            "txVersion": txv,
            "wallet": wallet_pubkey,
            "wrapSol": bool(wrap_sol),
            "unwrapSol": bool(unwrap_sol),
            "inputAccount": input_account,
            "outputAccount": output_account,
        }

        # DEBUG hyper utile si REQ_WALLET_ERROR
        self._info("[Raydium TX BUILD] wallet=%s txVersion=%s wrap=%s unwrap=%s", wallet_pubkey, txv, wrap_sol, unwrap_sol)

        r = await self._http.post(url, json=payload)
        r.raise_for_status()
        return r.json()

    def _extract_tx_b64s(self, txs_payload: Dict[str, Any]) -> List[str]:
        txs: List[str] = []
        data = txs_payload.get("data")

        if isinstance(data, list):
            for item in data:
                if isinstance(item, dict) and isinstance(item.get("transaction"), str):
                    txs.append(item["transaction"])
                elif isinstance(item, str):
                    txs.append(item)
            return txs

        if isinstance(data, dict):
            for key in ("transaction", "transactions", "txs", "data"):
                v = data.get(key)
                if isinstance(v, list):
                    for item in v:
                        if isinstance(item, dict) and isinstance(item.get("transaction"), str):
                            txs.append(item["transaction"])
                        elif isinstance(item, str):
                            txs.append(item)
                    if txs:
                        return txs
                elif isinstance(v, str):
                    txs.append(v)

        v = txs_payload.get("transaction")
        if isinstance(v, str):
            txs.append(v)

        return txs

    async def _sign_and_send_b64(self, tx_b64: str) -> str:
        if self._rpc is None:
            raise RuntimeError("RPC AsyncClient non dispo (pip install solana).")

        kp = self._get_signer_keypair()
        raw_tx = base64.b64decode(tx_b64)

        # V0
        try:
            from solders.transaction import VersionedTransaction
            vtx = VersionedTransaction.from_bytes(raw_tx)
            signed = VersionedTransaction(vtx.message, [kp])
            resp = await self._rpc.send_raw_transaction(bytes(signed))
            val = getattr(resp, "value", None) or getattr(resp, "result", None) or resp
            return str(val)
        except Exception:
            pass

        # Legacy
        from solana.transaction import Transaction
        from solana.rpc.types import TxOpts

        tx = Transaction.deserialize(raw_tx)
        tx.sign(kp)  # type: ignore
        resp = await self._rpc.send_raw_transaction(tx.serialize(), opts=TxOpts(skip_preflight=False))
        val = getattr(resp, "value", None) or getattr(resp, "result", None) or resp
        return str(val)

    async def swap_sol_to_token(self, token_address: str, sol_amount: float, slippage_bps: Optional[int] = None) -> str:
        wallet_pubkey = self._wallet_pubkey_str()
        lamports = int(float(sol_amount) * 1_000_000_000)
        slippage = int(slippage_bps if slippage_bps is not None else self.cfg.slippage_bps)

        self._info("[REAL BUY] token_address=%s sol=%s slippage_bps=%s wallet=%s", token_address, sol_amount, slippage, wallet_pubkey)

        quote = await self.get_quote(
            input_mint=WSOL_MINT,
            output_mint=token_address,
            amount=lamports,
            slippage_bps=slippage,
        )

        if isinstance(quote, dict) and quote.get("success") is False:
            raise RuntimeError(f"Raydium quote failed: {quote}")

        tx_payload = await self._build_transactions(
            swap_response=quote,
            wallet_pubkey=wallet_pubkey,
            wrap_sol=True,
            unwrap_sol=False,
        )

        if isinstance(tx_payload, dict) and tx_payload.get("success") is False:
            raise RuntimeError(f"Raydium tx build failed: {tx_payload}")

        txs = self._extract_tx_b64s(tx_payload)
        if not txs:
            raise RuntimeError(f"Raydium: aucune tx reçue: {tx_payload!r}")

        if self.cfg.test_mode:
            self._warn("[Raydium TEST] tx reçue (%d) -> pas envoyée", len(txs))
            return "SIMULATED_TX_OK"

        sig = await self._sign_and_send_b64(txs[-1])
        self._info("[Raydium] tx envoyée: %s", sig)
        return sig
