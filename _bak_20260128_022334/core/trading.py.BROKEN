from __future__ import annotations

import json
import os
import time
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from config import settings

# Exécuteurs (si présents dans ton projet)
try:
    from core.real_executor import RealExecutor
except Exception:
    RealExecutor = None  # type: ignore


def _now() -> float:
    return time.time()


def _fmt(x: float) -> str:
    if x == 0:
        return "0"
    if x < 0.0001:
        return f"{x:.8f}"
    return f"{x:.8f}".rstrip("0").rstrip(".")


def _short(addr: str, n: int = 10) -> str:
    if not addr:
        return "?"
    if len(addr) <= n + 4:
        return addr
    return addr[:n] + "…" + addr[-4:]


def _age(ts: float) -> str:
    s = int(_now() - ts)
    if s < 60:
        return f"{s}s"
    m = s // 60
    if m < 60:
        return f"{m}m"
    h = m // 60
    return f"{h}h"


def _table(rows: List[List[str]], headers: List[str]) -> str:
    widths = [len(h) for h in headers]
    for r in rows:
        for i, c in enumerate(r):
            widths[i] = max(widths[i], len(c))

    def sep(l, m, r, fill="─"):
        parts = [fill * (w + 2) for w in widths]
        return l + m.join(parts) + r

    def line(cols):
        parts = []
        for i, c in enumerate(cols):
            parts.append(" " + c.ljust(widths[i]) + " ")
        return "│" + "│".join(parts) + "│"

    out = []
    out.append(sep("┌", "┬", "┐"))
    out.append(line(headers))
    out.append(sep("├", "┼", "┤"))
    for r in rows:
        out.append(line(r))
    out.append(sep("└", "┴", "┘"))
    return "\n".join(out)


@dataclass
class Position:
    mint: str
    entry: float
    sol_in: float
    opened_at: float
    high: float

    closed: bool = False
    closed_at: float = 0.0
    exit_price: float = 0.0
    reason: str = ""

    def pnl_pct(self, price: float) -> float:
        if self.entry <= 0:
            return 0.0
        return (price / self.entry - 1.0) * 100.0

    def stop_loss_price(self) -> float:
        return self.entry * (1.0 - float(settings.STOP_LOSS_PCT))

    def trailing_price(self) -> float:
        return self.high * (1.0 - float(settings.TRAILING_FROM_HIGH_PCT))

    def trailing_active(self) -> bool:
        # activation si high >= entry*(1+activation)
        act = float(getattr(settings, "TRAILING_ACTIVATION_PCT", 0.0) or 0.0)
        if act <= 0:
            return True
        return self.high >= self.entry * (1.0 + act)

    def trigger_price(self) -> Tuple[float, str]:
        sl = self.stop_loss_price()
        if not self.trailing_active():
            return sl, "STOPLOSS"
        tr = self.trailing_price()
        # seuil effectif = max(SL, trailing)
        if tr >= sl:
            return tr, "TRAILING"
        return sl, "STOPLOSS"


class TradingEngine:
    """
    TradingEngine:
      - PAPER: simule en SOL
      - REAL : utilise RealExecutor (si disponible), sinon log only
    """

    def __init__(
        self,
        wallet: Any,
        logger: Any,
        positions_file: str,
        mode: str,
    ):
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file
        self.mode = (mode or "PAPER").upper().strip()

        self.positions: Dict[str, Position] = {}
        self.closed_trades: List[Position] = []

        # Paper accounting (en SOL)
        self.start_equity_paper = 1.0
        self.cash_paper = 1.0

        self.buy_amount_sol = float(settings.BUY_AMOUNT_SOL)

        self.executor = None
        if self.mode == "REAL":
            if RealExecutor is None:
                self.logger.warning("[TradingEngine] RealExecutor introuvable -> REAL en mode log-only.")
            else:
                self.executor = RealExecutor(wallet=self.wallet, logger=self.logger)

        self._buy_cooldown: Dict[str, float] = {}
        self._load_positions()
        self.logger.info("[TradingEngine] Initialisé (PAPER/REAL executor, SL + trailing activé).")

    # ---------- Persistence ----------
    def _load_positions(self) -> None:
        if not os.path.exists(self.positions_file):
            self.logger.info("[TradingEngine] 0 positions rechargées (fichier absent).")
            return
        try:
            raw = json.load(open(self.positions_file, "r"))
            if not isinstance(raw, dict):
                raw = {}
            for mint, p in raw.items():
                if not isinstance(p, dict):
                    continue
                pos = Position(
                    mint=mint,
                    entry=float(p.get("entry", 0.0)),
                    sol_in=float(p.get("sol_in", 0.0)),
                    opened_at=float(p.get("opened_at", _now())),
                    high=float(p.get("high", p.get("entry", 0.0))),
                    closed=bool(p.get("closed", False)),
                    closed_at=float(p.get("closed_at", 0.0)),
                    exit_price=float(p.get("exit_price", 0.0)),
                    reason=str(p.get("reason", "")),
                )
                if pos.closed:
                    self.closed_trades.append(pos)
                else:
                    self.positions[mint] = pos
            self.logger.info(f"[TradingEngine] positions ouvertes={len(self.positions)} fermées={len(self.closed_trades)} rechargées.")
        except Exception as e:
            self.logger.warning(f"[TradingEngine] load positions error: {e}")

    def _save_positions(self) -> None:
        try:
            raw: Dict[str, Any] = {}
            for mint, pos in self.positions.items():
                raw[mint] = pos.__dict__
            for pos in self.closed_trades:
                raw[pos.mint] = pos.__dict__
            with open(self.positions_file, "w") as f:
                json.dump(raw, f, indent=2)
        except Exception as e:
            self.logger.warning(f"[TradingEngine] save positions error: {e}")

    # ---------- Helpers ----------
    def can_open_more(self) -> bool:
        return len(self.positions) < int(settings.MAX_POSITIONS)

    def in_position(self, mint: str) -> bool:
        return mint in self.positions

    def cooldown_ok(self, mint: str) -> Tuple[bool, str]:
        last = self._buy_cooldown.get(mint, 0.0)
        if _now() - last < int(settings.BUY_COOLDOWN_SECONDS):
            return False, f"cooldown {settings.BUY_COOLDOWN_SECONDS}s"
        return True, "ok"

    def mark_cooldown(self, mint: str) -> None:
        self._buy_cooldown[mint] = _now()

    # ---------- Paper execution ----------
    def paper_buy(self, mint: str, price: float, sol_amount: float) -> None:
        if sol_amount <= 0:
            return
        if self.cash_paper < sol_amount:
            self.logger.info(f"[PAPER BUY] Cash insuffisant: cash={self.cash_paper:.4f} < {sol_amount:.4f}")
            return

        self.cash_paper -= sol_amount
        pos = Position(
            mint=mint,
            entry=price,
            sol_in=sol_amount,
            opened_at=_now(),
            high=price,
        )
        self.positions[mint] = pos
        self._save_positions()
        self.logger.info(f"[PAPER BUY] {mint} entry={_fmt(price)} size={sol_amount:.4f} SOL")

    def paper_sell(self, mint: str, price: float, reason: str) -> None:
        pos = self.positions.get(mint)
        if not pos:
            return
        pos.closed = True
        pos.closed_at = _now()
        pos.exit_price = price
        pos.reason = reason

        out_sol = pos.sol_in * (price / pos.entry) if pos.entry > 0 else 0.0
        self.cash_paper += out_sol

        self.closed_trades.append(pos)
        del self.positions[mint]
        self._save_positions()
        self.logger.info(f"[PAPER SELL] {mint} exit={_fmt(price)} reason={reason} out={out_sol:.4f} SOL pnl={pos.pnl_pct(price):+.2f}%")

    # ---------- Public API ----------
    async def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker: Any) -> None:
        # 1) map mint->price
        price_map: Dict[str, float] = {}
        for ov in overviews:
            data = ov.get("data") or {}
            mint = str(data.get("address") or data.get("mint") or "")
            if not mint:
                continue
            price = float(data.get("price") or 0.0)
            if price > 0:
                price_map[mint] = price

        # 2) update positions + sell if trigger
        for mint, pos in list(self.positions.items()):
            price = price_map.get(mint)
            if not price or price <= 0:
                continue

            if price > pos.high:
                pos.high = price

            trigger, reason = pos.trigger_price()

            self.logger.info(
                f"[POS] {mint} price={_fmt(price)} entry={_fmt(pos.entry)} high={_fmt(pos.high)} "
                f"SL={_fmt(pos.stop_loss_price())} TR={_fmt(pos.trailing_price())} act={pos.trailing_active()} "
                f"trigger={_fmt(trigger)} pnl={pos.pnl_pct(price):+.2f}%"
            )

            if price <= trigger:
                if self.mode == "PAPER":
                    self.paper_sell(mint, price, reason)
                else:
                    if self.executor is None:
                        self.logger.warning(f"[REAL SELL] executor absent -> skip {mint}")
                    else:
                        self.logger.info(f"[REAL SELL] {mint} reason={reason} price~{_fmt(price)}")
                        self.executor.sell(mint, price, reason)

        # 3) buys
        for ov in overviews:
            data = ov.get("data") or {}
            mint = str(data.get("address") or data.get("mint") or "")
            price = float(data.get("price") or 0.0)

            if not mint or price <= 0:
                continue

            if self.in_position(mint):
                continue

            ok_cd, why_cd = self.cooldown_ok(mint)
            if not ok_cd:
                self.logger.info(f"[BUY] Skip {mint} ({why_cd})")
                continue

            if not self.can_open_more():
                self.logger.info(f"[BUY] Skip {mint} (max positions {settings.MAX_POSITIONS} atteintes)")
                continue

            ok_risk, why_risk = risk_checker.allow_buy(ov)
            if not ok_risk:
                self.logger.info(f"[BUY] Skip {mint} (risk: {why_risk})")
                continue

            self.logger.info(f"[BUY] Signal {mint} price~{_fmt(price)} size={self.buy_amount_sol} SOL mode={self.mode}")
            self.mark_cooldown(mint)

            if self.mode == "PAPER":
                self.paper_buy(mint, price, self.buy_amount_sol)
            else:
                if self.executor is None:
                    self.logger.warning(f"[REAL BUY] mint={mint} sol={amount}")
                    did_buy = True
                else:
                    self.logger.info(f"[REAL BUY]
                did_buy = True {mint} size={self.buy_amount_sol} SOL price~{_fmt(price)}")
                    self.executor.buy(mint, price, self.buy_amount_sol)

        # 4) portfolio print
        self._print_portfolio(price_map)

    def _print_portfolio(self, price_map: Dict[str, float]) -> None:
        unreal = 0.0
        invested_open = 0.0
        for mint, pos in self.positions.items():
            invested_open += pos.sol_in
            price = price_map.get(mint, pos.entry)
            if pos.entry > 0:
                unreal += pos.sol_in * (price / pos.entry)

        equity = self.cash_paper + unreal
        pnl_total = equity - self.start_equity_paper
        unreal_pnl = unreal - invested_open
        realized_pnl = (self.cash_paper - (self.start_equity_paper - invested_open))

        self.logger.info(
            f"[PORTFOLIO] mode={self.mode} cash={self.cash_paper:.4f} equity={equity:.4f} "
            f"open={len(self.positions)} closed={len(self.closed_trades)} pnl={pnl_total:+.4f} "
            f"(real={realized_pnl:+.4f} unreal={unreal_pnl:+.4f})"
        )

        rows = []
        for mint, pos in self.positions.items():
            price = price_map.get(mint, pos.entry)
            trigger, reason = pos.trigger_price()
            rows.append([
                _short(mint, 10),
                _fmt(pos.entry),
                _fmt(price),
                _fmt(pos.high),
                _fmt(pos.stop_loss_price()),
                _fmt(pos.trailing_price()),
                "ON" if pos.trailing_active() else "OFF",
                f"{pos.pnl_pct(price):+.2f}%",
                _age(pos.opened_at),
            ])

        if rows:
            headers = ["token", "entry", "price", "high", "SL", "TR", "trail", "pnl%", "age"]
            self.logger.info("[TABLE]\n" + _table(rows, headers))
