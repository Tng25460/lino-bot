#!/usr/bin/env python3
import os, json, time
from pathlib import Path

INP   = Path(os.getenv("READY_IN", "ready_to_trade_enriched.jsonl"))
OUT   = Path(os.getenv("READY_OUT", "ready_to_trade_scored.jsonl"))
LIMIT = int(os.getenv("READY_LIMIT", "200"))

MIN_LIQ_USD    = float(os.getenv("MIN_LIQ_USD", "8000"))
MIN_VOL5M_USD  = float(os.getenv("MIN_VOL5M_USD", "600"))
MIN_CHG5M_PCT  = float(os.getenv("MIN_CHG5M_PCT", "2"))
MAX_CHG5M_PCT  = float(os.getenv("MAX_CHG5M_PCT", "120"))
MIN_CHG1H_PCT  = float(os.getenv("MIN_CHG1H_PCT", "5"))
SCORE_MIN      = float(os.getenv("SCORE_MIN", "6.0"))
DEX_ALLOW      = set(x.strip() for x in os.getenv("DEX_ALLOW", "raydium").lower().split(",") if x.strip())

def clamp(x,a,b): return a if x<a else b if x>b else x
def sf(x,d=0.0):
    try: return float(x)
    except Exception: return d

def score_row(r: dict):
    dex = (r.get("dex_id") or "").lower().strip()
    if DEX_ALLOW and dex and dex not in DEX_ALLOW:
        return (False, -99.0, "dex", {"dex": dex, "allow": sorted(DEX_ALLOW)})

    liq   = sf(r.get("liquidity_usd"), 0.0)
    v5    = sf(r.get("vol_5m"), 0.0)
    ch5   = sf(r.get("chg_5m"), 0.0)
    ch1h  = sf(r.get("chg_1h"), 0.0)
    tx5m  = sf(r.get("txns_5m"), 0.0)

    if liq <= 0:
        return (False, -1.0, "liq0", {"liq": liq})
    if liq < MIN_LIQ_USD:
        return (False, -1.0, "liq", {"liq": liq, "min": MIN_LIQ_USD})
    if v5 < MIN_VOL5M_USD:
        return (False, -1.0, "vol5m", {"vol5m": v5, "min": MIN_VOL5M_USD})
    if ch5 < MIN_CHG5M_PCT:
        return (False, -1.0, "chg5m_low", {"chg5m": ch5, "min": MIN_CHG5M_PCT})
    if ch5 > MAX_CHG5M_PCT:
        return (False, -1.0, "chg5m_high", {"chg5m": ch5, "max": MAX_CHG5M_PCT})
    if ch1h < MIN_CHG1H_PCT:
        return (False, -1.0, "chg1h", {"chg1h": ch1h, "min": MIN_CHG1H_PCT})

    # score stable
    s_liq  = clamp((liq / (MIN_LIQ_USD*3.0)), 0.0, 2.0)      # 0..2
    s_v5   = clamp((v5  / (MIN_VOL5M_USD*4.0)), 0.0, 3.0)   # 0..3
    s_ch5  = clamp((ch5 / 30.0), 0.0, 3.0)                  # 0..3
    s_tx   = clamp((tx5m / 30.0), 0.0, 2.0)                 # 0..2
    score  = float(2.0 + s_liq + s_v5 + s_ch5 + s_tx)

    dbg = {"liq": liq, "vol5m": v5, "chg5m": ch5, "chg1h": ch1h, "tx5m": tx5m,
           "s_liq": s_liq, "s_v5": s_v5, "s_ch5": s_ch5, "s_tx": s_tx}

    if score < SCORE_MIN:
        return (False, score, "score_min", dbg)

    return (True, score, "ok", dbg)

def main():
    if not INP.exists():
        raise SystemExit(f"missing {INP}")

    OUT.write_text("", encoding="utf-8")

    kept = 0
    total = 0

    with INP.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            if total >= LIMIT:
                break
            line = line.strip()
            if not line:
                continue
            try:
                r = json.loads(line)
            except Exception:
                continue
            if not isinstance(r, dict):
                continue

            total += 1
            ok, sc, reason, dbg = score_row(r)

            r["score"] = float(sc)
            r["score_reason"] = reason
            r["score_dbg"] = dbg
            r["scored_at"] = int(time.time())

            if ok:
                kept += 1
                with OUT.open("a", encoding="utf-8") as w:
                    w.write(json.dumps(r, ensure_ascii=False) + "\n")

    print("READY_IN=", str(INP), "limit=", LIMIT, "total=", total)
    print("OUT=", str(OUT), "kept=", kept)

if __name__ == "__main__":
    main()
