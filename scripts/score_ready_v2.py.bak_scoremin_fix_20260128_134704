#!/usr/bin/env python3
import os, json, time
from pathlib import Path

INP  = Path(os.getenv("READY_IN",  "ready_to_trade_enriched.jsonl"))
OUT  = Path(os.getenv("READY_OUT", "ready_to_trade_scored.jsonl"))
TOPN = int(os.getenv("READY_TOPN", "200"))
DEX_ALLOW = set(x.strip() for x in os.getenv("DEX_ALLOW", "raydium").lower().split(",") if x.strip())

# Thresholds (tune via env if needed)
MIN_LIQ_USD  = float(os.getenv("SCORE_MIN_LIQ",  "5000"))
MIN_VOL5_USD = float(os.getenv("SCORE_MIN_VOL5","100"))
MIN_TX5      = float(os.getenv("SCORE_MIN_TX5", "2"))
MIN_CHG5     = float(os.getenv("SCORE_MIN_CHG5", "0.5"))
MIN_CHG1H    = float(os.getenv("SCORE_MIN_CHG1H", "3.0"))
MAX_FDV      = float(os.getenv("SCORE_MAX_FDV", "50000000"))
MAX_MCAP     = float(os.getenv("SCORE_MAX_MCAP", "50000000"))

def _f(x, d=0.0):
    try:
        if x is None: return d
        return float(x)
    except Exception:
        return d

def score_row(o: dict):
    dex = (o.get("dex_id") or "").lower().strip()
    if DEX_ALLOW and dex and dex not in DEX_ALLOW:
        return None, "gate_dex"

    liq = _f(o.get("liquidity_usd"))
    v5  = _f(o.get("vol_5m"))
    ch5 = _f(o.get("chg_5m"))
    tx5 = _f(o.get("txns_5m"))

    # Gates
    if liq < MIN_LIQ_USD:  return None, "gate_liq"
    if v5  < MIN_VOL5_USD: return None, "gate_vol5"
    if tx5 < MIN_TX5:      return None, "gate_tx5"
    if ch5 < MIN_CHG5:     return None, "gate_chg5"
    ch1h = _f(o.get("chg_1h"))
    if ch1h < MIN_CHG1H:    return None, "gate_chg1h"
    fdv = _f(o.get("fdv"))
    mcap = _f(o.get("market_cap"))
    if fdv and fdv > MAX_FDV:   return None, "gate_fdv"
    if mcap and mcap > MAX_MCAP: return None, "gate_mcap"

    # Score buckets (simple + stable)
    s_liq = 2.0 if liq>=20000 else (1.0 if liq>=5000 else 0.0)
    s_v5  = 3.0 if v5>=2000 else (2.0 if v5>=500 else (1.0 if v5>=100 else 0.0))
    s_ch5 = max(0.0, min(2.0, ch5/30.0*2.0))  # 0..2
    s_tx  = max(0.0, min(2.0, tx5/20.0*2.0))  # 0..2

    score = s_liq + s_v5 + s_ch5 + s_tx
    dbg = {"liq":liq,"vol5m":v5,"chg5m":ch5,"tx5m":tx5,"s_liq":s_liq,"s_v5":s_v5,"s_ch5":s_ch5,"s_tx":s_tx}
    return score, dbg

def main():
    if not INP.exists():
        print("missing input:", INP)
        return 2

    kept = []
    n=0
    now=int(time.time())

    for line in INP.read_text(encoding="utf-8", errors="ignore").splitlines():
        line=line.strip()
        if not line:
            continue
        n += 1
        try:
            o=json.loads(line)
        except Exception:
            continue

        sc, dbg = score_row(o)
        if sc is None:
            continue

        o["score"] = float(sc)
        o["score_reason"] = "ok"
        o["score_dbg"] = dbg
        o["scored_at"] = now
        kept.append(o)

    kept.sort(key=lambda x: float(x.get("score") or 0.0), reverse=True)
    if TOPN > 0:
        kept = kept[:TOPN]

    OUT.write_text("\n".join(json.dumps(r, ensure_ascii=False) for r in kept) + ("\n" if kept else ""), encoding="utf-8")
    print("scored:", len(kept), "of", n, "->", OUT, "bytes=", OUT.stat().st_size if OUT.exists() else 0)

    return 0

if __name__ == "__main__":
    raise SystemExit(main())
