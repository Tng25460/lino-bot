from __future__ import annotations

import os
import sqlite3
import time
from dataclasses import dataclass
from typing import Any, Dict, Optional, Protocol

TOKEN_PROGRAM_ID = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
TOKEN_2022_PROGRAM_ID = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"


class RpcLike(Protocol):
    async def call(self, method: str, params: list) -> Any: ...


@dataclass
class RugResult:
    ok: bool
    reason: str
    details: Optional[Dict[str, Any]] = None


def _now_ts() -> int:
    return int(time.time())


def _db_path() -> str:
    return os.getenv("TRADES_DB_PATH", "state/trades.sqlite")


def _db() -> sqlite3.Connection:
    path = _db_path()
    os.makedirs(os.path.dirname(path), exist_ok=True)
    con = sqlite3.connect(path, timeout=30, isolation_level=None)
    con.row_factory = sqlite3.Row
    con.execute("PRAGMA journal_mode=WAL;")
    con.execute("PRAGMA synchronous=NORMAL;")
    con.execute("PRAGMA foreign_keys=ON;")
    con.execute(
        """
        CREATE TABLE IF NOT EXISTS rug_cache (
          mint TEXT PRIMARY KEY,
          ok INTEGER NOT NULL,
          reason TEXT NOT NULL,
          program_owner TEXT,
          checked_ts INTEGER NOT NULL,
          ttl_s INTEGER NOT NULL,
          details_json TEXT
        );
        """
    )
    return con


def _cache_get(mint: str) -> Optional[RugResult]:
    try:
        con = _db()
        row = con.execute(
            "SELECT ok,reason,checked_ts,ttl_s,program_owner,details_json FROM rug_cache WHERE mint=?",
            (mint,),
        ).fetchone()
        con.close()
        if not row:
            return None
        checked_ts = int(row["checked_ts"])
        ttl_s = int(row["ttl_s"])
        if _now_ts() > checked_ts + ttl_s:
            return None
        details: Dict[str, Any] = {}
        if row["program_owner"]:
            details["program_owner"] = row["program_owner"]
        # details_json is optional; we keep it light
        return RugResult(ok=bool(int(row["ok"])), reason=str(row["reason"]), details=details or None)
    except Exception:
        return None


def _cache_put(mint: str, res: RugResult, *, program_owner: Optional[str], ttl_s: int) -> None:
    try:
        con = _db()
        con.execute(
            """
            INSERT INTO rug_cache(mint,ok,reason,program_owner,checked_ts,ttl_s,details_json)
            VALUES(?,?,?,?,?,?,?)
            ON CONFLICT(mint) DO UPDATE SET
              ok=excluded.ok,
              reason=excluded.reason,
              program_owner=excluded.program_owner,
              checked_ts=excluded.checked_ts,
              ttl_s=excluded.ttl_s,
              details_json=excluded.details_json
            """,
            (mint, 1 if res.ok else 0, res.reason, program_owner or "", _now_ts(), int(ttl_s), ""),
        )
        con.close()
    except Exception:
        pass


class AntiRug:
    """
    On-chain anti-rug checks (fast + pragmatic).

    Uses RPC methods:
      - getAccountInfo (jsonParsed) -> mint program owner + mint authorities
      - getTokenSupply -> total supply
      - getTokenLargestAccounts -> top holders share
    """

    def __init__(
        self,
        rpc: RpcLike,
        logger: Any,
        *,
        block_token_2022: bool = True,
        cache_ttl_ok_s: int = 6 * 3600,
        cache_ttl_bad_s: int = 30 * 60,
    ) -> None:
        self.rpc = rpc
        self.log = logger
        self.block_token_2022 = bool(block_token_2022)
        self.cache_ttl_ok_s = int(cache_ttl_ok_s)
        self.cache_ttl_bad_s = int(cache_ttl_bad_s)

    async def _get_mint_account_parsed(self, mint: str) -> Optional[Dict[str, Any]]:
        j = await self.rpc.call("getAccountInfo", [mint, {"encoding": "jsonParsed"}])
        v = (j or {}).get("value")
        if not v:
            return None
        return v

    async def _get_token_supply_ui(self, mint: str) -> Optional[float]:
        j = await self.rpc.call("getTokenSupply", [mint])
        val = ((j or {}).get("value") or {})
        ui = val.get("uiAmount")
        if ui is None:
            # fallback: amount/decimals
            try:
                amt = float(val.get("amount", "0"))
                dec = int(val.get("decimals", 0))
                return amt / (10**dec) if dec >= 0 else None
            except Exception:
                return None
        try:
            return float(ui)
        except Exception:
            return None

    async def _get_largest_accounts_ui(self, mint: str, limit: int = 10) -> Optional[list]:
        j = await self.rpc.call("getTokenLargestAccounts", [mint])
        arr = ((j or {}).get("value") or [])
        out = []
        for it in arr[: max(1, int(limit))]:
            try:
                out.append({"address": it["address"], "uiAmount": float(it.get("uiAmount", 0.0))})
            except Exception:
                continue
        return out

    async def check(
        self,
        mint: str,
        *,
        max_top1: float = 0.25,
        max_top10: float = 0.60,
        require_renounced: bool = True,
    ) -> RugResult:
        # cache first
        cached = _cache_get(mint)
        if cached is not None:
            return cached

        details: Dict[str, Any] = {}
        program_owner: Optional[str] = None

        try:
            acct = await self._get_mint_account_parsed(mint)
            if acct is None:
                res = RugResult(False, "mint introuvable (RPC)", details or None)
                _cache_put(mint, res, program_owner=None, ttl_s=self.cache_ttl_bad_s)
                return res

            program_owner = str(acct.get("owner") or "")
            details["program_owner"] = program_owner

            if self.block_token_2022 and program_owner == TOKEN_2022_PROGRAM_ID:
                res = RugResult(False, "token-2022 bloqu√©", details)
                _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_bad_s)
                return res

            if program_owner not in (TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID):
                res = RugResult(False, "owner programme SPL inconnu", details)
                _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_bad_s)
                return res

            data = acct.get("data") or {}
            parsed = (data.get("parsed") or {})
            info = (parsed.get("info") or {})

            mint_auth = info.get("mintAuthority")
            freeze_auth = info.get("freezeAuthority")
            details["mintAuthority"] = mint_auth
            details["freezeAuthority"] = freeze_auth

            if require_renounced and (mint_auth is not None or freeze_auth is not None):
                res = RugResult(False, "mint/freeze authority non renounced", details)
                _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_bad_s)
                return res

            supply = await self._get_token_supply_ui(mint)
            if supply is None or supply <= 0:
                res = RugResult(False, "supply introuvable/zero", details)
                _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_bad_s)
                return res
            details["supply_ui"] = supply

            top = await self._get_largest_accounts_ui(mint, limit=10)
            if not top:
                res = RugResult(False, "holders introuvables", details)
                _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_bad_s)
                return res

            top_amounts = [float(x.get("uiAmount", 0.0)) for x in top]
            top1 = (top_amounts[0] / supply) if top_amounts else 1.0
            top10 = (sum(top_amounts[:10]) / supply) if top_amounts else 1.0
            details["top1_ratio"] = top1
            details["top10_ratio"] = top10

            if top1 > float(max_top1):
                res = RugResult(False, f"top1 trop haut ({top1:.2%})", details)
                _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_bad_s)
                return res

            if top10 > float(max_top10):
                res = RugResult(False, f"top10 trop haut ({top10:.2%})", details)
                _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_bad_s)
                return res

            res = RugResult(True, "ok", details)
            _cache_put(mint, res, program_owner=program_owner, ttl_s=self.cache_ttl_ok_s)
            return res

        except Exception as e:
            # if RPC is angry (429), we mark short TTL to retry soon
            msg = str(e)
            res = RugResult(False, f"holders check fail: {msg}", details or None)
            _cache_put(mint, res, program_owner=program_owner, ttl_s=180)  # 3 minutes
            return res
