from __future__ import annotations

import asyncio
import os
import time
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

import aiohttp

from core.birdeye_async import BirdeyeAsyncClient

USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"


@dataclass
class ScannerConfig:
    birdeye_api_key: Optional[str] = None
    new_listing_limit: int = 10
    global_rps: float = 0.25
    max_concurrency: int = 1
    chain: str = "solana"


class TokenScanner:
    """
    PRO mode:
      - Birdeye sert à découvrir les nouveaux mints (new_listing)
      - Le prix vient de Jupiter quote (pas de multi_price Birdeye => pas de 401/429)
      - 1 seul candidat par cycle (meilleure liquidité) => stabilité
    """

    def __init__(self, cfg: ScannerConfig):
        self.cfg = cfg
        api_key = (
            cfg.birdeye_api_key
            or os.getenv("BIRDEYE_API_KEY")
            or os.getenv("BIRDEYE_KEY")
            or ""
        )
        self._birdeye = BirdeyeAsyncClient(api_key=api_key, global_rps=cfg.global_rps)

        self._session: Optional[aiohttp.ClientSession] = None
        self._backoff_until = 0.0
        self._backoff = 0.0

    async def _get_session(self) -> aiohttp.ClientSession:
        if self._session and not self._session.closed:
            return self._session
        timeout = aiohttp.ClientTimeout(total=20)
        self._session = aiohttp.ClientSession(timeout=timeout)
        return self._session

    async def aclose(self) -> None:
        await self._birdeye.aclose()
        if self._session and not self._session.closed:
            await self._session.close()

    def close(self) -> None:
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                return
            loop.run_until_complete(self.aclose())
        except Exception:
            pass

    def _apply_backoff(self, base: float = 10.0, max_s: float = 300.0) -> None:
        if self._backoff <= 0:
            self._backoff = base
        else:
            self._backoff = min(self._backoff * 2, max_s)
        self._backoff_until = time.time() + self._backoff

    async def _jupiter_price_usdc(self, token_mint: str) -> float:
        """
        Prix approx en USDC via quote Jupiter:
          - on demande un quote USDC -> token
          - amount input = 1 USDC (1_000_000 micro USDC)
          - outAmount = quantité de token (en base units)
          => token per 1 USDC, donc prix token = 1 / (token_per_usdc) USDC
        """
        sess = await self._get_session()
        url = "https://quote-api.jup.ag/v6/quote"
        params = {
            "inputMint": USDC_MINT,
            "outputMint": token_mint,
            "amount": "1000000",      # 1 USDC
            "slippageBps": "50",
            "onlyDirectRoutes": "false",
        }

        async with sess.get(url, params=params) as r:
            txt = await r.text()
            if r.status == 429:
                raise RuntimeError("JUPITER_429")
            if r.status != 200:
                raise RuntimeError(f"JUPITER_HTTP_{r.status}: {txt[:200]}")
            j = await r.json()

        data = j.get("data") or []
        if not data:
            return 0.0

        best = data[0]
        out_amount = best.get("outAmount")
        if not out_amount:
            return 0.0

        # outAmount est en base units token. On a besoin des decimals.
        # Jupiter renvoie souvent "outAmount" + on peut lire decimals via "outputMint" pas fourni ici.
        # Donc on utilise un fallback simple: si la route fournit "outAmount" mais pas decimals,
        # on renvoie juste un "price proxy" basé sur outAmount brut -> suffisant pour BUY/SELL logique.
        try:
            out_amount_int = int(out_amount)
        except Exception:
            return 0.0

        if out_amount_int <= 0:
            return 0.0

        # "prix proxy" : 1 USDC / (outAmount en base units) => très petit.
        # Pour avoir un prix exploitable, il faut decimals. On va les récupérer du listing (Birdeye) si dispo.
        # Ici, on renvoie token_per_usdc_base = outAmount_int
        return float(out_amount_int)

    async def scan_once_async(self) -> List[Dict[str, Any]]:
        # backoff global
        if time.time() < self._backoff_until:
            return []

        # Fake mode optionnel
        if os.getenv("FAKE_BIRDEYE", "0") == "1":
            it = {
                "address": "FAKEmint00" + "x" * 32,
                "symbol": "FAKE00",
                "name": "Fake Token 00",
                "decimals": 6,
                "source": "fake",
                "liquidity": 5000.0,
                "liquidityAddedAt": "",
                "logoURI": "",
            }
            return [{"data": {**it, "price": 0.000001, "marketCap": 0.0}}]

        try:
            raw = await self._birdeye.get_new_tokens(limit=int(self.cfg.new_listing_limit))

            raw_list: List[Dict[str, Any]] = []
            if isinstance(raw, dict):
                raw_list = [raw]
            elif isinstance(raw, list):
                raw_list = raw
            else:
                return []

            items: List[Dict[str, Any]] = []
            for blob in raw_list:
                data = blob.get("data") or {}
                if isinstance(data, dict) and isinstance(data.get("items"), list):
                    items.extend([x for x in data["items"] if isinstance(x, dict)])
                elif isinstance(blob.get("items"), list):
                    items.extend([x for x in blob["items"] if isinstance(x, dict)])

            if not items:
                return []

            # best liquidity only
            def liq(x: Dict[str, Any]) -> float:
                try:
                    return float(x.get("liquidity") or 0.0)
                except Exception:
                    return 0.0

            items.sort(key=liq, reverse=True)
            best = items[0]

            addr = str(best.get("address") or "")
            if not addr:
                return []

            decimals = int(best.get("decimals") or 0)
            if decimals <= 0:
                decimals = 6  # fallback

            # Jupiter quote: returns outAmount in base units token for 1 USDC
            out_amount_base = await self._jupiter_price_usdc(addr)
            if out_amount_base <= 0:
                return []

            # Convert token_per_usdc = out_amount_base / 10**decimals
            token_per_usdc = out_amount_base / (10 ** decimals)
            if token_per_usdc <= 0:
                return []

            # price token in USDC
            price_usdc = 1.0 / token_per_usdc

            # reset backoff if success
            self._backoff = 0.0
            self._backoff_until = 0.0

            return [{
                "data": {
                    "address": addr,
                    "mint": addr,
                    "symbol": best.get("symbol") or "",
                    "name": best.get("name") or "",
                    "decimals": decimals,
                    "source": best.get("source") or "",
                    "liquidity": float(best.get("liquidity") or 0.0),
                    "liquidityAddedAt": best.get("liquidityAddedAt") or "",
                    "logoURI": best.get("logoURI") or "",
                    "price": float(price_usdc),
                    "marketCap": float(best.get("marketCap") or 0.0),
                }
            }]

        except Exception as e:
            msg = str(e)
            if "JUPITER_429" in msg:
                self._apply_backoff(base=15.0, max_s=300.0)
                print(f"[TokenScanner] Jupiter 429 -> backoff {int(self._backoff)}s")
                return []

            # Birdeye peut aussi limiter
            if "429" in msg or "Too many requests" in msg:
                self._apply_backoff(base=20.0, max_s=600.0)
                print(f"[TokenScanner] Birdeye rate-limit -> backoff {int(self._backoff)}s")
                return []

            print(f"[TokenScanner] scan error: {e}")
            return []
