from __future__ import annotations

import asyncio
import time
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Set

import httpx


@dataclass
class ScannerConfig:
    # combien de tokens "latest" on récupère à chaque tour
    new_listing_limit: int = 5

    # rps global (0.1 => 1 req / 10 sec)
    global_rps: float = 0.1
    max_concurrency: int = 1  # gardé pour compat, on reste simple

    # filtres (USD)
    min_liquidity_usd: float = 1000.0
    max_market_cap_usd: float = 300000.0

    # dédoublonnage : on évite de retraiter le même token pendant X secondes
    seen_ttl_sec: float = 900.0  # 15 min


class TokenScanner:
    """
    Scanner "dernieres sorties" via DEXScreener (gratuit, sans clé):
      - GET https://api.dexscreener.com/token-profiles/latest/v1  (rate-limit 60 rpm)
      - GET https://api.dexscreener.com/tokens/v1/solana/{tokenAddresses} (rate-limit 300 rpm, 30 tokens max)
    Source: https://docs.dexscreener.com/api/reference
    """

    def __init__(self, cfg: ScannerConfig):
        self.cfg = cfg
        self._base = "https://api.dexscreener.com"
        self._client = httpx.AsyncClient(
            headers={"accept": "application/json"},
            timeout=20.0,
            follow_redirects=True,
        )
        self._last_req = 0.0
        self._seen: Dict[str, float] = {}  # token -> ts

    async def aclose(self) -> None:
        await self._client.aclose()

    async def _throttle(self) -> None:
        # simple throttle global
        if self.cfg.global_rps <= 0:
            return
        min_dt = 1.0 / float(self.cfg.global_rps)
        now = time.time()
        dt = now - self._last_req
        if dt < min_dt:
            await asyncio.sleep(min_dt - dt)
        self._last_req = time.time()

    def _gc_seen(self) -> None:
        now = time.time()
        ttl = float(self.cfg.seen_ttl_sec)
        dead = [k for k, ts in self._seen.items() if (now - ts) > ttl]
        for k in dead:
            self._seen.pop(k, None)

    async def _get_latest_profiles(self) -> List[Dict[str, Any]]:
        await self._throttle()
        url = f"{self._base}/token-profiles/latest/v1"
        r = await self._client.get(url)
        r.raise_for_status()
        data = r.json()
        # docs montrent un objet/array selon endpoint, ici c'est généralement une liste
        if isinstance(data, list):
            return data
        if isinstance(data, dict) and "data" in data and isinstance(data["data"], list):
            return data["data"]
        return []

    async def _get_tokens_pairs(self, token_addresses: List[str]) -> List[Dict[str, Any]]:
        # endpoint: /tokens/v1/{chainId}/{tokenAddresses} tokenAddresses=csv up to 30
        out: List[Dict[str, Any]] = []
        for i in range(0, len(token_addresses), 30):
            chunk = token_addresses[i:i+30]
            if not chunk:
                continue
            await self._throttle()
            url = f"{self._base}/tokens/v1/solana/{','.join(chunk)}"
            r = await self._client.get(url)
            r.raise_for_status()
            data = r.json()
            if isinstance(data, list):
                out.extend(data)
        return out

    async def scan_once_async(self) -> List[Dict[str, Any]]:
        """
        Retourne une liste d'overviews compatible engine.on_overviews().
        Champs minimum:
          - address (mint)
          - symbol / name (best-effort)
          - liquidity (USD)
          - price (USD approx)
          - marketCap (USD approx)
        """
        self._gc_seen()

        profiles = await self._get_latest_profiles()

        # On garde SOLANA uniquement + dédoublonnage TTL
        candidates: List[str] = []
        for p in profiles:
            try:
                chain = (p.get("chainId") or "").strip().lower()
                token = (p.get("tokenAddress") or "").strip()
                if chain != "solana" or not token:
                    continue
                if token in self._seen:
                    continue
                candidates.append(token)
            except Exception:
                continue

        # limite
        candidates = candidates[: int(self.cfg.new_listing_limit)]

        if not candidates:
            return []

        pairs = await self._get_tokens_pairs(candidates)

        # Build overviews
        overviews: List[Dict[str, Any]] = []
        now = time.time()

        for pair in pairs:
            try:
                base = pair.get("baseToken") or {}
                mint = (base.get("address") or "").strip()
                if not mint:
                    continue

                # DEXScreener retourne souvent la "liquidity" en dict {usd:.., base:.., quote:..}
                liq = pair.get("liquidity") or {}
                liq_usd = float(liq.get("usd") or 0.0)

                # fdv ~ fully diluted valuation (souvent utilisé comme "marketcap" approx)
                mc = pair.get("fdv")
                mc_usd = float(mc) if mc is not None else 0.0

                price_usd = pair.get("priceUsd")
                price = float(price_usd) if price_usd is not None else 0.0

                # filtres
                if liq_usd < float(self.cfg.min_liquidity_usd):
                    continue
                if mc_usd > 0 and mc_usd > float(self.cfg.max_market_cap_usd):
                    continue

                symbol = (base.get("symbol") or "").strip() or "UNK"
                name = symbol

                overviews.append(
                    {
                        "address": mint,
                        "symbol": symbol,
                        "name": name,
                        "decimals": 6,  # best effort
                        "source": "dexscreener",
                        "liquidityAddedAt": None,
                        "logoURI": None,
                        "liquidity": liq_usd,
                        "marketCap": mc_usd,
                        "price": price,
                    }
                )

                self._seen[mint] = now
            except Exception:
                continue

        return overviews
