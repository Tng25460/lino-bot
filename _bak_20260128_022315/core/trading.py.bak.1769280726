from __future__ import annotations

import json
import os
import time
from typing import Any, Dict, List, Optional, Tuple

from config import settings


def _now() -> float:
    return time.time()


def _safe_float(x: Any, default: float = 0.0) -> float:
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default


class TradingEngine:
    """
    Stratégie:
      - Buy: selon scanner + risk_checker
      - Sell:
          SL: -10% depuis entry
          Trailing: -10% depuis le plus haut (ATH) -> si price <= high * 0.90 => SELL
    Anti double-buy:
      - si position OPEN existe déjà => skip
      - inflight set => skip pendant tx
      - cooldown par mint => skip
    """

    def __init__(self, wallet, logger, positions_file: str, mode: str):
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file or "positions.json"
        self.mode = (mode or "PAPER").upper().strip()

        from core.real_executor import RealExecutor
        from core.paper_executor import PaperExecutor

        self.executor = RealExecutor(wallet, logger) if self.mode == "REAL" else PaperExecutor(wallet, logger)

        # stratégie
        self.sl_pct = float(getattr(settings, "STOP_LOSS_PCT", -0.10))  # -10%
        self.trailing_pct = float(getattr(settings, "TRAILING_PCT", -0.10))  # -10% depuis high

        # anti spam
        self.last_buy_ts_global: float = 0.0
        self.last_buy_ts_by_mint: Dict[str, float] = {}
        self.buy_inflight: set[str] = set()
        self.sell_inflight: set[str] = set()

        # state
        self.positions: Dict[str, Dict[str, Any]] = {}
        self._load_positions()

        self.logger.info(
            "[TradingEngine] Initialisé (mode=%s, SL=%s%%, trailing=%s%% du high). positions_file=%s",
            self.mode,
            int(self.sl_pct * 100),
            int(self.trailing_pct * 100),
            self.positions_file,
        )

    # ---------------- persistence ----------------
    def _load_positions(self) -> None:
        try:
            if os.path.exists(self.positions_file):
                with open(self.positions_file, "r", encoding="utf-8") as f:
                    self.positions = json.load(f) or {}
            else:
                self.positions = {}
        except Exception as e:
            self.logger.error("[POSITIONS] load error: %s", e, exc_info=True)
            self.positions = {}

    def _save_positions(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.positions_file), exist_ok=True)
        except Exception:
            # si positions_file est juste "positions.json" (pas de dossier)
            pass

        tmp = self.positions_file + ".tmp"
        try:
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(self.positions, f, indent=2, sort_keys=True)
            os.replace(tmp, self.positions_file)
        except Exception as e:
            self.logger.error("[POSITIONS] save error: %s", e, exc_info=True)
            try:
                if os.path.exists(tmp):
                    os.remove(tmp)
            except Exception:
                pass

    # ---------------- helpers ----------------
    def _is_open(self, mint: str) -> bool:
        p = self.positions.get(mint) or {}
        return (p.get("status") == "OPEN")

    def _open_positions(self) -> Dict[str, Dict[str, Any]]:
        return {m: p for m, p in (self.positions or {}).items() if p.get("status") == "OPEN"}

    def _update_high(self, pos: Dict[str, Any], price: float) -> None:
        high = _safe_float(pos.get("high_price"), _safe_float(pos.get("entry_price"), 0.0))
        if price > high:
            pos["high_price"] = price

    def _should_sell(self, pos: Dict[str, Any], price: float) -> Tuple[bool, str]:
        entry = _safe_float(pos.get("entry_price"), 0.0)
        if entry <= 0.0 or price <= 0.0:
            return False, "no_price"

        # stop loss -10%
        if price <= entry * (1.0 + self.sl_pct):
            return True, "STOP_LOSS"

        # trailing -10% depuis ATH
        high = _safe_float(pos.get("high_price"), entry)
        if high > 0 and price <= high * (1.0 + self.trailing_pct):
            return True, "TRAILING_FROM_HIGH"

        return False, "hold"

    async def _fetch_price_usd_jupiter(self, mint: str) -> Optional[float]:
        """
        Fetch prix USD via Jupiter (si le scanner ne renvoie pas le mint).
        Supporte JUPITER_API_KEY + base url.
        """
        try:
            import httpx

            base = os.getenv("JUPITER_BASE_URL", getattr(settings, "JUPITER_BASE_URL", "https://api.jup.ag"))
            api_key = os.getenv("JUPITER_API_KEY", getattr(settings, "JUPITER_API_KEY", "")) or ""
            headers = {}
            if api_key:
                headers["x-api-key"] = api_key

            # endpoint "price/v2" (ids)
            url = base.rstrip("/") + "/price/v2"
            params = {"ids": mint}

            async with httpx.AsyncClient(timeout=10.0, headers=headers) as client:
                r = await client.get(url, params=params)
                r.raise_for_status()
                js = r.json()

            # formats possibles:
            # { "data": { "<mint>": { "price": 0.123 } } }
            data = js.get("data") or {}
            row = data.get(mint) or {}
            price = row.get("price")
            if price is None:
                # parfois liste/structure différente
                return None
            return float(price)
        except Exception:
            return None

    # ---------------- core loop ----------------
    async def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        """
        1) Met à jour / vend les positions (SL / trailing)
           - prix via overviews si dispo
           - sinon fetch Jupiter si position ouverte
        2) Tente un BUY (1 seul max par cycle) si pas déjà en position sur ce mint
        """
        overviews = overviews or []
        self.logger.info("[DBG_ENTER] on_overviews called, n=%s", len(overviews))

        # map mint->price depuis scanner
        price_map: Dict[str, float] = {}
        for ov in overviews:
            mint = ov.get("mint") or ov.get("token") or ov.get("address")
            px = ov.get("price_usd") or ov.get("price")
            if mint and px not in (None, 0, 0.0):
                price_map[str(mint)] = _safe_float(px, 0.0)

        # 1) manage sells
        await self._manage_positions(price_map)

        # 2) buy (au plus 1 par tick)
        await self._maybe_buy(overviews, risk_checker)

        self._print_portfolio()

    async def _manage_positions(self, price_map: Dict[str, float]) -> None:
        opens = self._open_positions()
        if not opens:
            return

        for mint, pos in opens.items():
            # prix: scanner d'abord, sinon Jupiter
            price = _safe_float(price_map.get(mint), 0.0)
            if price <= 0.0:
                price = _safe_float(await self._fetch_price_usd_jupiter(mint) or 0.0, 0.0)

            if price <= 0.0:
                continue

            # update ATH
            self._update_high(pos, price)

            do_sell, reason = self._should_sell(pos, price)
            if not do_sell:
                continue

            if mint in self.sell_inflight:
                continue

            self.sell_inflight.add(mint)
            try:
                self.logger.info(
                    "[SELL] %s reason=%s entry=%s high=%s now=%s",
                    mint,
                    reason,
                    _safe_float(pos.get("entry_price"), 0.0),
                    _safe_float(pos.get("high_price"), 0.0),
                    price,
                )

                res = self.executor.sell(mint)
                if hasattr(res, "__await__"):
                    res = await res

                pos["status"] = "CLOSED"
                pos["closed_ts"] = _now()
                pos["exit_price"] = price
                pos["exit_reason"] = reason

                self.positions[mint] = pos
                self._save_positions()

                self.logger.info("[SELL OK] %s reason=%s", mint, reason)

            except Exception as e:
                self.logger.error("[SELL ERROR] %s: %s", mint, e, exc_info=True)
            finally:
                self.sell_inflight.discard(mint)

    async def _maybe_buy(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        now = _now()

        # cooldown global
        cooldown_global = float(getattr(settings, "BUY_COOLDOWN_SECONDS", 0))
        if cooldown_global > 0 and (now - float(self.last_buy_ts_global or 0.0) < cooldown_global):
            return

        sol_amount = float(getattr(settings, "BUY_AMOUNT_SOL", 0.0))
        if sol_amount <= 0:
            return

        did_buy = False

        for ov in overviews:
            if did_buy:
                break

            mint: Optional[str] = ov.get("mint") or ov.get("token") or ov.get("address")
            price = ov.get("price_usd") or ov.get("price")
            dex = (ov.get("dex_id") or "").lower().strip()

            if not mint or price in (None, 0, 0.0):
                continue
            mint = str(mint)

            # REAL: Raydium only
            if self.mode == "REAL" and dex and dex != "raydium":
                continue

            # anti double-buy: déjà OPEN ?
            if self._is_open(mint):
                continue

            # anti inflight
            if mint in self.buy_inflight:
                continue

            # cooldown par mint (optionnel mais très efficace)
            cooldown_mint = float(getattr(settings, "BUY_COOLDOWN_PER_MINT_SECONDS", 900))  # 15 min default
            last_m = float(self.last_buy_ts_by_mint.get(mint) or 0.0)
            if cooldown_mint > 0 and (now - last_m < cooldown_mint):
                continue

            self.logger.info(
                "[DBG_PRE_RISK] mint=%s liq=%s mc=%s price=%s dex=%s",
                mint, ov.get("liquidity_usd"), ov.get("marketcap_usd"), ov.get("price_usd"), dex
            )

            ok, reason = risk_checker.allow_buy(ov)
            self.logger.info("[DBG_RISK] mint=%s ok=%s reason=%s", mint, ok, reason)
            if not ok:
                continue

            px = _safe_float(price, 0.0)
            if px <= 0:
                continue

            self.buy_inflight.add(mint)
            try:
                self.logger.info("[BUY] Signal %s price~%.10f size=%.4f SOL mode=%s", mint, px, sol_amount, self.mode)

                res = self.executor.buy(mint, sol_amount, px)
                if hasattr(res, "__await__"):
                    res = await res

                # on marque la position
                self.positions[mint] = {
                    "mint": mint,
                    "status": "OPEN",
                    "entry_price": px,
                    "high_price": px,
                    "opened_ts": now,
                    "mode": self.mode,
                }
                self._save_positions()

                self.last_buy_ts_global = now
                self.last_buy_ts_by_mint[mint] = now
                did_buy = True

                self.logger.info("[BUY OK] %s", mint)

                # --- persist OPEN position (enables SELL logic) ---
                self.positions[mint] = {
                    "status": "OPEN",
                    "entry_price": float(price),
                    "high_price": float(price),
                    "buy_ts": now,
                    "sol_amount": sol_amount,
                }
                self._save_positions()
                self.logger.info("[POSITION OPENED] %s entry=%s", mint, price)

            except Exception as e:
                self.logger.error("[BUY ERROR] %s: %s", mint, e, exc_info=True)
            finally:
                self.buy_inflight.discard(mint)

    def _print_portfolio(self) -> None:
        opens = self._open_positions()
        open_n = len(opens)
        closed_n = len([p for p in (self.positions or {}).values() if p.get("status") == "CLOSED"])

        # petit résumé positions ouvertes
        if open_n > 0:
            # log compact
            sample = list(opens.items())[:3]
            s = ", ".join([f"{m[:4]}.. entry={_safe_float(p.get('entry_price'),0):.6g} high={_safe_float(p.get('high_price'),0):.6g}" for m, p in sample])
            self.logger.info("[OPEN_POS] n=%d %s", open_n, s)

        self.logger.info(
            "[PORTFOLIO] mode=%s open=%d closed=%d positions_file=%s",
            self.mode, open_n, closed_n, self.positions_file
        )
