from __future__ import annotations

import asyncio
import logging
import math
import time
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

import aiohttp


# -----------------------------
# Logging
# -----------------------------
logger = logging.getLogger("TokenScanner")


# -----------------------------
# Helpers
# -----------------------------
def _cfg_get(cfg: Any, *names: str, default: Any = None) -> Any:
    """Retourne cfg.<name> pour le 1er name existant, sinon default."""
    for n in names:
        if hasattr(cfg, n):
            return getattr(cfg, n)
        if isinstance(cfg, dict) and n in cfg:
            return cfg.get(n)
    return default


DEFAULT_HEADERS = {
    "Accept": "application/json",
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) LinoBot/1.0",
}


class _RateLimiter:
    """Rate limiter simple (token bucket light) en req/s."""
    def __init__(self, rps: float):
        self.rps = max(0.1, float(rps))
        self._lock = asyncio.Lock()
        self._next = 0.0

    async def wait(self) -> None:
        async with self._lock:
            now = time.monotonic()
            if now < self._next:
                await asyncio.sleep(self._next - now)
            self._next = max(self._next, now) + (1.0 / self.rps)


# -----------------------------
# Public API expected by main.py
# -----------------------------
@dataclass
class ScannerConfig:
    """
    Contrat attendu par src/main.py:
      - new_listing_limit
      - global_rps
      - max_concurrency
    On accepte aussi d'autres champs, mais on ignore les kwargs inconnus.
    """
    new_listing_limit: int = 30
    global_rps: float = 2.0
    max_concurrency: int = 1

    chain: str = "solana"
    dexs: Tuple[str, ...] = ("raydium", "pumpfun")
    queries: Tuple[str, ...] = ("pump", "raydium", "bonk", "wif", "sol")

    # Filtres soft (pas bloquants si engine gère déjà)
    min_liquidity_usd: float = 2500.0

    # internal: debug
    debug: bool = False

    def __init__(self, **kwargs: Any):
        # Defaults
        self.new_listing_limit = int(kwargs.pop("new_listing_limit", kwargs.pop("scan_limit", 30)))
        self.global_rps = float(kwargs.pop("global_rps", kwargs.pop("scanner_rps", 2.0)))
        self.max_concurrency = int(kwargs.pop("max_concurrency", kwargs.pop("concurrency", 1)))

        self.chain = str(kwargs.pop("chain", kwargs.pop("SCANNER_CHAIN", "solana")))
        dexs = kwargs.pop("dexs", kwargs.pop("SCANNER_DEXES", ("raydium", "pumpfun")))
        queries = kwargs.pop("queries", kwargs.pop("SCANNER_QUERIES", ("pump", "raydium", "bonk", "wif", "sol")))

        # Normalize sequences
        self.dexs = tuple(str(x).lower() for x in (dexs or ()))
        self.queries = tuple(str(x) for x in (queries or ()))

        self.min_liquidity_usd = float(kwargs.pop("min_liquidity_usd", kwargs.pop("MIN_LIQUIDITY_USD", 2500.0)))
        self.debug = bool(kwargs.pop("debug", False))

        # ignore any remaining kwargs (compat)


class TokenScanner:
    """
    Scanner DexScreener -> overviews normalisés.

    Doit fournir:
      - scan_once_async()
      - (aliases) get_overviews/fetch_overviews/scan_overviews/scan
    """

    DEX_SEARCH_URL = "https://api.dexscreener.com/latest/dex/search/?q={q}"

    def __init__(self, cfg: Union[ScannerConfig, Any]):
        # cfg peut être ScannerConfig OU config.settings (module)
        if isinstance(cfg, ScannerConfig):
            self.cfg = cfg
        else:
            # construire un ScannerConfig à partir des attributs du module settings.py
            self.cfg = ScannerConfig(
                new_listing_limit=int(_cfg_get(cfg, "new_listing_limit", "scan_limit", default=30)),
                global_rps=float(_cfg_get(cfg, "global_rps", "scanner_rps", default=2.0)),
                max_concurrency=int(_cfg_get(cfg, "max_concurrency", "scanner_concurrency", default=1)),
                chain=str(_cfg_get(cfg, "SCANNER_CHAIN", "scanner_chain", default="solana")),
                dexs=_cfg_get(cfg, "SCANNER_DEXES", "scanner_dexes", default=("raydium", "pumpfun")),
                queries=_cfg_get(cfg, "SCANNER_QUERIES", "scanner_queries", default=("pump", "raydium", "bonk", "wif", "sol")),
                min_liquidity_usd=float(_cfg_get(cfg, "MIN_LIQUIDITY_USD", "min_liquidity_usd", default=2500.0)),
                debug=bool(_cfg_get(cfg, "SCANNER_DEBUG", "debug", default=False)),
            )

        self._rl = _RateLimiter(self.cfg.global_rps)
        self._sem = asyncio.Semaphore(max(1, int(self.cfg.max_concurrency)))

        logger.info(f"[Scanner] ✅ limit={self.cfg.new_listing_limit} rps={self.cfg.global_rps} conc={self.cfg.max_concurrency}")

    # -----------------------------
    # Public method expected by main.py
    # -----------------------------
    async def scan_once_async(self) -> List[Dict[str, Any]]:
        pairs: List[Dict[str, Any]] = await self._fetch_pairs()
        ovs = [self._to_overview(p) for p in pairs]
        # tri final
        ovs.sort(key=lambda x: float(x.get("score", 0.0)), reverse=True)
        return ovs[: int(self.cfg.new_listing_limit)]

    # Aliases (compat)
    async def get_overviews(self) -> List[Dict[str, Any]]:
        return await self.scan_once_async()

    async def fetch_overviews(self) -> List[Dict[str, Any]]:
        return await self.scan_once_async()

    async def scan_overviews(self) -> List[Dict[str, Any]]:
        return await self.scan_once_async()

    async def scan(self) -> List[Dict[str, Any]]:
        return await self.scan_once_async()

    # -----------------------------
    # Internal: fetching + scoring
    # -----------------------------
    async def _dex_search(self, session: aiohttp.ClientSession, q: str) -> List[Dict[str, Any]]:
        url = self.DEX_SEARCH_URL.format(q=q)
        await self._rl.wait()
        async with self._sem:
            async with session.get(url, headers=DEFAULT_HEADERS, timeout=aiohttp.ClientTimeout(total=20)) as resp:
                if resp.status != 200:
                    txt = await resp.text()
                    logger.warning(f"[TokenScanner] DexScreener HTTP {resp.status} for q={q} body={txt[:200]}")
                    return []
                data = await resp.json(content_type=None)
                pairs = data.get("pairs") or []
                if not isinstance(pairs, list):
                    return []
                return pairs

    async def _fetch_pairs(self) -> List[Dict[str, Any]]:
        queries = list(self.cfg.queries) if self.cfg.queries else ["solana"]
        chain = (self.cfg.chain or "solana").lower()
        dexs = set((d or "").lower() for d in (self.cfg.dexs or ()))

        async with aiohttp.ClientSession() as session:
            all_pairs: List[Dict[str, Any]] = []
            for q in queries:
                try:
                    ps = await self._dex_search(session, q)
                    all_pairs.extend(ps)
                except Exception as e:
                    logger.exception(f"[TokenScanner] dex_search error q={q}: {e}")

        # filtre chain/dex + dédup
        seen: set[str] = set()
        filtered: List[Dict[str, Any]] = []
        for p in all_pairs:
            try:
                if (p.get("chainId") or "").lower() != chain:
                    continue
                if dexs:
                    if (p.get("dexId") or "").lower() not in dexs:
                        continue
                pair_addr = str(p.get("pairAddress") or "")
                if not pair_addr:
                    continue
                key = f"{chain}:{(p.get('dexId') or '').lower()}:{pair_addr}"
                if key in seen:
                    continue
                seen.add(key)
                filtered.append(p)
            except Exception:
                continue

        # score & sort
        for p in filtered:
            p["score"] = self._score_pair(p)

        filtered.sort(key=lambda x: float(x.get("score", 0.0)), reverse=True)
        return filtered[: max(50, int(self.cfg.new_listing_limit) * 3)]

    def _score_pair(self, p: Dict[str, Any]) -> float:
        liq = float(((p.get("liquidity") or {}).get("usd") or 0.0))
        vol_m5 = float(((p.get("volume") or {}).get("m5") or 0.0))
        tx_m5 = (p.get("txns") or {}).get("m5") or {}
        buys = float(tx_m5.get("buys") or 0.0)
        sells = float(tx_m5.get("sells") or 0.0)
        txns_m5 = buys + sells

        # Score stable: log(liq) + log(vol) + sqrt(txns)
        s = 0.0
        s += math.log10(liq + 1.0) * 40.0
        s += math.log10(vol_m5 + 1.0) * 35.0
        s += math.sqrt(txns_m5) * 8.0
        return float(s)

    def _to_overview(self, pair: Dict[str, Any]) -> Dict[str, Any]:
        base = pair.get("baseToken") or {}
        mint = base.get("address") or pair.get("baseTokenAddress") or pair.get("mint") or None
        sym = base.get("symbol") or pair.get("symbol") or pair.get("sym") or None

        liq = float(((pair.get("liquidity") or {}).get("usd") or 0.0))
        vol_m5 = float(((pair.get("volume") or {}).get("m5") or 0.0))

        tx_m5 = (pair.get("txns") or {}).get("m5") or {}
        buys = int(tx_m5.get("buys") or 0)
        sells = int(tx_m5.get("sells") or 0)
        txns_m5 = int(buys + sells)

        # tx per minute from 5 minutes window
        tpm = float(txns_m5) / 5.0

        ov: Dict[str, Any] = {
            # --- Identité token/pair ---
            "mint": mint,
            "sym": sym,
            "symbol": sym,              # alias
            "ticker": sym,              # alias
            "chainId": pair.get("chainId"),
            "dexId": pair.get("dexId"),
            "pairAddress": pair.get("pairAddress"),
            "url": pair.get("url"),

            # --- Liquidité/volume/tx (alias multiples) ---
            "liq": liq,
            "liquidity_usd": liq,
            "liquidity": {"usd": liq},

            "vol_m5": vol_m5,
            "volume_m5_usd": vol_m5,
            "volume": {"m5": vol_m5},

            "txns_m5": txns_m5,
            "tpm": tpm,
            "tx_per_min": tpm,          # alias
            "tx_per_minute": tpm,       # alias
            "txns": {"m5": {"buys": buys, "sells": sells}},

            # --- Marketcap info (best-effort) ---
            "marketCap": float(pair.get("marketCap") or 0.0),
            "fdv": float(pair.get("fdv") or 0.0),

            # --- Prices ---
            "priceUsd": pair.get("priceUsd"),
            "priceNative": pair.get("priceNative"),

            # --- Score final ---
            "score": float(pair.get("score") or 0.0),

            # --- Raw for debugging ---
            "_raw": pair,
        }
        return ov
