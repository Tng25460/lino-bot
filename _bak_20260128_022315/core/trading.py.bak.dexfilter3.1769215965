from __future__ import annotations

import time
from typing import Any, Dict, List, Optional

from config import settings


class TradingEngine:
    def __init__(self, wallet, logger, positions_file: str, mode: str):
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file
        self.mode = (mode or "PAPER").upper().strip()

        self.last_buy_ts: float = 0.0

        from core.real_executor import RealExecutor
        from core.paper_executor import PaperExecutor

        if self.mode == "REAL":
            self.executor = RealExecutor(wallet, logger)
        else:
            self.executor = PaperExecutor(wallet, logger)

        self.logger.info("[TradingEngine] Initialisé (mode=%s, SL + trailing activé).", self.mode)

    async def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        self.logger.info("[DBG_ENTER] on_overviews called, n=%s", (len(overviews) if overviews else 0))

        did_buy = False
        now = time.time()

        for ov in (overviews or []):
            if did_buy:
                break

            # --- Champs venant de ton scanner (dexscreener-like) ---
            mint: Optional[str] = ov.get("mint") or ov.get("token") or ov.get("address")
            price = ov.get("price_usd") or ov.get("price")
            dex = (ov.get("dex_id") or "").lower().strip()

            if not mint or price in (None, 0, 0.0):
                continue

            # REAL: Raydium only (évite pumpswap / meteora / etc.)
            if self.mode == "REAL" and dex and dex != "raydium":
                self.logger.info("[SKIP] dex=%s mint=%s (REAL=Raydium only)", dex, mint)
                continue

            # cooldown global
            cooldown = float(getattr(settings, "BUY_COOLDOWN_SECONDS", 0))
            if cooldown > 0 and (now - float(self.last_buy_ts or 0.0) < cooldown):
                continue

            self.logger.info(
                "[DBG_PRE_RISK] mint=%s liq=%s mc=%s price=%s dex=%s",
                mint, ov.get("liquidity_usd"), ov.get("marketcap_usd"), ov.get("price_usd"), dex
            )

            ok, reason = risk_checker.allow_buy(ov)
            self.logger.info("[DBG_RISK] mint=%s ok=%s reason=%s", mint, ok, reason)

            if not ok:
                self.logger.info("[BUY] Skip %s (risk: %s)", mint, reason)
                continue

            sol_amount = float(getattr(settings, "BUY_AMOUNT_SOL", 0.0))
            self.logger.info(
                "[BUY] Signal %s price~%.8f size=%.4f SOL mode=%s",
                mint, float(price), sol_amount, self.mode
            )
            self.logger.info(
                "[DBG_BEFORE_BUY] mint=%s price=%s sol_amount=%s mode=%s",
                mint, price, sol_amount, self.mode
            )

            try:
                res = self.executor.buy(mint, sol_amount, float(price))
                if hasattr(res, "__await__"):
                    res = await res

                self.last_buy_ts = now
                did_buy = True

            except Exception as e:
                self.logger.error("[BUY ERROR] %s: %s", mint, e, exc_info=True)

        self._print_portfolio()

    def _print_portfolio(self) -> None:
        # placeholder simple (tu remplaceras par positions.json etc.)
        self.logger.info(
            "[PORTFOLIO] mode=%s cash=%.4f equity=%.4f open=%d closed=%d pnl=+%.4f",
            self.mode, 1.0, 1.0, 0, 0, 0.0
        )
