# /home/tng25/lino/core/trading.py
from __future__ import annotations

import json
import os
import time
from dataclasses import dataclass
from typing import Any, Dict, Optional, List, Tuple

from config.settings import (
    MODE,
    BUY_AMOUNT_SOL,
    MAX_POSITIONS,
    BUY_COOLDOWN_SECONDS,
    STOP_LOSS_PCT,
    TRAILING_FROM_HIGH_PCT,
)

# Si ton raydium client existe, on l'importe (REAL)
try:
    from core.raydium_client import RaydiumClient
except Exception:
    RaydiumClient = None  # type: ignore


def _now() -> float:
    return time.time()


def _short(addr: str, n: int = 8) -> str:
    if not addr:
        return "?"
    return addr[:n] + "…" + addr[-4:]


def _fmt(x: float) -> str:
    # affiche joliment petits prix
    if x == 0:
        return "0"
    if x < 0.0001:
        return f"{x:.8f}"
    return f"{x:.8f}".rstrip("0").rstrip(".")


def _age(ts: float) -> str:
    s = int(_now() - ts)
    if s < 60:
        return f"{s}s"
    m = s // 60
    if m < 60:
        return f"{m}m"
    h = m // 60
    return f"{h}h"


def _table(rows: List[List[str]], headers: List[str]) -> str:
    # tableau ascii simple (sans dépendances)
    widths = [len(h) for h in headers]
    for r in rows:
        for i, c in enumerate(r):
            widths[i] = max(widths[i], len(c))

    def sep(char_left, char_mid, char_right, fill="─"):
        parts = [fill * (w + 2) for w in widths]
        return char_left + char_mid.join(parts) + char_right

    def line(cols):
        parts = []
        for i, c in enumerate(cols):
            parts.append(" " + c.ljust(widths[i]) + " ")
        return "│" + "│".join(parts) + "│"

    out = []
    out.append(sep("┌", "┬", "┐"))
    out.append(line(headers))
    out.append(sep("├", "┼", "┤"))
    for r in rows:
        out.append(line(r))
    out.append(sep("└", "┴", "┘"))
    return "\n".join(out)


@dataclass
class Position:
    mint: str
    entry: float
    sol_in: float
    opened_at: float
    high: float
    closed: bool = False
    closed_at: float = 0.0
    exit_price: float = 0.0
    reason: str = ""

    def pnl_pct(self, price: float) -> float:
        if self.entry <= 0:
            return 0.0
        return (price / self.entry - 1.0) * 100.0

    def stop_loss_price(self) -> float:
        return self.entry * (1.0 - STOP_LOSS_PCT)

    def trailing_price(self) -> float:
        return self.high * (1.0 - TRAILING_FROM_HIGH_PCT)

    def trigger_price(self) -> float:
        # seuil effectif = max(SL, trailing)
        return max(self.stop_loss_price(), self.trailing_price())


class TradingEngine:
    """
    API stable:
      TradingEngine(wallet, logger, positions_file=..., mode=...)
    """

    def __init__(
        self,
        wallet: Any,
        logger: Any,
        positions_file: str = "/home/tng25/lino/positions.json",
        mode: str = MODE,
    ):
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file
        self.mode = (mode or "PAPER").upper().strip()

        self.positions: Dict[str, Position] = {}
        self.closed_trades: List[Position] = []

        self._buy_cooldown: Dict[str, float] = {}
        self.start_equity_paper = 1.0  # base paper en "SOL"
        self.cash_paper = 1.0          # cash paper en "SOL"

        self.client = None
        if self.mode == "REAL" and RaydiumClient is not None:
            try:
                self.client = RaydiumClient()
            except Exception as e:
                self.logger.warning(f"[RaydiumClient] init fail (REAL disabled): {e}")
                self.client = None

        self._load_positions()
        self.logger.info("[TradingEngine] Initialisé (Moonshot trailing only).")

    # ---------- Persistence ----------
    def _load_positions(self) -> None:
        if not os.path.exists(self.positions_file):
            self.logger.info(f"[TradingEngine] 0 positions rechargées (fichier absent).")
            return
        try:
            raw = json.load(open(self.positions_file, "r"))
            if not isinstance(raw, dict):
                raw = {}
            count = 0
            for mint, p in raw.items():
                if not isinstance(p, dict):
                    continue
                pos = Position(
                    mint=mint,
                    entry=float(p.get("entry", 0.0)),
                    sol_in=float(p.get("sol_in", 0.0)),
                    opened_at=float(p.get("opened_at", _now())),
                    high=float(p.get("high", p.get("entry", 0.0))),
                    closed=bool(p.get("closed", False)),
                    closed_at=float(p.get("closed_at", 0.0)),
                    exit_price=float(p.get("exit_price", 0.0)),
                    reason=str(p.get("reason", "")),
                )
                if pos.closed:
                    self.closed_trades.append(pos)
                else:
                    self.positions[mint] = pos
                count += 1
            self.logger.info(f"[TradingEngine] {len(self.positions)} positions rechargées depuis {self.positions_file}.")
        except Exception as e:
            self.logger.warning(f"[TradingEngine] load positions error: {e}")

    def _save_positions(self) -> None:
        try:
            raw: Dict[str, Any] = {}
            for mint, pos in self.positions.items():
                raw[mint] = pos.__dict__
            for pos in self.closed_trades:
                raw[pos.mint] = pos.__dict__
            with open(self.positions_file, "w") as f:
                json.dump(raw, f, indent=2)
        except Exception as e:
            self.logger.warning(f"[TradingEngine] save positions error: {e}")

    # ---------- Helpers ----------
    def can_open_more(self) -> bool:
        return len(self.positions) < MAX_POSITIONS

    def in_position(self, mint: str) -> bool:
        return mint in self.positions

    def cooldown_ok(self, mint: str) -> Tuple[bool, str]:
        last = self._buy_cooldown.get(mint, 0.0)
        if _now() - last < BUY_COOLDOWN_SECONDS:
            return False, f"cooldown {BUY_COOLDOWN_SECONDS}s"
        return True, "ok"

    def mark_cooldown(self, mint: str) -> None:
        self._buy_cooldown[mint] = _now()

    # ---------- Paper execution ----------
    def paper_buy(self, mint: str, price: float, sol_amount: float) -> None:
        if sol_amount <= 0:
            return
        if self.cash_paper < sol_amount:
            self.logger.info(f"[PAPER BUY] Cash insuffisant: cash={self.cash_paper:.4f} < {sol_amount:.4f}")
            return
        self.cash_paper -= sol_amount
        pos = Position(
            mint=mint,
            entry=price,
            sol_in=sol_amount,
            opened_at=_now(),
            high=price,
        )
        self.positions[mint] = pos
        self._save_positions()
        self.logger.info(f"[PAPER BUY] Position ouverte sur {mint} à {_fmt(price)} pour {sol_amount:.4f} SOL.")

    def paper_sell(self, mint: str, price: float, reason: str) -> None:
        pos = self.positions.get(mint)
        if not pos:
            return
        pos.closed = True
        pos.closed_at = _now()
        pos.exit_price = price
        pos.reason = reason
        # paper: on récupère sol_in * (price/entry)
        out_sol = pos.sol_in * (price / pos.entry) if pos.entry > 0 else 0.0
        self.cash_paper += out_sol

        self.closed_trades.append(pos)
        del self.positions[mint]
        self._save_positions()
        self.logger.info(f"[PAPER SELL] {mint} exit={_fmt(price)} reason={reason} out={out_sol:.4f} SOL pnl={pos.pnl_pct(price):+.2f}%")

    # ---------- Public API ----------
    def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker: Any) -> None:
        """
        1) update positions (high/trailing)
        2) check sell rules
        3) try new buys
        4) print portfolio + table
        """
        # map mint->price from overviews
        price_map: Dict[str, float] = {}
        for ov in overviews:
            data = ov.get("data") or {}
            mint = str(data.get("address") or data.get("mint") or "")
            if not mint:
                continue
            price = float(data.get("price") or 0.0)
            price_map[mint] = price

        # --- update & sell ---
        for mint, pos in list(self.positions.items()):
            price = price_map.get(mint, pos.entry)
            if price <= 0:
                continue

            if price > pos.high:
                pos.high = price

            sl = pos.stop_loss_price()
            tr = pos.trailing_price()
            trigger = pos.trigger_price()

            self.logger.info(
                f"[POS] {mint} price={_fmt(price)} entry={_fmt(pos.entry)} high={_fmt(pos.high)} "
                f"SL={_fmt(sl)} TR={_fmt(tr)} trigger={_fmt(trigger)} pnl={pos.pnl_pct(price):+.2f}%"
            )

            if price <= trigger:
                reason = "STOPLOSS" if trigger == sl else "TRAILING"
                if self.mode == "PAPER":
                    self.paper_sell(mint, price, reason)
                else:
                    # REAL: ici tu brancheras le swap token->SOL quand tu mettras du vrai SOL.
                    self.logger.warning(f"[REAL SELL] (stub) {mint} would sell @ {price} reason={reason}")

        # --- buys ---
        for ov in overviews:
            data = ov.get("data") or {}
            mint = str(data.get("address") or data.get("mint") or "")
            if not mint:
                continue
            price = float(data.get("price") or 0.0)

            if price <= 0:
                self.logger.info(f"[BUY] Impossible d'acheter {mint} (prix invalide={price}).")
                continue

            if self.in_position(mint):
                self.logger.info(f"[BUY] Skip {mint} (déjà en position).")
                continue

            ok_cd, why_cd = self.cooldown_ok(mint)
            if not ok_cd:
                self.logger.info(f"[BUY] Skip {mint} ({why_cd}).")
                continue

            if not self.can_open_more():
                self.logger.info(f"[BUY] Skip {mint} (max positions {MAX_POSITIONS} atteintes).")
                continue

            ok_risk, why_risk = risk_checker.allow_buy(ov)
            if not ok_risk:
                self.logger.info(f"[BUY] Skip {mint} (risk: {why_risk}).")
                continue

            self.logger.info(f"[BUY] Signal sur {mint} (prix ~ {_fmt(price)}, montant={BUY_AMOUNT_SOL} SOL, mode={self.mode}).")
            self.mark_cooldown(mint)

            if self.mode == "PAPER":
                self.paper_buy(mint, price, BUY_AMOUNT_SOL)
            else:
                # REAL: ici tu brancheras le swap SOL->token (quand tu mettras de l'argent).
                self.logger.warning(f"[REAL BUY] (stub) {mint} would buy {BUY_AMOUNT_SOL} SOL @ {price}")

        self._print_portfolio(price_map)

    def _print_portfolio(self, price_map: Dict[str, float]) -> None:
        # equity paper = cash + somme(position sol_in * price/entry)
        unreal = 0.0
        for mint, pos in self.positions.items():
            price = price_map.get(mint, pos.entry)
            if pos.entry > 0:
                unreal += pos.sol_in * (price / pos.entry)

        equity = self.cash_paper + unreal
        pnl_total = equity - self.start_equity_paper

        # realized pnl paper (approx) = cash - start + (unreal - invested)
        invested_open = sum(p.sol_in for p in self.positions.values())
        unreal_pnl = unreal - invested_open
        realized_pnl = (self.cash_paper - (self.start_equity_paper - invested_open))

        self.logger.info(
            f"[PORTFOLIO] mode={self.mode} start={self.start_equity_paper:.4f} cash={self.cash_paper:.4f} equity={equity:.4f} "
            f"open={len(self.positions)} closed={len(self.closed_trades)} pnl_total={pnl_total:+.4f} "
            f"(real={realized_pnl:+.4f} unreal={unreal_pnl:+.4f})"
        )

        rows = []
        for mint, pos in self.positions.items():
            price = price_map.get(mint, pos.entry)
            rows.append([
                _short(mint, 10),
                _fmt(pos.entry),
                _fmt(price),
                _fmt(pos.high),
                _fmt(pos.stop_loss_price()),
                _fmt(pos.trailing_price()),
                f"{pos.pnl_pct(price):+,.2f}%",
                _age(pos.opened_at),
            ])

        if rows:
            headers = ["token", "entry", "price", "high", "SL", "TR", "pnl%", "age"]
            self.logger.info("[TABLE]\n" + _table(rows, headers))
