from __future__ import annotations
import os

PREFER_SCORED_READY = os.getenv('PREFER_SCORED_READY','1') in ('1','true','True')

# === DEBUG FILTERS ===


def _load_jsonl(path: str):
    import json
    out = []
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    out.append(json.loads(line))
                except Exception:
                    continue
    except FileNotFoundError:
        return []
    return out

def _pick_best(items):
    # best by "score" if present, else first
    best = None
    best_score = None
    for it in items:
        if not isinstance(it, dict):
            continue
        sc = it.get("score")
        if sc is None:
            continue
        try:
            scv = float(sc)
        except Exception:
            continue
        if best is None or scv > best_score:
            best, best_score = it, scv
    if best is not None:
        return best
    # fallback: first dict
    for it in items:
        if isinstance(it, dict):
            return it
    return None

# ===== MINIMAL_EXEC_ENTRYPOINT (STABLE) =====
# Used by trader_loop subprocess

def main():
    import os
    ready_file = os.getenv("READY_FILE", "ready_to_trade.jsonl")
    jup_base = os.getenv("JUP_BASE_URL", "https://lite-api.jup.ag")
    rpc_http = os.getenv("RPC_HTTP", "https://api.mainnet-beta.solana.com")
    dry_run = os.getenv("TRADER_DRY_RUN", "0") in ("1","true","True")

    print("üöÄ trader_exec BUY", flush=True)
    print("   ready_file=", ready_file, flush=True)
    print("   jup_base=", jup_base, flush=True)
    print("   rpc_http=", rpc_http, flush=True)
    print("   dry_run=", dry_run, flush=True)

    items = _load_jsonl(ready_file)
    print("   ready_count=", len(items), flush=True)
    if not items:
        print("‚ö†Ô∏è READY_FILE empty/not found", flush=True)
        return 0

    best = _pick_best(items)
    if not best:
        print("‚ö†Ô∏è no dict entries in READY_FILE", flush=True)
        return 0

    mint = best.get("mint") or best.get("address") or best.get("tokenAddress")
    score = best.get("score")
    liq = best.get("liq_usd") or best.get("liquidity_usd")
    vol = best.get("vol_24h") or best.get("volume_24h")
    tx1h = best.get("txns_1h") or best.get("tx_1h")
    chg = best.get("chg_1h") or best.get("change_1h")

    print(f"[DECISION] PICK mint={mint} score={score} liq={liq} vol24={vol} tx1h={tx1h} chg1h={chg}", flush=True)

    # DRY_RUN only for now
    if dry_run:
        print("üß™ TRADER_DRY_RUN=1 -> not sending tx", flush=True)
        return 0

    print("‚ö†Ô∏è LIVE disabled in this minimal main (enable later)", flush=True)
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
