from __future__ import annotations

import base64
import json
import os
import time
from pathlib import Path
from typing import Any, Dict, Optional

import requests
from solders.keypair import Keypair as SoldersKeypair
from solders.transaction import VersionedTransaction
from solders import message as solders_message


# ====== CONFIG ENV ======
SOL_MINT = "So11111111111111111111111111111111111111112"

RPC_HTTP = os.getenv("RPC_HTTP", "https://api.mainnet-beta.solana.com").strip()

# Jupiter endpoints (defaults to lite-api; override with env)
JUP_BASE = os.getenv("JUP_BASE", os.getenv("JUPITER_BASE_URL", "https://lite-api.jup.ag")).rstrip("/")
JUP_QUOTE_URL = os.getenv("JUP_QUOTE_URL", f"{JUP_BASE}/swap/v1/quote")
JUP_SWAP_URL  = os.getenv("JUP_SWAP_URL",  f"{JUP_BASE}/swap/v1/swap")

# Trading toggles
ONE_SHOT = os.getenv("TRADER_ONE_SHOT", "0").strip().lower() in ("1", "true", "yes", "on")
DRY_RUN = os.getenv("TRADER_DRY_RUN", "1").strip().lower() in ("1", "true", "yes", "on")
SKIP_PREFLIGHT = os.getenv("TRADER_SKIP_PREFLIGHT", "0").strip().lower() in ("1", "true", "yes", "on")

SLIPPAGE_BPS = int(os.getenv("SLIPPAGE_BPS", os.getenv("TRADER_SLIPPAGE_BPS", "120")))
MAX_PRICE_IMPACT_PCT = float(os.getenv("MAX_PRICE_IMPACT_PCT", os.getenv("TRADER_MAX_PRICE_IMPACT_PCT", "1.5")))

# amounts
DEFAULT_SOL_AMOUNT = float(os.getenv("TRADER_SOL_AMOUNT", os.getenv("BUY_AMOUNT_SOL", "0.01")))
# if TRADER_SOL_AMOUNT is "ALL"/"FULL", we use balance - buffer
SOL_BUFFER = float(os.getenv("TRADER_SOL_BUFFER", "0.003"))  # ATA rent + fees cushion

READY_FILE = Path(os.getenv("READY_FILE", "ready_to_trade.jsonl"))
OUT_TX_B64 = Path("last_swap_tx.b64")
OUT_META = Path("last_swap_meta.json")
OUT_ERR = Path("last_swap_error.json")
DBG_LOG = Path("last_swap_debug.log")

USER_PUBKEY = (os.getenv("WALLET_PUBKEY") or os.getenv("TRADER_USER_PUBLIC_KEY") or "").strip()
KEYPAIR_PATH = (os.getenv("SOLANA_KEYPAIR") or os.getenv("KEYPAIR_PATH") or "").strip()


def _append_dbg(line: str):
    try:
        DBG_LOG.write_text((DBG_LOG.read_text(encoding="utf-8", errors="ignore") if DBG_LOG.exists() else "") + line + "\n", encoding="utf-8")
    except Exception:
        pass


def _write_err(where: str, payload: Dict[str, Any]):
    OUT_ERR.write_text(json.dumps({"where": where, "payload": payload}, ensure_ascii=False, indent=2), encoding="utf-8")


def _headers() -> Dict[str, str]:
    h = {"accept": "application/json"}
    # Jupiter api key (only if you use api.jup.ag / need auth)
    k = (os.getenv("JUPITER_API_KEY") or os.getenv("JUP_API_KEY") or "").strip()
    if k:
        h["x-api-key"] = k
    return h


def _rpc(method: str, params: Any) -> Any:
    r = requests.post(
        RPC_HTTP,
        json={"jsonrpc": "2.0", "id": 1, "method": method, "params": params},
        timeout=25,
    )
    r.raise_for_status()
    j = r.json()
    if "error" in j:
        raise RuntimeError(f"rpc {method} error={j['error']}")
    return j["result"]


def _get_balance_lamports(pubkey: str) -> int:
    res = _rpc("getBalance", [pubkey])
    return int(res["value"])


def _load_ready() -> list[dict]:
    if not READY_FILE.exists():
        return []
    out = []
    for line in READY_FILE.read_text(encoding="utf-8", errors="ignore").splitlines():
        line = line.strip()
        if not line:
            continue
        try:
            out.append(json.loads(line))
        except Exception:
            continue
    # keep as-is (your upstream already sorts)
    return out


def _lamports_from_any(v: Any) -> Optional[int]:
    if v is None:
        return None
    if isinstance(v, (int, float)):
        return int(float(v))
    if isinstance(v, str):
        t = v.strip().lower()
        if t in ("all", "full"):
            return -1
        try:
            return int(float(t))
        except Exception:
            return None
    return None


def _load_solders_keypair(path: str) -> SoldersKeypair:
    if not path:
        raise RuntimeError("Missing SOLANA_KEYPAIR env (path to keypair.json)")
    p = Path(path).expanduser()
    if not p.exists():
        raise RuntimeError(f"SOLANA_KEYPAIR not found: {p}")
    arr = json.loads(p.read_text(encoding="utf-8", errors="ignore"))
    if not isinstance(arr, list):
        raise RuntimeError("keypair.json must be a JSON array of ints")
    b = bytes(int(x) & 0xFF for x in arr)
    # common formats: 64 bytes (secret key) or 32 bytes (seed)
    if len(b) == 64:
        return SoldersKeypair.from_bytes(b)
    if len(b) == 32:
        return SoldersKeypair.from_seed(b)
    raise RuntimeError(f"Unsupported key length in keypair.json: {len(b)}")


def _sign_and_send_swap_tx_b64(swap_tx_b64: str, user_kp: SoldersKeypair) -> str:
    raw = VersionedTransaction.from_bytes(base64.b64decode(swap_tx_b64))
    sig = user_kp.sign_message(solders_message.to_bytes_versioned(raw.message))
    signed = VersionedTransaction.populate(raw.message, [sig])
    encoded = base64.b64encode(bytes(signed)).decode("utf-8")

    params = [
        encoded,
        {
            "encoding": "base64",
            "skipPreflight": bool(SKIP_PREFLIGHT),
            "preflightCommitment": "processed",
        },
    ]
    res = _rpc("sendTransaction", params)
    return str(res)


def main() -> int:
    if not USER_PUBKEY:
        print("‚ùå missing WALLET_PUBKEY/TRADER_USER_PUBLIC_KEY")
        return 2

    sell_mode = os.getenv("SELL_MINT", "").strip() != ""

    if sell_mode:
        # not implemented in this clean file (sell engine handles sells)
        print("‚ö†Ô∏è SELL mode not supported in src/trader_exec.py clean version. Use sell_engine.")
        return 0

    print("üöÄ trader_exec BUY")
    print("   ready_file=", str(READY_FILE))
    print("   jup_base=", JUP_BASE)
    print("   rpc_http=", RPC_HTTP)
    print("   input_mint=", SOL_MINT)
    print("   slippage_bps=", SLIPPAGE_BPS, "max_price_impact=", f"{MAX_PRICE_IMPACT_PCT}%")
    print("   one_shot=", ONE_SHOT, "dry_run=", DRY_RUN)

    ready = _load_ready()
    print("   ready_count=", len(ready))
    if not ready:
        _write_err("no_ready_candidates", {"ready_file": str(READY_FILE)})
        print("‚ö†Ô∏è ready_to_trade vide")
        return 0

    cand = ready[0]
    output_mint = (cand.get("outputMint") or cand.get("mint") or "").strip()
    if not output_mint:
        _write_err("bad_candidate_no_mint", {"candidate": cand})
        print("‚ö†Ô∏è candidate sans mint/outputMint")
        return 0

    # amount selection
    amount_lp = _lamports_from_any(cand.get("amount"))
    if amount_lp is None:
        # env override
        env_amount = os.getenv("TRADER_SOL_AMOUNT", os.getenv("BUY_AMOUNT_SOL", "")).strip()
        if env_amount.lower() in ("all", "full"):
            amount_lp = -1
        else:
            amount_lp = int(DEFAULT_SOL_AMOUNT * 1_000_000_000)

    # if ALL/FULL => use balance - buffer
    bal = _get_balance_lamports(USER_PUBKEY)
    buffer_lp = int(SOL_BUFFER * 1_000_000_000)
    if amount_lp == -1:
        amount_lp = max(0, bal - buffer_lp)

    # hard guard: must have amount + buffer
    if bal < (amount_lp + buffer_lp):
        print(f"‚ùå insufficient SOL balance: {bal} need~ {amount_lp + buffer_lp} (amount {amount_lp} + buffer {buffer_lp} )")
        return 0

    input_mint = SOL_MINT
    amount = int(amount_lp)
    print("   pick=", output_mint, "amount_lamports=", amount)

    # QUOTE
    params = {
        "inputMint": input_mint,
        "outputMint": output_mint,
        "amount": str(amount),
        "slippageBps": str(SLIPPAGE_BPS),
    }
    try:
        qr = requests.get(JUP_QUOTE_URL, params=params, headers=_headers(), timeout=25)
        _append_dbg("QUOTE_URL=" + qr.url)
        _append_dbg("QUOTE_STATUS=" + str(qr.status_code))
        _append_dbg("QUOTE_BODY=" + (qr.text[:2000] if qr.text else ""))
        if qr.status_code != 200:
            _write_err("quote_http", {"status": qr.status_code, "text": (qr.text or "")[:2000], "url": qr.url})
            print("‚ùå quote failed http=", qr.status_code)
            return 0
        quote = qr.json()
    except Exception as e:
        _write_err("quote_exc", {"error": str(e)})
        print("‚ùå quote exception:", e)
        return 0

    # SWAP build
    body = {"quoteResponse": quote, "userPublicKey": USER_PUBKEY, "wrapAndUnwrapSol": True}

    try:
        sr = requests.post(JUP_SWAP_URL, headers=_headers(), json=body, timeout=35)
        _append_dbg("SWAP_STATUS=" + str(sr.status_code))
        _append_dbg("SWAP_BODY=" + (sr.text[:2000] if sr.text else ""))
        if sr.status_code != 200:
            _write_err("swap_http", {"status": sr.status_code, "text": (sr.text or "")[:2000]})
            print("‚ùå swap build failed http=", sr.status_code)
            return 0

        swap = sr.json()
        txb64 = swap.get("swapTransaction")
        if not txb64:
            _write_err("swap_no_tx", {"keys": list(swap.keys()), "sample": swap})
            print("‚ö†Ô∏è swap response sans swapTransaction")
            return 0

        OUT_TX_B64.write_text(txb64, encoding="utf-8")
        OUT_META.write_text(json.dumps({
            "ts": int(time.time()),
            "mode": "BUY",
            "inputMint": input_mint,
            "outputMint": output_mint,
            "amount": amount,
            "slippageBps": SLIPPAGE_BPS,
            "userPublicKey": USER_PUBKEY,
            "jupQuoteUrl": JUP_QUOTE_URL,
            "jupSwapUrl": JUP_SWAP_URL,
        }, ensure_ascii=False, indent=2), encoding="utf-8")

        print("‚úÖ built tx -> last_swap_tx.b64")

        if DRY_RUN:
            print("üß™ DRY_RUN=1 -> not sending")
            return 0

        kp = _load_solders_keypair(KEYPAIR_PATH)
        txsig = _sign_and_send_swap_tx_b64(txb64, kp)
        print("‚úÖ sent txsig=", txsig)
        return 0

    except Exception as e:
        _write_err("swap_exc", {"error": str(e)})
        print("‚ùå swap/send exception:", e)
        return 0


if __name__ == "__main__":
    raise SystemExit(main())
