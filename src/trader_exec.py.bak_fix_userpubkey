from __future__ import annotations

import os
import json
import time
import base64
from pathlib import Path
from typing import Any, Dict, Optional

import requests

from solders.keypair import Keypair
from solders.transaction import VersionedTransaction
from solders.message import to_bytes_versioned
### SOL_BALANCE_GUARD_V1 ###
MIN_SOL_BUFFER_LAMPORTS = int(float(os.getenv('MIN_SOL_BUFFER_SOL','0.003')) * 1_000_000_000)  # fees/ATA buffer

def _get_balance_lamports(rpc_http: str, pubkey: str) -> int:
    try:
        rr = requests.post(rpc_http, json={'jsonrpc':'2.0','id':1,'method':'getBalance','params':[pubkey]}, timeout=20)
        return int((rr.json().get('result') or {}).get('value') or 0)
    except Exception:
        return 0



READY_FILE = Path(os.getenv("READY_FILE", "ready_to_trade.jsonl"))
OUT_TX_B64 = Path(os.getenv("OUT_TX_B64", "last_swap_tx.b64"))
OUT_META = Path(os.getenv("OUT_META", "last_swap_meta.json"))
OUT_ERR = Path(os.getenv("OUT_ERR", "last_swap_error.json"))
OUT_DBG = Path(os.getenv("OUT_DBG", "last_swap_debug.log"))
OUT_SENT = Path(os.getenv("OUT_SENT", "last_swap_sent.json"))

JUP_BASE = os.getenv("JUP_BASE", os.getenv("JUPITER_BASE_URL", "https://api.jup.ag")).rstrip("/")
RPC_HTTP = os.getenv("RPC_HTTP", os.getenv("SOLANA_RPC_HTTP", "https://api.mainnet-beta.solana.com"))

SOL_MINT = os.getenv("SOL_MINT", "So11111111111111111111111111111111111111112")

SLIPPAGE_BPS = int(float(os.getenv("SLIPPAGE_BPS", os.getenv("TRADER_SLIPPAGE_BPS", "120"))))
MAX_PRICE_IMPACT_PCT = float(os.getenv("MAX_PRICE_IMPACT_PCT", os.getenv("TRADER_MAX_PRICE_IMPACT_PCT", "1.5")))
DEFAULT_SOL_AMOUNT = float(os.getenv("TRADER_SOL_AMOUNT", os.getenv("BUY_AMOUNT_SOL", "0.01")))

ONE_SHOT = os.getenv("TRADER_ONE_SHOT", "0").strip().lower() in ("1", "true", "yes", "on")
DRY_RUN = os.getenv("TRADER_DRY_RUN", os.getenv("DRY_RUN", "1")).strip().lower() in ("1", "true", "yes", "on")
SKIP_PREFLIGHT = os.getenv("TRADER_SKIP_PREFLIGHT", "0").strip().lower() in ("1", "true", "yes", "on")

WALLET_PUBKEY = (os.getenv("WALLET_PUBKEY") or os.getenv("TRADER_USER_PUBLIC_KEY") or "").strip()


def _append_dbg(line: str) -> None:
    try:
        OUT_DBG.parent.mkdir(parents=True, exist_ok=True)
        with OUT_DBG.open("a", encoding="utf-8") as f:
            f.write(line.rstrip() + "\n")
    except Exception:
        pass


def _write_err(kind: str, payload: Dict[str, Any]) -> None:
    try:
        OUT_ERR.write_text(json.dumps({"ts": int(time.time()), "kind": kind, **payload}, ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception:
        pass


def _headers() -> Dict[str, str]:
    h = {"accept": "application/json"}
    k = os.getenv("JUPITER_API_KEY") or os.getenv("JUP_API_KEY") or ""
    if k:
        h["x-api-key"] = k
    return h


def _load_ready() -> list[dict]:
    if not READY_FILE.exists():
        return []
    out = []
    with READY_FILE.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                out.append(json.loads(line))
            except Exception:
                continue
    return out


def _lamports_from_any(v: Any) -> Optional[int]:
    if v is None:
        return None
    if isinstance(v, int):
        return int(v)
    if isinstance(v, float):
        return int(v)
    if isinstance(v, str) and v.strip():
        try:
            if "." in v:
                return int(float(v))
            return int(v)
        except Exception:
            return None
    return None


def _load_keypair() -> Keypair:
    path = os.getenv("SOLANA_KEYPAIR") or os.getenv("KEYPAIR_PATH") or ""
    if not path:
        raise RuntimeError("Missing SOLANA_KEYPAIR env (path to keypair.json)")
    p = Path(path).expanduser()
    arr = json.loads(p.read_text(encoding="utf-8"))
    if not isinstance(arr, list) or len(arr) < 64:
        raise RuntimeError("Bad keypair.json format (expected list of 64 ints)")
    secret = bytes(int(x) & 0xFF for x in arr[:64])
    return Keypair.from_bytes(secret)


def _send_signed_b64(tx_b64: str, rpc_http: str) -> str:
    kp = _load_keypair()

    raw_tx = VersionedTransaction.from_bytes(base64.b64decode(tx_b64))
    sig = kp.sign_message(to_bytes_versioned(raw_tx.message))
    signed_tx = VersionedTransaction.populate(raw_tx.message, [sig])

    encoded_tx = base64.b64encode(bytes(signed_tx)).decode("utf-8")

    req = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "sendTransaction",
        "params": [
            encoded_tx,
            {
                "encoding": "base64",
                "skipPreflight": bool(SKIP_PREFLIGHT),
                "preflightCommitment": os.getenv("PREFLIGHT_COMMITMENT", "processed"),
                "maxRetries": int(os.getenv("SEND_MAX_RETRIES", "3")),
            },
        ],
    }
    r = requests.post(rpc_http, json=req, timeout=35)
    _append_dbg("SEND_STATUS=" + str(r.status_code))
    _append_dbg("SEND_BODY=" + (r.text[:2000] if r.text else ""))

    if r.status_code != 200:
        raise RuntimeError(f"sendTransaction http={r.status_code} body={r.text[:2000]}")

    j = r.json()
    if "error" in j:
        raise RuntimeError(f"sendTransaction error={j['error']}")
    res = j.get("result")
    if not res:
        raise RuntimeError(f"sendTransaction no result: {j}")
    return str(res)


def main() -> int:
    if not WALLET_PUBKEY:
        print("‚ùå missing WALLET_PUBKEY/TRADER_USER_PUBLIC_KEY")
        return 1

    print("üöÄ trader_exec BUY")
    print("   ready_file=", str(READY_FILE))
    print("   jup_base=", JUP_BASE)
    print("   rpc_http=", RPC_HTTP)
    print("   input_mint=", SOL_MINT)
    print("   slippage_bps=", SLIPPAGE_BPS, "max_price_impact=", f"{MAX_PRICE_IMPACT_PCT}%")
    print("   one_shot=", ONE_SHOT, "dry_run=", DRY_RUN)

    ready = _load_ready()
    print("   ready_count=", len(ready))
    if not ready:
        _write_err("no_ready_candidates", {"ready_file": str(READY_FILE)})
        print("‚ö†Ô∏è ready_to_trade vide")
        return 0

    cand = ready[0]
    output_mint = (cand.get("outputMint") or cand.get("mint") or "").strip()
    if not output_mint:
        _write_err("bad_candidate_no_mint", {"candidate": cand})
        print("‚ö†Ô∏è candidate sans mint/outputMint")
        return 0

    amount = _lamports_from_any(cand.get("amount"))
    if amount is None:
        amount = int(DEFAULT_SOL_AMOUNT * 1_000_000_000)

    print("   pick=", output_mint, "amount_lamports=", amount)


    # SOL balance guard (amount + buffer)

    bal = _get_balance_lamports(RPC_HTTP, user_pubkey)

    need = int(amount) + int(MIN_SOL_BUFFER_LAMPORTS)

    if bal < need:

        _write_err('insufficient_sol', {'bal': bal, 'need': need, 'amount': int(amount), 'buffer': int(MIN_SOL_BUFFER_LAMPORTS)})

        print('‚ùå insufficient SOL balance:', bal, 'need~', need, '(amount', int(amount), '+ buffer', int(MIN_SOL_BUFFER_LAMPORTS), ')')

        return 0

    # QUOTE
    qurl = os.getenv("JUP_QUOTE_URL", f"{JUP_BASE}/swap/v1/quote")
    params = {
        "inputMint": SOL_MINT,
        "outputMint": output_mint,
        "amount": str(amount),
        "slippageBps": str(SLIPPAGE_BPS),
    }
    try:
        qr = requests.get(qurl, params=params, headers=_headers(), timeout=25)
        _append_dbg("QUOTE_URL=" + qr.url)
        _append_dbg("QUOTE_STATUS=" + str(qr.status_code))
        _append_dbg("QUOTE_BODY=" + (qr.text[:2000] if qr.text else ""))
        if qr.status_code != 200:
            _write_err("quote_http", {"status": qr.status_code, "text": qr.text[:2000], "url": qr.url})
            print("‚ùå quote failed http=", qr.status_code)
            return 0
        quote = qr.json()
    except Exception as e:
        _write_err("quote_exc", {"error": str(e)})
        print("‚ùå quote exception:", e)
        return 0

    # SWAP build
    surl = os.getenv("JUP_SWAP_URL", f"{JUP_BASE}/swap/v1/swap")
    body = {"quoteResponse": quote, "userPublicKey": WALLET_PUBKEY, "wrapAndUnwrapSol": True}

    try:
        sr = requests.post(surl, headers=_headers(), json=body, timeout=35)
        _append_dbg("SWAP_STATUS=" + str(sr.status_code))
        _append_dbg("SWAP_BODY=" + (sr.text[:2000] if sr.text else ""))
        if sr.status_code != 200:
            _write_err("swap_http", {"status": sr.status_code, "text": sr.text[:2000]})
            print("‚ùå swap build failed http=", sr.status_code)
            return 0

        swap = sr.json()
        txb64 = swap.get("swapTransaction")
        if not txb64:
            _write_err("swap_no_tx", {"keys": list(swap.keys()), "sample": swap})
            print("‚ö†Ô∏è swap response sans swapTransaction")
            return 0

        OUT_TX_B64.write_text(txb64, encoding="utf-8")
        OUT_META.write_text(json.dumps({
            "ts": int(time.time()),
            "mode": "BUY",
            "inputMint": SOL_MINT,
            "outputMint": output_mint,
            "amount": amount,
            "slippageBps": SLIPPAGE_BPS,
            "userPublicKey": WALLET_PUBKEY,
        }, ensure_ascii=False, indent=2), encoding="utf-8")

        print("‚úÖ built tx -> last_swap_tx.b64")

        if DRY_RUN:
            print("üß™ DRY_RUN=1 -> not sending")
            return 0

        try:
            txsig = _send_signed_b64(txb64, RPC_HTTP)
            OUT_SENT.write_text(json.dumps({"ts": int(time.time()), "txsig": txsig}, ensure_ascii=False, indent=2), encoding="utf-8")
            print("‚úÖ sent txsig=", txsig)
        except Exception as e:
            _write_err("send_exc", {"error": str(e)})
            print("‚ùå send exception:", e)

        return 0

    except Exception as e:
        _write_err("swap_exc", {"error": str(e)})
        print("‚ùå swap exception:", e)
        return 0


if __name__ == "__main__":
    raise SystemExit(main())
