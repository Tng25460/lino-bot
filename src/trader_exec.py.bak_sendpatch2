import os, json, time
from pathlib import Path
from typing import Any, Dict, List, Optional
import requests

READY_FILE = os.getenv("TRADER_READY_FILE", "ready_to_trade.jsonl")

JUP_BASE = os.getenv("JUP_BASE", os.getenv("JUPITER_BASE_URL", "https://lite-api.jup.ag")).rstrip("/")
JUP_API_KEY = os.getenv("JUP_API_KEY", os.getenv("JUPITER_API_KEY", "")).strip()

RPC_HTTP = os.getenv("RPC_HTTP", os.getenv("RPC_URL", "https://api.mainnet-beta.solana.com")).strip()

SLIPPAGE_BPS = int(os.getenv("TRADER_SLIPPAGE_BPS", os.getenv("SLIPPAGE_BPS", "120")))
MAX_PRICE_IMPACT_PCT = float(os.getenv("TRADER_MAX_PRICE_IMPACT_PCT", os.getenv("MAX_PRICE_IMPACT_PCT", "1.5")))

ONE_SHOT = os.getenv("TRADER_ONE_SHOT", "0").strip().lower() in ("1","true","yes","on")
DRY_RUN = os.getenv("TRADER_DRY_RUN", "1").strip().lower() in ("1","true","yes","on")

DEFAULT_SOL_AMOUNT = float(os.getenv("TRADER_SOL_AMOUNT", os.getenv("BUY_AMOUNT_SOL", "0.01")))

OUT_TX_B64 = Path("last_swap_tx.b64")
OUT_META = Path("last_swap_meta.json")
OUT_ERR = Path("last_swap_error.json")
OUT_DBG = Path("last_swap_debug.txt")

SOL_MINT = "So11111111111111111111111111111111111111112"

def _headers() -> Dict[str, str]:
    h = {"accept": "application/json", "content-type": "application/json"}
    if JUP_API_KEY:
        h["x-api-key"] = JUP_API_KEY
    return h

def _write_err(where: str, payload: Any):
    OUT_ERR.write_text(json.dumps({"where": where, "payload": payload}, ensure_ascii=False, indent=2), encoding="utf-8")

def _append_dbg(s: str):
    OUT_DBG.write_text((OUT_DBG.read_text(encoding="utf-8") if OUT_DBG.exists() else "") + s + "\n", encoding="utf-8")

def _load_ready() -> List[Dict[str, Any]]:
    p = Path(READY_FILE)
    if not p.exists():
        return []
    arr: List[Dict[str, Any]] = []
    for ln in p.read_text(encoding="utf-8").splitlines():
        ln = ln.strip()
        if not ln:
            continue
        try:
            obj = json.loads(ln)
            if isinstance(obj, dict):
                arr.append(obj)
        except Exception:
            continue
    return arr

def _pick_user_pubkey() -> str:
    for k in ("WALLET_PUBKEY","TRADER_USER_PUBLIC_KEY","TRADER_USER_PUBKEY","USER_PUBKEY","PUBLIC_KEY","WALLET_PUBLIC_KEY"):
        v = os.getenv(k, "").strip()
        if v:
            return v
    return ""

def _lamports_from_any(x: Any) -> Optional[int]:
    try:
        if x is None:
            return None
        if isinstance(x, int):
            return int(x)
        s = str(x).strip()
        if not s:
            return None
        if "." in s:
            return int(float(s) * 1_000_000_000)  # SOL -> lamports
        return int(s)
    except Exception:
        return None

def _get_token_amount_for_sell(mint: str) -> Optional[int]:
    """
    On lit l'amount token √† vendre depuis env:
      SELL_TOKEN_AMOUNT (raw) ou SELL_TOKEN_AMOUNT_UI (ui units) + SELL_TOKEN_DECIMALS
    Minimal pour avancer sans RPC token balance.
    """
    raw = os.getenv("SELL_TOKEN_AMOUNT", "").strip()
    if raw:
        try: return int(raw)
        except Exception: pass

    ui = os.getenv("SELL_TOKEN_AMOUNT_UI", "").strip()
    dec = os.getenv("SELL_TOKEN_DECIMALS", "").strip()
    if ui and dec:
        try:
            ui_f = float(ui)
            dec_i = int(dec)
            return int(ui_f * (10 ** dec_i))
        except Exception:
            return None
    return None

def main() -> int:
    sell_mode = os.getenv("SELL_MODE", "0").strip().lower() in ("1","true","yes","on")

    user_pubkey = _pick_user_pubkey()
    if not user_pubkey:
        _write_err("missing_user_pubkey", {"hint": "set WALLET_PUBKEY or TRADER_USER_PUBLIC_KEY"})
        print("‚ùå missing public key")
        return 0

    _append_dbg("==== trader_exec run ====")

    if sell_mode:
        sell_mint = os.getenv("SELL_MINT", "").strip()
        sell_fraction = float(os.getenv("SELL_FRACTION", "1.0"))
        sell_fraction = max(0.0, min(1.0, sell_fraction))

        if not sell_mint:
            _write_err("sell_missing_mint", {})
            print("‚ùå SELL_MODE=1 but SELL_MINT missing")
            return 0

        # For now: require caller to provide token raw amount.
        token_amount = _get_token_amount_for_sell(sell_mint)
        if token_amount is None:
            _write_err("sell_missing_amount", {"hint": "provide SELL_TOKEN_AMOUNT (raw integer) OR SELL_TOKEN_AMOUNT_UI + SELL_TOKEN_DECIMALS"})
            print("‚ùå SELL missing token amount env")
            return 0

        # Apply fraction
        token_amount = int(token_amount * sell_fraction)
        if token_amount <= 0:
            _write_err("sell_amount_zero", {"computed": token_amount})
            print("‚ùå SELL computed amount <= 0")
            return 0

        input_mint = sell_mint
        output_mint = SOL_MINT
        amount = token_amount

        print("üöÄ trader_exec SELL")
        print("   mint=", sell_mint, "fraction=", sell_fraction, "amount_raw=", amount)
        print("   jup_base=", JUP_BASE, "slippage_bps=", SLIPPAGE_BPS, "dry_run=", DRY_RUN)

    else:
        # BUY from ready_to_trade
        print("üöÄ trader_exec BUY")
        print("   ready_file=", READY_FILE)
        print("   jup_base=", JUP_BASE)
        print("   rpc_http=", RPC_HTTP)
        print("   input_mint=", SOL_MINT)
        print("   slippage_bps=", SLIPPAGE_BPS, "max_price_impact=", f"{MAX_PRICE_IMPACT_PCT}%")
        print("   one_shot=", ONE_SHOT, "dry_run=", DRY_RUN)

        ready = _load_ready()
        print("   ready_count=", len(ready))
        if not ready:
            _write_err("no_ready_candidates", {"ready_file": READY_FILE})
            print("‚ö†Ô∏è ready_to_trade vide")
            return 0

        cand = ready[0]
        output_mint = (cand.get("outputMint") or cand.get("mint") or "").strip()
        if not output_mint:
            _write_err("bad_candidate_no_mint", {"candidate": cand})
            print("‚ö†Ô∏è candidate sans mint/outputMint")
            return 0

        amount = _lamports_from_any(cand.get("amount"))
        if amount is None:
            amount = int(DEFAULT_SOL_AMOUNT * 1_000_000_000)

        input_mint = SOL_MINT
        print("   pick=", output_mint, "amount_lamports=", amount)

    # QUOTE
    qurl = os.getenv("JUP_QUOTE_URL", f"{JUP_BASE}/swap/v1/quote")
    params = {
        "inputMint": input_mint,
        "outputMint": output_mint,
        "amount": str(amount),
        "slippageBps": str(SLIPPAGE_BPS),
    }
    try:
        qr = requests.get(qurl, params=params, headers=_headers(), timeout=25)
        _append_dbg("QUOTE_URL=" + qr.url)
        _append_dbg("QUOTE_STATUS=" + str(qr.status_code))
        _append_dbg("QUOTE_BODY=" + (qr.text[:2000] if qr.text else ""))
        if qr.status_code != 200:
            _write_err("quote_http", {"status": qr.status_code, "text": qr.text[:2000], "url": qr.url})
            print("‚ùå quote failed http=", qr.status_code)
            return 0
        quote = qr.json()
    except Exception as e:
        _write_err("quote_exc", {"error": str(e)})
        print("‚ùå quote exception:", e)
        return 0

    # SWAP build
    surl = os.getenv("JUP_SWAP_URL", f"{JUP_BASE}/swap/v1/swap")
    body = {"quoteResponse": quote, "userPublicKey": user_pubkey, "wrapAndUnwrapSol": True}

    try:
        sr = requests.post(surl, headers=_headers(), json=body, timeout=35)
        _append_dbg("SWAP_STATUS=" + str(sr.status_code))
        _append_dbg("SWAP_BODY=" + (sr.text[:2000] if sr.text else ""))
        if sr.status_code != 200:
            _write_err("swap_http", {"status": sr.status_code, "text": sr.text[:2000]})
            print("‚ùå swap build failed http=", sr.status_code)
            return 0
        swap = sr.json()
        txb64 = swap.get("swapTransaction")
        if not txb64:
            _write_err("swap_no_tx", {"keys": list(swap.keys()), "sample": swap})
            print("‚ö†Ô∏è swap response sans swapTransaction")
            return 0

        OUT_TX_B64.write_text(txb64, encoding="utf-8")
        OUT_META.write_text(json.dumps({
            "ts": int(time.time()),
            "mode": "SELL" if sell_mode else "BUY",
            "inputMint": input_mint,
            "outputMint": output_mint,
            "amount": amount,
            "slippageBps": SLIPPAGE_BPS,
            "userPublicKey": user_pubkey,
        }, ensure_ascii=False, indent=2), encoding="utf-8")

        print("‚úÖ built tx -> last_swap_tx.b64")
        return 0

    except Exception as e:
        _write_err("swap_exc", {"error": str(e)})
        print("‚ùå swap exception:", e)
        return 0

if __name__ == "__main__":
    raise SystemExit(main())
