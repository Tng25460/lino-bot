import sys
import asyncio
import os
from pathlib import Path as _Path

ROOT = str(_Path(__file__).resolve().parents[1])
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from core.sell_engine import SellEngine
from core.positions_db_adapter import PositionsDBAdapter
from core.price_feed_dex import DexScreenerPriceFeed
from src.trader_loop import trader_loop


async def _maybe_await(x):
    if asyncio.iscoroutine(x):
        return await x
    return x


async def main():
    print("ðŸš€ run_live: starting sell_engine + trader_loop", flush=True)

    db_path = os.getenv("DB_PATH", "state/trades.sqlite")
    db = PositionsDBAdapter(db_path)

    price_feed = DexScreenerPriceFeed()
    sell_engine = SellEngine(db=db, price_feed=price_feed)
    print("âœ… sell_engine: using step loop SellEngine.run_once()", flush=True)

    sleep_s = float(os.getenv("LOOP_SLEEP_S", "10"))
    # --- SELL_ONLY mode (skip trader_loop) ---
    if os.getenv("SELL_ONLY","0") == "1":
        print("ðŸ›‘ SELL_ONLY=1 -> sell_engine ONLY (skip trader_loop)", flush=True)
        while True:
            print("ðŸ’° SELL_TICK: running sell_engine.run_once()", flush=True)
            try:
                sell_engine.run_once()
            except Exception as err:
                print("âŒ sell_engine tick error: " + str(err), flush=True)
            await asyncio.sleep(sleep_s)
    # --- end SELL_ONLY ---
    one_shot = os.getenv("ONE_SHOT", "0") in ("1", "true", "True")

    while True:
        print("ðŸ’° SELL_TICK: running sell_engine.run_once()", flush=True)
        try:
            # SellEngine est sync -> pas besoin d'await
            sell_engine.run_once()
        except Exception as err:
            print("âŒ sell_engine tick error: " + str(err), flush=True)

        print("ðŸ§  trader_loop (universe_builder -> exec -> sign -> send)", flush=True)
        try:
            # trader_loop peut Ãªtre sync ou async -> safe
            await _maybe_await(trader_loop())
        except Exception as err:
            print("âŒ trader_loop error: " + str(err), flush=True)

        # NOTE: trader_loop a son propre TRADER_ONE_SHOT.
        # ONE_SHOT ici ne sert que si tu utilises run_live comme loop unique.
        if one_shot:
            print("ðŸ§ª ONE_SHOT=1 -> stop after one iteration", flush=True)
            break

        await asyncio.sleep(sleep_s)


if __name__ == "__main__":
    asyncio.run(main())
