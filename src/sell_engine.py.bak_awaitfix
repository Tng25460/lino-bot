from __future__ import annotations

# ### SELL_ENGINE_WALLET_FIX_V2 ###
def _se_wallet_obj():
    """
    Return a wallet-ish object to satisfy SellEngine.run_once(wallet).
    Priority:
      - solders.keypair.Keypair (from SOLANA_KEYPAIR or /home/tng25/lino/keypair.json)
      - solana.keypair.Keypair (legacy)
      - fallback pubkey string
    """
    import os, json

    kp = os.getenv("SOLANA_KEYPAIR") or os.getenv("KEYPAIR_PATH") or ""
    if not kp and os.path.exists("/home/tng25/lino/keypair.json"):
        kp = "/home/tng25/lino/keypair.json"

    # solders
    try:
        from solders.keypair import Keypair as SKeypair
        if kp and os.path.exists(kp):
            arr = json.load(open(kp, "r"))
            return SKeypair.from_bytes(bytes(arr))
    except Exception:
        pass

    # solana-py legacy
    try:
        from solana.keypair import Keypair as PKeypair
        if kp and os.path.exists(kp):
            arr = json.load(open(kp, "r"))
            return PKeypair.from_secret_key(bytes(arr))
    except Exception:
        pass

    # pubkey-only fallback
    pub = os.getenv("WALLET_PUBKEY") or os.getenv("TRADER_USER_PUBLIC_KEY") or ""
    return pub or None

import os
import asyncio
from dataclasses import dataclass
from typing import Optional

from core.db import (
    DB, init_db, now_ts,
    update_position_marks, close_position, mark_tp_done
)

# Tu as déjà un Jupiter async client dans core/jupiter_async.py normalement.
# On fait un import "best effort": adapte si ton nom diffère.
try:
    from core.jupiter_async import JupiterAsync
except Exception:
    JupiterAsync = None  # type: ignore


@dataclass
class SellCfg:
    hard_stop_pct: float = float(os.getenv("HARD_STOP_PCT", "0.15"))   # 15%
    trailing_pct: float  = float(os.getenv("TRAILING_PCT", "0.03"))    # 3%
    tp1_pct: float       = float(os.getenv("TP1_PCT", "0.25"))         # +25%
    tp2_pct: float       = float(os.getenv("TP2_PCT", "0.60"))         # +60%
    tp1_sell_frac: float = float(os.getenv("TP1_SELL_FRAC", "0.25"))   # 25% qty
    tp2_sell_frac: float = float(os.getenv("TP2_SELL_FRAC", "0.35"))   # 35% qty
    min_qty: float       = float(os.getenv("MIN_SELL_QTY", "0.000001"))


class SellEngine:
    def __init__(self, db_path: str, *, cfg: Optional[SellCfg] = None, logger=None):
        init_db(db_path)
        self.db = DB(db_path)
        self.cfg = cfg or SellCfg()
        self.logger = logger

        self.rpc_url = os.getenv("RPC_URL") or os.getenv("RPC_HTTP") or "https://api.mainnet-beta.solana.com"
        self.jupiter_url = os.getenv("JUPITER_URL", "https://quote-api.jup.ag")

    def log(self, msg: str) -> None:
        if self.logger:
            self.logger.info(msg)
        else:
            print(msg)

    async def get_price_usd(self, mint: str) -> Optional[float]:
        # Si tu as un prix déjà dispo ailleurs, branche-le ici.
        if JupiterAsync is None:
            return None
        j = JupiterAsync(self.jupiter_url)
        try:
            # On quote: 0.1 SOL -> mint ? non.
            # Plus simple: quote mint -> USDC, amount small. Adapte si ton JupiterAsync diffère.
            # On tente plusieurs APIs “probables”.
            usdc = os.getenv("USDC_MINT", "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")
            amount = int(float(os.getenv("PRICE_QUOTE_TOKENS", "10.0")) * 1_000_000)  # fallback
            try:
                q = await j.quote(input_mint=mint, output_mint=usdc, amount=amount, slippage_bps=50)
                # On déduit prix approx: outAmount / inAmount (mais dépend decimals). Ici: best-effort.
                # Si ton JupiterAsync renvoie un champ direct "priceUsd", utilise-le.
                if isinstance(q, dict):
                    if "priceUsd" in q:
                        return float(q["priceUsd"])
                    if "data" in q and isinstance(q["data"], dict) and "priceUsd" in q["data"]:
                        return float(q["data"]["priceUsd"])
            except Exception:
                return None
            return None
        finally:
            try:
                await j.close()
            except Exception:
                pass

    async def run_once(self, wallet: str) -> None:
        rows = self.db.all(
            "SELECT * FROM positions WHERE wallet=? AND status='OPEN'",
            (wallet,),
        )
        if not rows:
            return

        for p in rows:
            mint = p["mint"]
            symbol = p.get("symbol")
            qty = float(p["qty_token"] or 0)
            entry = float(p["entry_price_usd"] or 0) if p["entry_price_usd"] is not None else None
            if qty <= self.cfg.min_qty or not entry or entry <= 0:
                continue

            price = await self.get_price_usd(mint)
            if price is None:
                continue

            high = float(p["high_price_usd"] or entry)
            high2 = max(high, price)

            trail = None
            if self.cfg.trailing_pct > 0:
                trail = high2 * (1.0 - self.cfg.trailing_pct)

            update_position_marks(
                self.db,
                wallet=wallet,
                mint=mint,
                last_price_usd=price,
                high_price_usd=high2,
                trail_stop_usd=trail,
                ts=now_ts(),
            )

            pnl = (price / entry) - 1.0
            tp1_done = int(p.get("tp_done_1") or 0) == 1
            tp2_done = int(p.get("tp_done_2") or 0) == 1

            # --- Hard Stop ---
            if pnl <= -self.cfg.hard_stop_pct:
                self.log(f"[SELL] HARD STOP {symbol or mint[:4]} pnl={pnl:.2%} price={price}")
                await self.emit_sell(wallet, mint, symbol, frac=1.0, reason="HARD_STOP", price=price)
                close_position(self.db, wallet=wallet, mint=mint, close_price_usd=price, reason="HARD_STOP", ts=now_ts())
                continue

            # --- Trailing stop ---
            if trail is not None and price <= trail:
                self.log(f"[SELL] TRAIL STOP {symbol or mint[:4]} price={price} trail={trail}")
                await self.emit_sell(wallet, mint, symbol, frac=1.0, reason="TRAIL_STOP", price=price)
                close_position(self.db, wallet=wallet, mint=mint, close_price_usd=price, reason="TRAIL_STOP", ts=now_ts())
                continue

            # --- TP1 ---
            if (not tp1_done) and pnl >= self.cfg.tp1_pct:
                frac = self.cfg.tp1_sell_frac
                self.log(f"[SELL] TP1 {symbol or mint[:4]} pnl={pnl:.2%} sell_frac={frac:.0%}")
                await self.emit_sell(wallet, mint, symbol, frac=frac, reason="TP1", price=price)
                mark_tp_done(self.db, wallet=wallet, mint=mint, which=1)

            # --- TP2 ---
            if (not tp2_done) and pnl >= self.cfg.tp2_pct:
                frac = self.cfg.tp2_sell_frac
                self.log(f"[SELL] TP2 {symbol or mint[:4]} pnl={pnl:.2%} sell_frac={frac:.0%}")
                await self.emit_sell(wallet, mint, symbol, frac=frac, reason="TP2", price=price)
                mark_tp_done(self.db, wallet=wallet, mint=mint, which=2)

    async def emit_sell(self, wallet: str, mint: str, symbol: Optional[str], *, frac: float, reason: str, price: float) -> None:
        # Ici on déclenche ton pipeline existant:
        # trader_exec/sign/send avec un mode SELL.
        # Tu as sûrement une fonction déjà existante. On fait un subprocess safe.
        import subprocess, json, sys

        payload = {
            "side": "SELL",
            "wallet": wallet,
            "mint": mint,
            "symbol": symbol,
            "sell_frac": float(frac),
            "reason": reason,
            "ref_price_usd": float(price),
        }

        cmd = [sys.executable, "-m", "src.trader_loop", "--sell-json", json.dumps(payload)]
        try:
            subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            self.log(f"[SELL] emit failed: {e}")


async def loop_forever():
    db_path = os.getenv("TRADES_DB_PATH", "state/trades.sqlite")
    wallet = os.getenv("WALLET_PUBKEY", "")
    if not wallet:
        raise SystemExit("WALLET_PUBKEY not set")

    eng = SellEngine(db_path)
    while True:
        try:
            await eng.run_once(wallet)
        except Exception as e:
            eng.log(f"[SELL] loop error: {e}")
        await asyncio.sleep(float(os.getenv("SELL_LOOP_S", "2.0")))


if __name__ == "__main__":
    asyncio.run(loop_forever())


# --- compat wrapper for src/run_live.py ---
def sell_engine(*args, **kwargs):
    """
    Thread target used by src/run_live.py.
    Resilient wrapper: tries many runner names; never crashes the thread.
    """
    import os, time, traceback

    # default db path expected by our project
    kwargs.setdefault("db_path", os.getenv("DB_PATH", "state/trades.sqlite"))

    try:
        eng = SellEngine(*args, **kwargs)
    except Exception as e:
        print("❌ sell_engine init failed:", e)
        traceback.print_exc()
        # keep thread alive (do not kill whole bot)
        while True:
            time.sleep(5.0)

    # Try common runner names
    candidates = [
        "run_forever","run","start","loop","main",
        "run_loop","loop_forever","serve",
        "run_engine","engine_loop",
        "process","process_loop","process_forever",
        "tick","tick_loop","update","update_loop",
        "cycle","cycle_loop",
        "work","work_loop",
    ]

    for meth in candidates:
        fn = getattr(eng, meth, None)
        if callable(fn):
            try:
                print(f"✅ sell_engine: using SellEngine.{meth}()")
                return fn()
            except Exception as e:
                print(f"❌ sell_engine runner {meth}() failed:", e)
                traceback.print_exc()
                while True:
                    time.sleep(5.0)

    # If SellEngine is callable (has __call__)
    if callable(eng):
        try:
            print("✅ sell_engine: using SellEngine.__call__()")
            return eng()
        except Exception as e:
            print("❌ sell_engine __call__ failed:", e)
            traceback.print_exc()
            while True:
                time.sleep(5.0)

    # Fallback: try "step-like" methods in a loop
    steppers = ["step","step_once","run_once","once","poll","poll_once"]
    for meth in steppers:
        fn = getattr(eng, meth, None)
        if callable(fn):
            print(f"✅ sell_engine: using step loop SellEngine.{meth}()")
            tick = float(os.getenv("SELL_ENGINE_TICK", "2.0"))
            while True:
                try:
                    try:
                        fn()
                    except TypeError as te:
                        msg = str(te)
                        if "wallet" in msg and ("required positional argument" in msg or "missing" in msg):
                            wobj = _se_wallet_obj()
                            if wobj is None:
                                raise RuntimeError("SellEngine.run_once(wallet) but no wallet available (set SOLANA_KEYPAIR or WALLET_PUBKEY)")
                            fn(wobj)
                        else:
                            raise
                except Exception as e:
                    print(f"❌ sell_engine step {meth}() error:", e)
                    traceback.print_exc()
                time.sleep(tick)
