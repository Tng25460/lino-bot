#!/usr/bin/env python3
import os
def _env_allowed_dexes(default: str = "raydium,meteora,orca"):
    s = os.environ.get("ALLOWED_DEXES", default)
    return [x.strip() for x in s.split(",") if x.strip()]

ALLOWED_DEXES_LIST = _env_allowed_dexes()

import sys
import json
import asyncio
from pathlib import Path

# Make project root importable: allows `import core.*` when running `python src/trader_exec.py`
ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from solders.keypair import Keypair

from core.solana_rpc_async import SolanaRPCAsync
import core.jupiter_exec as jx

# --- Config ---
WSOL_MINT = os.getenv("WSOL_MINT", "So11111111111111111111111111111111111111112")


# -----------------------
# Helpers
# -----------------------
def load_ready(path: str):
    rows = []
    p = Path(path)
    if not p.exists():
        return rows
    with p.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                rows.append(json.loads(line))
            except Exception:
                continue
    return rows


def score_used(o: dict) -> float:
    # prefer score_v4 (0..1) then score2 then score
    for k in ("score_v4", "score2", "score"):
        v = o.get(k)
        if v is None:
            continue
        try:
            return float(v)
        except Exception:
            pass
    return 0.0


def pick_best(rows):
    if not rows:
        return None
    rows = sorted(rows, key=lambda x: score_used(x), reverse=True)
    return rows[0]


def build_allowed_dexes(best: dict):
    dexes = best.get("dexes") or []
    dexes = [str(d).lower() for d in dexes]
    origin = (best.get("origin") or "").lower()

    pref = ["meteora", "raydium", "orca"]
    if origin == "pumpfun":
        pref = ["raydium", "meteora", "orca"]
    allowed = ALLOWED_DEXES_LIST or allowed
    if not allowed:
        allowed = pref
    return allowed


def dex_label(d: str) -> str:
    d = (d or "").lower()
    if d == "meteora":
        return "Meteora+DLMM"
    if d == "raydium":
        return "Raydium"
    if d == "orca":
        return "Orca"
    return d


def _pick_jup_buy_func():
    if hasattr(jx, "jup_buy_exact_in"):
        return jx.jup_buy_exact_in, "jup_buy_exact_in"
    raise RuntimeError("No Jupiter BUY function found in core/jupiter_exec.py")


async def _buy_try(buy_func, rpc, wallet, out_mint: str, amount_in: int, dex_list, fallback_any: bool):
    # Controls internal fallback in core/jupiter_exec.py (if you coded it)
    os.environ["JUP_DEX_FALLBACK_ANY"] = "1" if fallback_any else "0"
    try:
        return await buy_func(
            rpc=rpc,
            wallet=wallet,
            input_mint=WSOL_MINT,
            output_mint=out_mint,
            amount_in=amount_in,
            allowed_dexes=dex_list,
        )
    finally:
        # keep env for logs
        pass


async def buy_with_strict_routing(buy_func, rpc, wallet, out_mint: str, amount_in: int, allowed_dexes):
    dexes = [str(d).lower() for d in (allowed_dexes or []) if d]

    # 1) strict per-dex
    for d in dexes:
        print(f"ðŸ§­ routing_try strict dex_only={d} (JUP_DEX_FALLBACK_ANY=0)", flush=True)
        try:
            return await _buy_try(buy_func, rpc, wallet, out_mint, amount_in, [d], fallback_any=False)
        except Exception as e:
            print(f"âš ï¸ routing_try failed dex_only={d} err={e}", flush=True)

    # 2) strict with full list
    if dexes:
        print(f"ðŸ§­ routing_try strict dex_list={dexes} (JUP_DEX_FALLBACK_ANY=0)", flush=True)
        try:
            return await _buy_try(buy_func, rpc, wallet, out_mint, amount_in, dexes, fallback_any=False)
        except Exception as e:
            print(f"âš ï¸ routing_try failed dex_list={dexes} err={e}", flush=True)

    # 3) fallback ANY
    strict_only = os.getenv("STRICT_ONLY", "0").strip().lower() in ("1","true","yes","on")
    if strict_only:
        raise RuntimeError(f"STRICT_ONLY=1: no Jupiter route for allowed_dexes={dexes}")

    print("ðŸ§­ routing_fallback ANY (JUP_DEX_FALLBACK_ANY=1)", flush=True)
    return await _buy_try(buy_func, rpc, wallet, out_mint, amount_in, None, fallback_any=True)


def _load_wallet():
    kp_path = os.getenv("KEYPAIR_PATH", str(ROOT / "keypair.json"))
    kb = Path(kp_path).read_text(encoding="utf-8", errors="ignore")
    arr = json.loads(kb)
    return Keypair.from_bytes(bytes(arr))


async def main_async():
    ready_file = os.getenv("READY_FILE", "ready_to_trade_ranked_v4_orca.jsonl")
    dry_run = os.getenv("TRADER_DRY_RUN", "0").strip().lower() in ("1", "true", "yes", "on")
    rpc_http = os.getenv("RPC_HTTP", os.getenv("SOLANA_RPC_HTTP", "https://api.mainnet-beta.solana.com")).strip()
    buy_amount_sol = float(os.getenv("BUY_AMOUNT_SOL", "0.01"))
    amount_in = int(buy_amount_sol * 1_000_000_000)

    print("ðŸš€ trader_exec BUY", flush=True)
    print("   ready_file=", ready_file, flush=True)
    print("   rpc_http=", rpc_http, flush=True)
    print("   dry_run=", dry_run, flush=True)

    rows = load_ready(ready_file)
    print("   ready_count=", len(rows), flush=True)
    best = pick_best(rows)
    if not best:
        print("ðŸ’¤ no candidates", flush=True)
        return 0

    mint = best.get("mint")
    origin = best.get("origin")
    liq = best.get("liquidity_usd")
    vol24 = best.get("vol_24h")
    tx1h = best.get("txns_1h")
    chg1h = best.get("chg_1h")

    allowed = build_allowed_dexes(best)
    labels = [dex_label(d) for d in allowed]
    print(
        f"[DECISION] PICK mint={mint} score_used={score_used(best):.4f} origin={origin} "
        f"dexes={best.get('dexes')} liq={liq} vol24={vol24} tx1h={tx1h} chg1h={chg1h}",
        flush=True,
    )
    print(f"ðŸ”€ route_policy allowed_dexes={allowed} labels={labels}", flush=True)
    print(f"ðŸ’¸ BUY_AMOUNT_SOL= {buy_amount_sol} (lamports={amount_in})", flush=True)

    buy_func, buy_name = _pick_jup_buy_func()
    print(f"ðŸ§© using jupiter func: {buy_name}", flush=True)

    wallet = _load_wallet()
    # RPC init (compatible with different SolanaRPCAsync signatures)
    try:
        rpc = SolanaRPCAsync(rpc_http=rpc_http)
    except TypeError:
        try:
            rpc = SolanaRPCAsync(rpc_url=rpc_http)
        except TypeError:
            try:
                rpc = SolanaRPCAsync(url=rpc_http)
            except TypeError:
                try:
                    rpc = SolanaRPCAsync(endpoint=rpc_http)
                except TypeError:
                    rpc = SolanaRPCAsync(rpc_http)
    try:
        try:
            txsig = await buy_with_strict_routing(buy_func, rpc, wallet, mint, amount_in, allowed)
        except Exception as e:
            if os.getenv('STRICT_ONLY','0').strip().lower() in ('1','true','yes','on'):
                print(f"â›” STRICT_ONLY skip: no route on allowed_dexes={allowed} err={e}", flush=True)
                return 0
            raise

        print(f"âœ… jupiter build result: {txsig}", flush=True)
        if dry_run:
            print("ðŸ§ª TRADER_DRY_RUN=1 -> not sending tx", flush=True)
        return 0
    finally:
        await rpc.aclose()


def main():
    return asyncio.run(main_async())


if __name__ == "__main__":
    raise SystemExit(main())
