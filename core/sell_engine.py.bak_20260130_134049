import traceback\nimport os\nimport json\nimport requests\nfrom solders.keypair import Keypair\nimport subprocess\nimport time as _time\nfrom typing import Dict\n\nclass SellEngine:\n\n    def _onchain_ui_balance(self, mint: str) -> float:\n        """Return on-chain uiAmount total for mint for our owner."""\n        rpc = os.getenv("SOLANA_RPC", "https://api.mainnet-beta.solana.com")\n        keypath = os.getenv("KEYPAIR_PATH", "keypair.json")\n        try:\n            secret = json.load(open(keypath, "r", encoding="utf-8"))\n            kp = Keypair.from_bytes(bytes(secret))\n            owner = str(kp.pubkey())\n        except Exception as e:\n            print(f"‚ùå onchain_ui_balance: keypair load failed err={e}", flush=True)\n            return 0.0\n\n        payload = {"jsonrpc":"2.0","id":1,"method":"getTokenAccountsByOwner",\n                   "params":[owner, {"mint": mint}, {"encoding":"jsonParsed"}]}\n        try:\n            j = requests.post(rpc, json=payload, timeout=25).json()\n        except Exception as e:\n            print(f"‚ùå onchain_ui_balance: rpc call failed err={e}", flush=True)\n            return 0.0\n\n        total = 0.0\n        for a in j.get("result",{}).get("value",[]):\n            try:\n                ui = a["account"]["data"]["parsed"]["info"]["tokenAmount"]["uiAmount"] or 0\n                total += float(ui)\n            except Exception:\n                pass\n        return float(total)\n\n\n    """\n    Sell Engine simple et robuste\n    - TP partiel\n    - Trailing stop\n    - Hard stop\n    """\n\n\n    def _onchain_ui_balance_stable(self, mint: str, tries: int = 3, sleep_s: float = 0.7) -> float:\n        """Return a more stable on-chain UI balance (NON-RECURSIVE).\n        Samples _onchain_ui_balance() up to N tries and returns when 2 consecutive reads are close.\n        Has a hard timeout so the sell loop can never freeze."""\n        import os, time as _time\n        # env overrides\n        try:\n            tries = int(os.getenv('ONCHAIN_STABLE_TRIES', str(tries)) or tries)\n        except Exception:\n            pass\n        try:\n            sleep_s = float(os.getenv('ONCHAIN_STABLE_SLEEP_S', str(sleep_s)) or sleep_s)\n        except Exception:\n            pass\n        try:\n            total_timeout = float(os.getenv('ONCHAIN_STABLE_TIMEOUT_S', '4.0') or 4.0)\n        except Exception:\n            total_timeout = 4.0\n        t0 = _time.time()\n        prev = None\n        for k in range(max(1, tries)):\n            if _time.time() - t0 > total_timeout:\n                break\n            v = None\n            try:\n                v = float(self._onchain_ui_balance(mint) or 0.0)\n            except Exception:\n                v = None\n            if v is not None and prev is not None:\n                # close enough -> stable\n                if abs(v - prev) <= max(1e-12, abs(prev) * 0.005):\n                    return float(v)\n            if v is not None:\n                prev = float(v)\n            _time.sleep(max(0.0, sleep_s))\n        return float(prev or 0.0)\n    def __init__(self, db, price_feed):\n        self.db = db\n        self.price_feed = price_feed\n\n        # Config (env)\n        self.TP1_PCT = float(os.getenv("SELL_TP1_PCT", "0.30"))      # +30%\n        self.TP1_SIZE = float(os.getenv("SELL_TP1_SIZE", "0.50"))   # 50%\n        self.TP2_PCT = float(os.getenv("SELL_TP2_PCT", "1.00"))     # +100%\n        self.TP2_SIZE = float(os.getenv("SELL_TP2_SIZE", "0.25"))   # 25%\n\n        self.HARD_SL_PCT = -abs(float(os.getenv("SELL_HARD_SL_PCT", "0.25")))  # loss, e.g. 0.25 => -0.25\n        self.TRAIL_TIGHT = float(os.getenv("SELL_TRAIL_TIGHT", "0.10"))  # 10%\n        self.TRAIL_WIDE  = float(os.getenv("SELL_TRAIL_WIDE",  "0.20"))  # 20%\n\n        self.TIME_STOP_SEC = int(os.getenv("SELL_TIME_STOP_SEC", "1800"))  # 30 min\n        self.TIME_STOP_MIN_PNL = float(os.getenv("SELL_TIME_STOP_MIN_PNL", "0.05"))\n    def _sell_ui_via_exec(self, mint: str, ui_amount: float, reason: str) -> str:\n        """Execute SELL via Jupiter by calling src/sell_exec.py.\n        Logs stdout/stderr and returns txsig string (or DRY_RUN_NO_TX_SENT).\n        """\n        if ui_amount <= 0:\n            raise ValueError("ui_amount must be > 0")\n\n        cmd = ["python","-u","src/sell_exec.py","--mint",mint,"--ui",str(ui_amount),"--reason",reason]\n        print("üßæ SELL cmd=" + " ".join(cmd), flush=True)\n\n        proc = subprocess.run(cmd, capture_output=True, text=True)\n        out = (proc.stdout or "").strip()\n        err = (proc.stderr or "").strip()\n\n        if out:\n            print("üì§ sell_exec stdout:\n" + out, flush=True)\n        if err:\n            print("üì• sell_exec stderr:\n" + err, flush=True)\n\n        # parse txsig from stdout\n        txsig = ""\n        for line in (proc.stdout or "").splitlines():\n            if line.startswith("txsig="):\n                txsig = line.split("=",1)[1].strip()\n\n        if proc.returncode != 0:\n            raise RuntimeError(f"sell_exec failed rc={proc.returncode} txsig={txsig}")\n\n        if not txsig:\n            raise RuntimeError("sell_exec returned success but no txsig=... found")\n\n        return txsig\n\n\n    def run_once(self):\n        now = _time.time()\n        positions = self.db.get_open_positions()\n        print(f"üí∞ sell_engine: open_positions={len(positions)}", flush=True)\n        if not positions:\n            print("üí§ sell_engine: no open positions -> skip", flush=True)\n            return\n        for pos in positions:\n            try:\n                self._handle_position(pos, now)\n            except Exception as e:\n                print(f"‚ùå sell_engine error mint={pos.get('mint')}: {e}", flush=True)\n                print(traceback.format_exc(), flush=True)\n\n    def _sync_qty_db(self, pos, qty_ui: float) -> None:\n        """Persist qty_token for OPEN position when bootstrapped from on-chain.\n        Uses sqlite3 directly (PositionsDBAdapter does not expose .con; pos may not have rowid)."""\n        try:\n            import os, sqlite3\n            if not isinstance(pos, dict):\n                return\n            mint = str(pos.get('mint') or '')\n            if not mint:\n                return\n            db_path = os.getenv('DB_PATH', 'state/trades.sqlite')\n            con = sqlite3.connect(db_path, timeout=30)\n            cur = con.cursor()\n            cur.execute(\n                """UPDATE positions\n                   SET qty_token=?\n                 WHERE mint=? AND lower(status)='open'""",\n                (float(qty_ui), mint),\n            )\n            con.commit()\n            rows = cur.rowcount\n            con.close()\n            print("üßæ SYNC_DB_QTY mint=%s rows=%s qty_token=%s" % (mint, rows, qty_ui), flush=True)\n        except Exception as e:\n            m2 = None\n            try:\n                m2 = pos.get('mint') if isinstance(pos, dict) else None\n            except Exception:\n                m2 = None\n            print("‚ö†Ô∏è SYNC_DB_QTY failed mint=%s err=%r" % (m2, e), flush=True)\n\n    def _handle_position(self, pos: Dict, now: float):\n        mint = pos["mint"]\n        # === BOOTSTRAP_ENTRY_PRICE_USD_VIA_GET_PRICE (avoid div0) ===\n        try:\n            _entry = float((pos.get("entry_price_usd") or pos.get("entry_price") or 0) or 0)\n        except Exception:\n            _entry = 0.0\n        if _entry <= 0.0:\n            _p = 0.0\n            try:\n                pf = getattr(self, "price_feed", None)\n                if pf is not None and hasattr(pf, "get_price"):\n                    _p = float(pf.get_price(mint) or 0.0)\n            except Exception:\n                _p = 0.0\n            if _p > 0.0:\n                try:\n                    self.db.update_position(mint, entry_price_usd=_p, entry_price=_p)\n                except Exception:\n                    pass\n                # force local vars (si utilis√©s plus bas)\n                try: entry_price_usd = _p\n                except Exception: pass\n                try: entry_price = _p\n                except Exception: pass\n                print(f"üß© BOOTSTRAP_ENTRY_PRICE_USD mint={mint} entry_price_usd={_p}", flush=True)\n            else:\n                print(f"‚ö†Ô∏è BOOTSTRAP_ENTRY_PRICE_USD failed mint={mint} (get_price=0)", flush=True)\n        # === end BOOTSTRAP_ENTRY_PRICE_USD_VIA_GET_PRICE ===\n\n        entry = float(pos["entry_price"])\n        size = float(pos.get("qty_token") or pos.get("qty") or 0.0)\n        # --- BOOTSTRAP qty from on-chain if DB qty is zero ---\n        if float(size) <= 0.0:\n            try:\n                oc = float(self._onchain_ui_balance_stable(mint, tries=3, sleep_s=0.7) or 0.0)\n                if oc > 0.0:\n                    size = oc\n                    print(f"üß© BOOTSTRAP_QTY_ONCHAIN mint={mint} ui={oc} (db_qty=0) -> using on-chain", flush=True)\n                    self._sync_qty_db(pos, size)\n                else:\n                    print(f"üßä ONCHAIN_QTY_ZERO mint={mint} (db_qty=0) -> close/sync", flush=True)\n                    if os.getenv("SELL_DRY_RUN","0") == "1":\n                        print("üß™ SELL_DRY_RUN=1 -> keep position open (no close)", flush=True)\n                        return\n                    self.db.close_position(mint, reason="sync_onchain_zero")\n                    return\n            except Exception as e:\n                print(f"‚ùå BOOTSTRAP_QTY_ONCHAIN failed mint={mint} err={e}", flush=True)\n        # --- init high_water if missing ---\n        if float(pos.get("high_water") or 0.0) <= 0.0:\n            try:\n                hw0 = max(float(entry or 0.0), float(price or 0.0))\n                if hw0 > 0.0:\n                    pos["high_water"] = hw0\n            except Exception:\n                pass\n        entry_ts = float(pos["entry_ts"])\n\n        price = self.price_feed.get_price(mint)\n\n        # --- FIX: bootstrap entry if missing (avoid div0, allow TP logic) ---\n        try:\n            _entry = float(pos.get('entry_price') or pos.get('entry_price_usd') or pos.get('entry_price_usd') or 0.0)\n        except Exception:\n            _entry = 0.0\n        if _entry <= 0.0 and float(price) > 0.0:\n            _entry = float(price)\n            pos['entry_price'] = _entry\n            try:\n                self.db.update_position(mint, entry_price=_entry, entry_price_usd=_entry)\n            except Exception:\n                pass\n            print(f"üß© BOOTSTRAP_ENTRY_FROM_PRICE mint={mint} entry={_entry}", flush=True)\n\n        if not price or price <= 0:\n            return\n\n        # --- SAFE pnl (no div0) ---\n        # --- PATCH: if entry missing but price available, set entry=price (avoid permanent skip) ---\n        if (entry is None or entry <= 0) and (price is not None and price > 0):\n            try:\n                print(f"ü©π FIX entry<=0 -> set entry=price mint={mint} entry={entry} price={price}", flush=True)\n                entry = float(price)\n                pos['entry_price_usd'] = entry\n                # persist minimal fix to DB if possible\n                try:\n                    self._sync_entry_db(mint, entry)\n                except Exception as _e:\n                    pass\n            except Exception:\n                pass\n\n        if float(entry or 0.0) <= 0.0:\n\n            print(f"üßØ SKIP pnl div0 mint={mint} entry={entry} price={price}", flush=True)\n\n            return\n\n        # --- SAFE pnl (no div0) ---\n\n        if float(entry or 0.0) <= 0.0:\n\n            print(f"üßØ SKIP pnl div0 mint={mint} entry={entry} price={price}", flush=True)\n\n            return\n\n        # --- BOOTSTRAP qty/entry from on-chain if DB has zeros ---\n\n        # --- SAFE PnL calc (after bootstrap) ---\n\n        if entry <= 0:\n\n            print(f"üßØ SKIP pnl div0 mint={mint} entry={entry} price={price}", flush=True)\n\n            return\n\n        pnl = (price - entry) / entry\n\n        print("üìà PRICE mint=%s entry=%s price=%s pnl=%.2f%% tp1=%s tp2=%s hw=%s" % (mint, entry, price, pnl*100.0, pos.get("tp1_done"), pos.get("tp2_done"), pos.get("high_water")), flush=True)\n\n        highest = float(pos.get("high_water") or entry)\n        if price > highest:\n            highest = price\n            self.db.update_position(mint, high_water=highest)\n\n        # --- HARD STOP ---\n        if pnl <= self.HARD_SL_PCT:\n            print(f"üî¥ HARD SL mint={mint} pnl={pnl:.2%}", flush=True)\n            try:\n                txsig = self._sell_ui_via_exec(mint, float(pos.get("qty_token") or 0.0), "hard_sl")\n                print(f"‚úÖ SELL HARD_SL txsig={txsig}", flush=True)\n                self.db.close_position(mint, reason="hard_sl")\n                return\n            except Exception as e:\n                print(f"‚ùå SELL HARD_SL failed mint={mint} err={e}", flush=True)\n                return\n\n        # --- TIME STOP ---\n        if True:  # allow TIME STOP even after TP1\n            if now - entry_ts > self.TIME_STOP_SEC and pnl < self.TIME_STOP_MIN_PNL:\n                print(f"‚è±Ô∏è TIME STOP mint={mint} pnl={pnl:.2%}", flush=True)\n                # sell remaining fraction based on TP flags\n                rem_frac = 1.0\n                if pos.get('tp1_done'):\n                    rem_frac -= float(self.TP1_SIZE)\n                if pos.get('tp2_done'):\n                    rem_frac -= float(self.TP2_SIZE)\n                if rem_frac < 0:\n                    rem_frac = 0.0\n                ui_sell = float(size) * rem_frac\n                try:\n                    txsig = self._sell_ui_via_exec(mint, ui_sell, reason='time_stop')\n                    print(f"‚úÖ TIME_STOP sell txsig={txsig}", flush=True)\n                except Exception as e:\n                    print(f"‚ùå TIME_STOP sell error: {e}", flush=True)\n                    return\n                if os.getenv("SELL_DRY_RUN","0") == "1":\n                    print("üß™ SELL_DRY_RUN=1 -> skip close_position on TIME STOP", flush=True)\n                    return\n                self.db.close_position(mint, reason="time_stop")\n                return\n        # --- TP1 ---\n        if not pos['tp1_done'] and pnl >= self.TP1_PCT:\n            qty = float(size) * float(self.TP1_SIZE)\n            print(f"üü¢ TP1 mint={mint} qty={qty:.4f}", flush=True)\n            try:\n                txsig = self._sell_ui_via_exec(mint, float(qty), 'tp1')\n                print(f"‚úÖ TP1 sell txsig={txsig}", flush=True)\n            except Exception as e:\n                print(f"‚ùå TP1 sell error: {e}", flush=True)\n                return\n        \n            # --- RESYNC remaining qty on-chain after partial sell (TP) ---\n            if os.getenv('SELL_DRY_RUN','0') != '1':\n                try:\n                    _rem = float(self._onchain_ui_balance_stable(mint, tries=3, sleep_s=0.7) or 0.0)\n                    if _rem >= 0.0:\n                        self._sync_qty_db(pos, _rem)\n                        try:\n                            pos['qty_token'] = _rem\n                        except Exception:\n                            pass\n                        print(f"üßæ RESYNC_AFTER_TP mint={mint} qty_token={_rem}", flush=True)\n                except Exception as e:\n                    print(f"‚ö†Ô∏è RESYNC_AFTER_TP failed mint={mint} err={repr(e)}", flush=True)\n        \n            if os.getenv('SELL_DRY_RUN','0') == '1':\n                print('üß™ SELL_DRY_RUN=1 -> skip mark_tp1()', flush=True)\n            else:\n                self.db.mark_tp1(mint)\n            return\n        # --- TP2 ---\n        if pos['tp1_done'] and not pos['tp2_done'] and pnl >= self.TP2_PCT:\n            qty = float(size) * float(self.TP2_SIZE)\n            print(f"üü¢ TP2 mint={mint} qty={qty:.4f}", flush=True)\n            try:\n                txsig = self._sell_ui_via_exec(mint, float(qty), 'tp2')\n                print(f"‚úÖ TP2 sell txsig={txsig}", flush=True)\n            except Exception as e:\n                print(f"‚ùå TP2 sell error: {e}", flush=True)\n                return\n        \n            # --- RESYNC remaining qty on-chain after partial sell (TP) ---\n            if os.getenv('SELL_DRY_RUN','0') != '1':\n                try:\n                    _rem = float(self._onchain_ui_balance_stable(mint, tries=3, sleep_s=0.7) or 0.0)\n                    if _rem >= 0.0:\n                        self._sync_qty_db(pos, _rem)\n                        try:\n                            pos['qty_token'] = _rem\n                        except Exception:\n                            pass\n                        print(f"üßæ RESYNC_AFTER_TP mint={mint} qty_token={_rem}", flush=True)\n                except Exception as e:\n                    print(f"‚ö†Ô∏è RESYNC_AFTER_TP failed mint={mint} err={repr(e)}", flush=True)\n        \n            if os.getenv('SELL_DRY_RUN','0') == '1':\n                print('üß™ SELL_DRY_RUN=1 -> skip mark_tp2()', flush=True)\n            else:\n                self.db.mark_tp2(mint)\n            return\n        # --- TRAILING STOP ---\n        trail = self.TRAIL_WIDE if pos["tp2_done"] else self.TRAIL_TIGHT\n        stop_price = highest * (1 - trail)\n\n        if price <= stop_price:\n            print(f"üü† TRAIL STOP mint={mint} price={price:.6f}", flush=True)\n            # sell remaining fraction based on TP flags\n            rem_frac = 1.0\n            if pos.get('tp1_done'):\n                rem_frac -= float(self.TP1_SIZE)\n            if pos.get('tp2_done'):\n                rem_frac -= float(self.TP2_SIZE)\n            if rem_frac < 0:\n                rem_frac = 0.0\n            ui_sell = float(size) * rem_frac\n            try:\n                txsig = self._sell_ui_via_exec(mint, ui_sell, reason='trail')\n                print(f"‚úÖ TRAIL sell txsig={txsig}", flush=True)\n            except Exception as e:\n                print(f"‚ùå TRAIL sell error: {e}", flush=True)\n                return\n            if os.getenv("SELL_DRY_RUN","0") == "1":\n                print("üß™ SELL_DRY_RUN=1 -> skip close_position on TRAIL", flush=True)\n                return\n            self.db.close_position(mint, reason="trailing_stop")\n            return\n\n        # --- PATCH: if entry missing but price available, set entry=price (avoid permanent skip) ---\n        if (entry is None or entry <= 0) and (price is not None and price > 0):\n            try:\n                print(f"ü©π FIX entry<=0 -> set entry=price mint={mint} entry={entry} price={price}", flush=True)\n                entry = float(price)\n                pos['entry_price_usd'] = entry\n                # persist minimal fix to DB if possible\n                try:\n                    self._sync_entry_db(mint, entry)\n                except Exception as _e:\n                    pass\n            except Exception:\n                pass\n