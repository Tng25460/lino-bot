import os
import time as _time
import subprocess
import traceback

class SellEngine:
    """
    Sell engine autonome (compatible DB actuelle):
    - lit qty_token (fallback qty)
    - ex√©cute src/sell_exec.py (Jupiter)
    - TP1 / TP2 partiels + hard SL + time stop + trailing
    """

    def __init__(self, db, price_feed, trader=None):
        self.db = db
        self.price_feed = price_feed
        self.trader = trader  # ignored (compat)

        # Fractions (0.01 = 1%)
        self.TP1_PCT = float(os.getenv("SELL_TP1_PCT", "0.30"))
        self.TP1_SIZE = float(os.getenv("SELL_TP1_SIZE", "0.35"))
        self.TP2_PCT = float(os.getenv("SELL_TP2_PCT", "0.80"))
        self.TP2_SIZE = float(os.getenv("SELL_TP2_SIZE", "0.35"))

        self.HARD_SL_PCT = -abs(float(os.getenv("SELL_HARD_SL_PCT", "0.25")))
        self.TRAIL_TIGHT = float(os.getenv("SELL_TRAIL_TIGHT", "0.10"))
        self.TRAIL_WIDE  = float(os.getenv("SELL_TRAIL_WIDE",  "0.20"))

        self.TIME_STOP_SEC = int(os.getenv("SELL_TIME_STOP_SEC", "900"))
        self.TIME_STOP_MIN_PNL = float(os.getenv("SELL_TIME_STOP_MIN_PNL", "0.05"))

        self._cfg_logged = False

    def _ui_qty(self, pos) -> float:
        try:
            return float(pos.get("qty_token") or pos.get("qty") or 0.0)
        except Exception:
            return 0.0

    def _entry(self, pos) -> float:
        try:
            return float(pos.get("entry_price") or pos.get("entry_price_usd") or 0.0)
        except Exception:
            return 0.0

    def _sell_exec(self, mint: str, ui_amount: float, reason: str) -> str:
        ui_amount = float(ui_amount or 0.0)
        if ui_amount <= 0:
            print(f"üßπ SELL_SKIP mint={mint} reason={reason} ui_amount={ui_amount}", flush=True)
            return ""

        cmd = ["python", "-u", "src/sell_exec.py", "--mint", mint, "--ui", str(ui_amount), "--reason", reason]
        print("üßæ SELL cmd=" + " ".join(cmd), flush=True)

        proc = subprocess.run(cmd, capture_output=True, text=True)
        out = (proc.stdout or "").strip()
        err = (proc.stderr or "").strip()

        if out:
            print("üì§ sell_exec stdout:\n" + out, flush=True)
        if err:
            print("üì• sell_exec stderr:\n" + err, flush=True)

        # extract txsig
        txsig = ""
        for line in (proc.stdout or "").splitlines():
            if line.startswith("txsig="):
                txsig = line.split("=", 1)[1].strip()

        if proc.returncode != 0:
            blob = (out + "\n" + err).lower()

            # anti-dust: computed amount <= 0 => close as dust (best effort)
            if "computed amount <= 0" in blob:
                print("‚ö†Ô∏è SELL_SKIP_DUST mint=", mint, "ui=", ui_amount, "reason=", reason, "-> CLOSE", flush=True)
                try:
                    self.db.close_position(mint, close_reason="dust", close_ts=int(_time.time()))
                except Exception:
                    pass
                return ""

            # Jupiter error 0x1788 == 6024 == InsufficientFunds => skip (no crash loop)
            # (lack SOL for fees/rent etc)
            if "0x1788" in blob or "6024" in blob or "insufficientfunds" in blob or "insufficient funds" in blob:
                print("‚ö†Ô∏è JUP_INSUFFICIENT_FUNDS -> skip sell (need more SOL for fees/rent)", flush=True)
                return ""

            raise RuntimeError(f"sell_exec failed rc={proc.returncode} txsig={txsig}")

        return txsig or "NO_TXSIG"

    def run_once(self):
        only_mint = (os.getenv("SELL_ONLY_MINT", "") or "").strip()
        if only_mint:
            print("üß™ SELL_ONLY_MINT=", only_mint, flush=True)

        # log SELL_* once
        if not self._cfg_logged:
            self._cfg_logged = True
            keys = sorted([k for k in os.environ.keys() if k.startswith("SELL_")])
            snap = {k: os.getenv(k) for k in keys}
            print("üßæ SELL_ENGINE_CFG " + " ".join([k + "=" + str(snap.get(k)) for k in keys]), flush=True)
            want = ("hard", "sl", "tp", "trail", "time_stop")
            for name in sorted(dir(self)):
                ln = name.lower()
                if any(w in ln for w in want):
                    try:
                        v = getattr(self, name)
                        if isinstance(v, (int, float, str, bool)):
                            print("üßæ SELL_ENGINE_ATTR " + name + "=" + str(v), flush=True)
                    except Exception:
                        pass

        now = _time.time()
        positions = self.db.get_open_positions() or []
        print(f"üí∞ sell_engine: open_positions={len(positions)}", flush=True)

        for pos in positions:
            mint = str(pos.get("mint") or "")
            if not mint:
                continue
            if only_mint and mint != only_mint:
                continue
            try:
                self._handle_one(pos, now)
            except Exception as e:
                print(f"‚ùå sell_engine error mint={mint}: {e}", flush=True)
                print(traceback.format_exc(), flush=True)

    def _handle_one(self, pos, now: float):
        mint = str(pos.get("mint") or "")
        entry = self._entry(pos)
        qty_total = self._ui_qty(pos)
        entry_ts = float(pos.get("entry_ts") or pos.get("opened_ts") or 0.0)

        price = float(self.price_feed.get_price(mint) or 0.0)
        if price <= 0:
            return

        if entry <= 0:
            entry = price
            try:
                self.db.update_position(mint, entry_price=entry, entry_price_usd=entry)
            except Exception:
                pass
            pos["entry_price"] = entry
            print(f"üß© BOOTSTRAP_ENTRY_FROM_PRICE mint={mint} entry={entry}", flush=True)

        pnl = (price - entry) / entry

        # high water
        hw = float(pos.get("high_water") or pos.get("highest_price") or entry)
        if price > hw:
            hw = price
            try:
                self.db.update_position(mint, high_water=hw, highest_price=hw)
            except Exception:
                pass

        tp1 = bool(pos.get("tp1_done"))
        tp2 = bool(pos.get("tp2_done"))

        print(
            "üìà PRICE mint=%s entry=%s price=%s pnl=%.2f%% tp1=%s tp2=%s hw=%s"
            % (mint, entry, price, pnl * 100.0, int(tp1), int(tp2), hw),
            flush=True,
        )

        # HARD SL (sell ALL)
        if pnl <= self.HARD_SL_PCT:
            print(f"üî¥ HARD_SL mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip HARD_SL sell", flush=True)
                return
            sell_qty = qty_total
            txsig = self._sell_exec(mint, sell_qty, "hard_sl")
            if not txsig:
                return
            print(f"‚úÖ SOLD HARD_SL txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="hard_sl")
            except Exception:
                pass
            return

        # TIME STOP (sell ALL)  (condition: age > TIME_STOP_SEC AND pnl < TIME_STOP_MIN_PNL)
        if entry_ts > 0 and (now - entry_ts) > self.TIME_STOP_SEC and pnl < self.TIME_STOP_MIN_PNL:
            print(f"‚è±Ô∏è TIME_STOP mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TIME_STOP sell", flush=True)
                return
            sell_qty = qty_total
            txsig = self._sell_exec(mint, sell_qty, "time_stop")
            if not txsig:
                return
            print(f"‚úÖ SOLD TIME_STOP txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="time_stop")
            except Exception:
                pass
            return

        # TP1
        if (not tp1) and pnl >= self.TP1_PCT:
            sell_qty = qty_total * float(self.TP1_SIZE)
            if sell_qty <= 0:
                print(f"‚è≠Ô∏è TP1 SKIP qty<=0 mint={mint}", flush=True)
                return
            print(f"üü¢ TP1 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TP1 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp1")
            if not txsig:
                return
            print(f"‚úÖ SOLD TP1 txsig={txsig}", flush=True)
            try:
                self.db.mark_tp1(mint)
            except Exception:
                pass
            return

        # TP2
        if tp1 and (not tp2) and pnl >= self.TP2_PCT:
            sell_qty = qty_total * float(self.TP2_SIZE)
            if sell_qty <= 0:
                print(f"‚è≠Ô∏è TP2 SKIP qty<=0 mint={mint}", flush=True)
                return
            print(f"üü¢ TP2 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TP2 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp2")
            if not txsig:
                return
            print(f"‚úÖ SOLD TP2 txsig={txsig}", flush=True)
            try:
                self.db.mark_tp2(mint)
            except Exception:
                pass
            return

        # TRAIL (sell ALL)
        trail = self.TRAIL_WIDE if tp2 else self.TRAIL_TIGHT
        stop_price = hw * (1 - trail)
        if hw > 0 and price <= stop_price:
            print(f"üü† TRAIL_STOP mint={mint} price={price} stop={stop_price} hw={hw}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TRAIL sell", flush=True)
                return
            sell_qty = qty_total
            txsig = self._sell_exec(mint, sell_qty, "trailing_stop")
            if not txsig:
                return
            print(f"‚úÖ SOLD TRAIL txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="trailing_stop")
            except Exception:
                pass
            return
