from __future__ import annotations

import json
import os
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from config import settings


def _now() -> float:
    return float(time.time())


def _safe_float(x: Any, default: float = 0.0) -> float:
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default


@dataclass
class SellDecision:
    should_sell: bool
    reason: str = ""
    exit_price: float = 0.0


class TradingEngine:
    """
    Stratégie (simple et efficace):
    - Stop Loss: -10% vs entry
    - Trailing Take Profit: vendre si prix <= (ATH * (1 - 10%)) ET ATH > entry
    - Anti double-buy:
        * bloque si déjà OPEN
        * bloque si achat en cours (buy_inflight)
        * bloque si mint en cooldown (per_mint_cooldown)
    - positions persistées dans positions.json
    """

    def __init__(self, wallet, logger, positions_file: str, mode: str):
        self.wallet = wallet
        self.logger = logger
        self.positions_file = positions_file or "positions.json"
        self.mode = (mode or "PAPER").upper().strip()

        # --- états ---
        self.positions: Dict[str, Dict[str, Any]] = {}  # mint -> pos dict
        self.buy_inflight: set[str] = set()
        self.sell_inflight: set[str] = set()
        self.last_buy_ts: float = 0.0
        self.last_trade_by_mint: Dict[str, float] = {}  # anti re-buy

        from core.real_executor import RealExecutor
        from core.paper_executor import PaperExecutor

        if self.mode == "REAL":
            self.executor = RealExecutor(wallet, logger)
        else:
            self.executor = PaperExecutor(wallet, logger)

        self._load_positions()

        sl = _safe_float(getattr(settings, "STOP_LOSS_PCT", 0.10), 0.10)
        tr = _safe_float(getattr(settings, "TRAILING_FROM_HIGH_PCT", 0.10), 0.10)

        self.logger.info(
            "[TradingEngine] Initialisé (mode=%s, SL=-%.0f%%, trailing=-%.0f%% du high).",
            self.mode, sl * 100, tr * 100
        )

    # ---------------- persistence ----------------
    def _load_positions(self) -> None:
        p = Path(self.positions_file)
        if not p.exists():
            self.positions = {}
            return
        try:
            self.positions = json.loads(p.read_text(encoding="utf-8") or "{}") or {}
            # normaliser
            if not isinstance(self.positions, dict):
                self.positions = {}
        except Exception as e:
            self.logger.error("[POSITIONS] load failed: %s", e, exc_info=True)
            self.positions = {}

    def _save_positions(self) -> None:
        p = Path(self.positions_file)
        tmp = p.with_suffix(p.suffix + ".tmp")
        try:
            tmp.write_text(json.dumps(self.positions, indent=2, ensure_ascii=False), encoding="utf-8")
            os.replace(tmp, p)
        except Exception as e:
            self.logger.error("[POSITIONS] save failed: %s", e, exc_info=True)

    # ---------------- helpers ----------------
    def _open_positions(self) -> List[Dict[str, Any]]:
        out = []
        for mint, pos in (self.positions or {}).items():
            if isinstance(pos, dict) and pos.get("status") == "OPEN":
                out.append(pos)
        return out

    def _get_pos(self, mint: str) -> Optional[Dict[str, Any]]:
        pos = (self.positions or {}).get(mint)
        if isinstance(pos, dict):
            return pos
        return None

    def _price_from_overviews(self, mint: str, overviews: List[Dict[str, Any]]) -> Optional[float]:
        for ov in (overviews or []):
            m = ov.get("mint") or ov.get("token") or ov.get("address")
            if m == mint:
                px = ov.get("price_usd") or ov.get("price")
                px = _safe_float(px, 0.0)
                return px if px > 0 else None
        return None

    def _should_sell(self, pos: Dict[str, Any], price: float) -> SellDecision:
        entry = _safe_float(pos.get("entry_price"), 0.0)
        high = _safe_float(pos.get("high_price"), entry)

        if entry <= 0 or price <= 0:
            return SellDecision(False)

        stop_loss_pct = _safe_float(getattr(settings, "STOP_LOSS_PCT", 0.10), 0.10)
        trailing_pct = _safe_float(getattr(settings, "TRAILING_FROM_HIGH_PCT", 0.10), 0.10)

        sl_level = entry * (1.0 - stop_loss_pct)
        if price <= sl_level:
            return SellDecision(True, f"STOP_LOSS (-{stop_loss_pct*100:.0f}%)", price)

        # trailing seulement si on a fait au moins un plus haut > entry
        if high > entry:
            tr_level = high * (1.0 - trailing_pct)
            if price <= tr_level:
                return SellDecision(True, f"TRAILING_FROM_HIGH (-{trailing_pct*100:.0f}% from ATH)", price)

        return SellDecision(False)

    def _can_buy_mint(self, mint: str) -> Tuple[bool, str]:
        # déjà en position OPEN ?
        pos = self._get_pos(mint)
        if pos and pos.get("status") == "OPEN":
            return False, "already_open"

        # achat en cours sur ce mint ?
        if mint in self.buy_inflight:
            return False, "buy_inflight"

        # cooldown par mint (anti re-buy spam)
        per_mint_cd = float(getattr(settings, "PER_MINT_COOLDOWN_SECONDS", 900))  # 15 min par défaut
        last = float(self.last_trade_by_mint.get(mint, 0.0))
        if per_mint_cd > 0 and (_now() - last) < per_mint_cd:
            return False, f"mint_cooldown({int(per_mint_cd)}s)"

        # max positions
        max_pos = int(getattr(settings, "MAX_POSITIONS", 1))
        if max_pos > 0 and len(self._open_positions()) >= max_pos:
            return False, "max_positions_reached"

        return True, "ok"

    # ---------------- main loop ----------------
    async def on_overviews(self, overviews: List[Dict[str, Any]], risk_checker) -> None:
        self.logger.info("[DBG_ENTER] on_overviews called, n=%s", (len(overviews) if overviews else 0))

        # 1) update positions + check sell
        await self._manage_positions(overviews)

        # 2) buy logic (1 buy max par cycle)
        did_buy = False
        now = _now()

        for ov in (overviews or []):
            if did_buy:
                break

            mint: Optional[str] = ov.get("mint") or ov.get("token") or ov.get("address")
            price = ov.get("price_usd") or ov.get("price")
            dex = (ov.get("dex_id") or "").lower().strip()

            if not mint:
                continue
            price_f = _safe_float(price, 0.0)
            if price_f <= 0:
                continue

            # REAL: Raydium only
            if self.mode == "REAL" and dex and dex != "raydium":
                self.logger.info("[SKIP] dex=%s mint=%s (REAL=Raydium only)", dex, mint)
                continue

            # cooldown global buy
            cooldown = float(getattr(settings, "BUY_COOLDOWN_SECONDS", 0))
            if cooldown > 0 and (now - float(self.last_buy_ts or 0.0) < cooldown):
                continue

            self.logger.info(
                "[DBG_PRE_RISK] mint=%s liq=%s mc=%s price=%s dex=%s",
                mint, ov.get("liquidity_usd"), ov.get("marketcap_usd"), ov.get("price_usd"), dex
            )

            ok, reason = risk_checker.allow_buy(ov)
            self.logger.info("[DBG_RISK] mint=%s ok=%s reason=%s", mint, ok, reason)
            if not ok:
                self.logger.info("[BUY] Skip %s (risk: %s)", mint, reason)
                continue

            can, why = self._can_buy_mint(mint)
            if not can:
                self.logger.info("[BUY] Skip %s (%s)", mint, why)
                continue

            sol_amount = float(getattr(settings, "BUY_AMOUNT_SOL", 0.0))
            if sol_amount <= 0:
                self.logger.info("[BUY] Skip %s (BUY_AMOUNT_SOL<=0)", mint)
                continue

            self.logger.info("[BUY] Signal %s price~%.8f size=%.4f SOL mode=%s", mint, price_f, sol_amount, self.mode)

            self.buy_inflight.add(mint)
            try:
                res = self.executor.buy(mint, sol_amount, price_f)
                if hasattr(res, "__await__"):
                    res = await res

                # res peut être signature str ou dict, on récupère ce qu'on peut
                sig = None
                if isinstance(res, str):
                    sig = res
                elif isinstance(res, dict):
                    sig = res.get("sig") or res.get("signature") or res.get("tx")

                pos = {
                    "mint": mint,
                    "status": "OPEN",
                    "entry_price": price_f,
                    "high_price": price_f,
                    "opened_ts": now,
                    "buy_sig": sig,
                    "last_price": price_f,
                }
                self.positions[mint] = pos
                self._save_positions()

                self.last_buy_ts = now
                self.last_trade_by_mint[mint] = now
                did_buy = True

                self.logger.info("[BUY OK] %s tx=%s", mint, sig)

            except Exception as e:
                self.logger.error("[BUY ERROR] %s: %s", mint, e, exc_info=True)
            finally:
                self.buy_inflight.discard(mint)

        self._print_portfolio()

    async def _manage_positions(self, overviews: List[Dict[str, Any]]) -> None:
        # on vérifie les positions OPEN uniquement
        open_positions = self._open_positions()
        if not open_positions:
            return

        for pos in open_positions:
            mint = pos.get("mint")
            if not mint or not isinstance(mint, str):
                continue

            price = self._price_from_overviews(mint, overviews)
            if price is None:
                # pas de price update ce tour → on ne peut pas appliquer SL/trailing
                continue

            pos["last_price"] = price

            # update ATH
            high = _safe_float(pos.get("high_price"), _safe_float(pos.get("entry_price"), price))
            if price > high:
                pos["high_price"] = price
                high = price

            decision = self._should_sell(pos, price)
            if not decision.should_sell:
                continue

            if mint in self.sell_inflight:
                continue

            self.sell_inflight.add(mint)
            try:
                self.logger.info("[SELL] %s reason=%s price=%.8f entry=%.8f high=%.8f",
                                 mint, decision.reason,
                                 price,
                                 _safe_float(pos.get("entry_price"), 0.0),
                                 _safe_float(pos.get("high_price"), 0.0))

                res = self.executor.sell(mint)
                if hasattr(res, "__await__"):
                    res = await res

                sig = None
                if isinstance(res, str):
                    sig = res
                elif isinstance(res, dict):
                    sig = res.get("sig") or res.get("signature") or res.get("tx")

                entry = _safe_float(pos.get("entry_price"), 0.0)
                pnl_pct = ((price - entry) / entry) if entry > 0 else 0.0

                pos["status"] = "CLOSED"
                pos["closed_ts"] = _now()
                pos["sell_sig"] = sig
                pos["exit_price"] = price
                pos["close_reason"] = decision.reason
                pos["pnl_pct"] = pnl_pct

                self.positions[mint] = pos
                self._save_positions()

                self.last_trade_by_mint[mint] = _now()

                self.logger.info("[SELL OK] %s tx=%s pnl=%.2f%%", mint, sig, pnl_pct * 100)

            except Exception as e:
                self.logger.error("[SELL ERROR] %s: %s", mint, e, exc_info=True)
            finally:
                self.sell_inflight.discard(mint)

    def _print_portfolio(self) -> None:
        open_positions = self._open_positions()
        open_n = len(open_positions)
        closed_n = sum(1 for _, p in (self.positions or {}).items() if isinstance(p, dict) and p.get("status") == "CLOSED")

        self.logger.info(
            "[PORTFOLIO] mode=%s open=%d closed=%d positions_file=%s",
            self.mode, open_n, closed_n, self.positions_file
        )
