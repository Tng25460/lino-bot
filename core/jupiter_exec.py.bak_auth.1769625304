import os
import json
import base64
import aiohttp
from typing import Dict, Any, Optional, List, Tuple

from solders.keypair import Keypair
from solders.transaction import VersionedTransaction

from core.solana_rpc_async import SolanaRPCAsync

# NOTE:
# - Official API base: https://api.jup.ag (requires x-api-key header per docs)
# - lite-api.jup.ag is being deprecated 31 Jan 2026 (migration recommended)
JUP_BASE = os.getenv("JUP_BASE_URL", "https://api.jup.ag").rstrip("/")

JUP_API_KEY = os.getenv("JUP_API_KEY", "").strip()
SLIPPAGE_BPS = int(os.getenv("JUP_SLIPPAGE_BPS", "250"))
PRIORITY_FEE_MICROLAMPORTS = int(os.getenv("JUP_PRIORITY_FEE_MICROLAMPORTS", "0"))
JUP_TIMEOUT_S = float(os.getenv("JUP_TIMEOUT_S", "20"))
JUP_RETRIES = int(os.getenv("JUP_RETRIES", "3"))

# Keep your behavior: DRY_RUN returns a marker instead of txsig
SELL_DRY_RUN = os.getenv("SELL_DRY_RUN", "1").strip().lower() not in ("0", "false", "no")

# Optional hard excludes (comma-separated Jupiter labels)
# Example: export JUP_EXCLUDE_DEXES="Lifinity,Openbook"
JUP_EXCLUDE_DEXES = os.getenv("JUP_EXCLUDE_DEXES", "").strip()

# Map our internal dex ids (dexscreener-ish) to Jupiter labels (per docs examples)
DEX_LABEL_MAP = {
    "raydium": "Raydium",
    "orca": "Orca+V2",
    "meteora": "Meteora+DLMM",
    # you can add more later when needed:
    # "raydium_clmm": "Raydium+CLMM",
    # "raydium_cpmm": "Raydium",
}

def _headers() -> Dict[str, str]:
    h = {"accept": "application/json"}
    if JUP_API_KEY:
        h["x-api-key"] = JUP_API_KEY
    return h

def _norm_allowed_dexes(allowed_dexes: Optional[List[str]]) -> Optional[List[str]]:
    if not allowed_dexes:
        return None
    out = []
    for d in allowed_dexes:
        if not d:
            continue
        d = str(d).strip()
        if not d:
            continue
        # already a Jupiter label?
        if ("+" in d) or (d[:1].isupper()):
            out.append(d)
            continue
        out.append(DEX_LABEL_MAP.get(d.lower(), d))
    # de-dup keep order
    seen = set()
    uniq = []
    for x in out:
        if x not in seen:
            uniq.append(x); seen.add(x)
    return uniq or None

async def _post_json(session: aiohttp.ClientSession, url: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    last_err = None
    for _ in range(JUP_RETRIES):
        try:
            async with session.post(
                url,
                json=payload,
                headers=_headers(),
                timeout=aiohttp.ClientTimeout(total=JUP_TIMEOUT_S),
            ) as r:
                txt = await r.text()
                if r.status >= 400:
                    raise RuntimeError(f"Jupiter HTTP {r.status}: {txt[:600]}")
                return await r.json()
        except Exception as e:
            last_err = e
    raise RuntimeError(f"Jupiter POST failed after {JUP_RETRIES} tries: {last_err}")

async def _get_json(session: aiohttp.ClientSession, url: str, params: Dict[str, Any]) -> Dict[str, Any]:
    last_err = None
    for _ in range(JUP_RETRIES):
        try:
            async with session.get(
                url,
                params=params,
                headers=_headers(),
                timeout=aiohttp.ClientTimeout(total=JUP_TIMEOUT_S),
            ) as r:
                txt = await r.text()
                if r.status >= 400:
                    raise RuntimeError(f"Jupiter quote HTTP {r.status}: {txt[:600]}")
                return await r.json()
        except Exception as e:
            last_err = e
    raise RuntimeError(f"Jupiter GET failed after {JUP_RETRIES} tries: {last_err}")

def _is_no_route_err(err: Exception) -> bool:
    s = str(err)
    return ("COULD_NOT_FIND_ANY_ROUTE" in s) or ("Could not find any route" in s)

async def jup_build_swap_tx(
    session: aiohttp.ClientSession,
    user_pubkey: str,
    input_mint: str,
    output_mint: str,
    amount_in: int,
    allowed_dexes: Optional[List[str]] = None,
) -> str:
    qurl = f"{JUP_BASE}/swap/v1/quote"
    surl = f"{JUP_BASE}/swap/v1/swap"

    allowed_labels = _norm_allowed_dexes(allowed_dexes)

    def make_params(use_dexes: bool) -> Dict[str, Any]:
        p: Dict[str, Any] = {
            "inputMint": input_mint,
            "outputMint": output_mint,
            "amount": str(amount_in),
            "slippageBps": str(SLIPPAGE_BPS),
        }
        if JUP_EXCLUDE_DEXES:
            p["excludeDexes"] = JUP_EXCLUDE_DEXES
        if use_dexes and allowed_labels:
            # Jupiter expects comma-separated labels, ex: Raydium,Orca+V2,Meteora+DLMM
            p["dexes"] = ",".join(allowed_labels)
            print(f"ðŸ§© jup_quote dexes={allowed_labels}", flush=True)
        return p

    async def do_quote_and_swap(use_dexes: bool) -> str:
        params = make_params(use_dexes=use_dexes)
        quote = await _get_json(session, qurl, params=params)

        body: Dict[str, Any] = {
            "quoteResponse": quote,
            "userPublicKey": user_pubkey,
            "wrapAndUnwrapSol": True,
        }
        if PRIORITY_FEE_MICROLAMPORTS > 0:
            body["prioritizationFeeLamports"] = PRIORITY_FEE_MICROLAMPORTS

        resp = await _post_json(session, surl, body)
        tx_b64 = resp.get("swapTransaction")
        if not tx_b64:
            raise RuntimeError(f"Jupiter swap response missing swapTransaction keys={list(resp.keys())}")
        return tx_b64

    # 1) try restricted dexes if provided
    if allowed_labels:
        try:
            return await do_quote_and_swap(use_dexes=True)
        except Exception as e:
            # If no route with restriction, fallback to any route
            if _is_no_route_err(e):
                print("âš ï¸ jup_quote: no route with dex restriction -> fallback to ANY route", flush=True)
            else:
                print(f"âš ï¸ jup_quote restricted failed -> fallback ANY. err={e}", flush=True)

    # 2) fallback: no dex restriction
    return await do_quote_and_swap(use_dexes=False)

async def jup_sign_and_send(
    rpc: SolanaRPCAsync,
    wallet: Keypair,
    tx_b64: str,
) -> str:
    raw = base64.b64decode(tx_b64)
    vtx = VersionedTransaction.from_bytes(raw)
    sig_tx = VersionedTransaction(vtx.message, [wallet])

    if SELL_DRY_RUN:
        return "DRY_RUN_NO_TX_SENT"

    txsig = await rpc.send_transaction(bytes(sig_tx), skip_preflight=False, max_retries=3)
    return txsig

async def jup_buy_exact_in(
    rpc: SolanaRPCAsync,
    wallet: Keypair,
    input_mint: str,
    output_mint: str,
    amount_in: int,
    allowed_dexes: Optional[List[str]] = None,
) -> str:
    user_pubkey = str(wallet.pubkey())
    async with aiohttp.ClientSession() as session:
        tx_b64 = await jup_build_swap_tx(
            session=session,
            user_pubkey=user_pubkey,
            input_mint=input_mint,
            output_mint=output_mint,
            amount_in=amount_in,
            allowed_dexes=allowed_dexes,
        )
    return await jup_sign_and_send(rpc=rpc, wallet=wallet, tx_b64=tx_b64)

async def jup_sell_exact_in(
    rpc: SolanaRPCAsync,
    wallet: Keypair,
    input_mint: str,
    output_mint: str,
    amount_in: int,
    allowed_dexes: Optional[List[str]] = None,
) -> str:
    user_pubkey = str(wallet.pubkey())
    async with aiohttp.ClientSession() as session:
        tx_b64 = await jup_build_swap_tx(
            session=session,
            user_pubkey=user_pubkey,
            input_mint=input_mint,
            output_mint=output_mint,
            amount_in=amount_in,
            allowed_dexes=allowed_dexes,
        )
    return await jup_sign_and_send(rpc=rpc, wallet=wallet, tx_b64=tx_b64)
