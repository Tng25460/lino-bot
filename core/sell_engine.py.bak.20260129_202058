import traceback
import os
import time as _time
from typing import Dict

class SellEngine:
    """
    Sell Engine simple et robuste
    - TP partiel
    - Trailing stop
    - Hard stop
    """

    def __init__(self, db, price_feed):
        self.db = db
        self.price_feed = price_feed

        # Config (env)
        self.TP1_PCT = float(os.getenv("SELL_TP1_PCT", "0.30"))      # +30%
        self.TP1_SIZE = float(os.getenv("SELL_TP1_SIZE", "0.50"))   # 50%
        self.TP2_PCT = float(os.getenv("SELL_TP2_PCT", "1.00"))     # +100%
        self.TP2_SIZE = float(os.getenv("SELL_TP2_SIZE", "0.25"))   # 25%

        self.HARD_SL_PCT = -abs(float(os.getenv("SELL_HARD_SL_PCT", "0.25")))  # loss, e.g. 0.25 => -0.25
        self.TRAIL_TIGHT = float(os.getenv("SELL_TRAIL_TIGHT", "0.10"))  # 10%
        self.TRAIL_WIDE  = float(os.getenv("SELL_TRAIL_WIDE",  "0.20"))  # 20%

        self.TIME_STOP_SEC = int(os.getenv("SELL_TIME_STOP_SEC", "1800"))  # 30 min
        self.TIME_STOP_MIN_PNL = float(os.getenv("SELL_TIME_STOP_MIN_PNL", "0.05"))

    def run_once(self):
        now = _time.time()
        positions = self.db.get_open_positions()
        print(f"üí∞ sell_engine: open_positions={len(positions)}", flush=True)
        if not positions:
            print("üí§ sell_engine: no open positions -> skip", flush=True)
            return

        for pos in positions:
            try:
                self._handle_position(pos, now)
            except Exception as e:
                print(f"‚ùå sell_engine error mint={pos.get('mint')}: {e}")
                print(traceback.format_exc(), flush=True)


    def _handle_position(self, pos: Dict, now: float):
        mint = pos["mint"]
        # === BOOTSTRAP_ENTRY_PRICE_USD_VIA_GET_PRICE (avoid div0) ===
        try:
            _entry = float((pos.get("entry_price_usd") or pos.get("entry_price") or 0) or 0)
        except Exception:
            _entry = 0.0
        if _entry <= 0.0:
            _p = 0.0
            try:
                pf = getattr(self, "price_feed", None)
                if pf is not None and hasattr(pf, "get_price"):
                    _p = float(pf.get_price(mint) or 0.0)
            except Exception:
                _p = 0.0
            if _p > 0.0:
                try:
                    self.db.update_position(mint, entry_price_usd=_p, entry_price=_p)
                except Exception:
                    pass
                # force local vars (si utilis√©s plus bas)
                try: entry_price_usd = _p
                except Exception: pass
                try: entry_price = _p
                except Exception: pass
                print(f"üß© BOOTSTRAP_ENTRY_PRICE_USD mint={mint} entry_price_usd={_p}", flush=True)
            else:
                print(f"‚ö†Ô∏è BOOTSTRAP_ENTRY_PRICE_USD failed mint={mint} (get_price=0)", flush=True)
        # === end BOOTSTRAP_ENTRY_PRICE_USD_VIA_GET_PRICE ===

        entry = float(pos["entry_price"])
        size = float(pos.get("qty_token") or pos.get("qty") or 0.0)
        entry_ts = float(pos["entry_ts"])

        price = self.price_feed.get_price(mint)
        if not price or price <= 0:
            return

        pnl = (price - entry) / entry
        print("üìà PRICE mint=%s entry=%s price=%s pnl=%.2f%% tp1=%s tp2=%s hw=%s" % (mint, entry, price, pnl*100.0, pos.get("tp1_done"), pos.get("tp2_done"), pos.get("high_water")), flush=True)

        highest = float(pos.get("high_water") or entry)
        if price > highest:
            highest = price
            self.db.update_position(mint, high_water=highest)

        # --- HARD STOP ---
        if pnl <= self.HARD_SL_PCT:
            print(f"üî¥ HARD SL mint={mint} pnl={pnl:.2%}")
            self.db.close_position(mint, reason="hard_sl")
            return

        # --- TIME STOP ---
        if not pos["tp1_done"]:
            if now - entry_ts > self.TIME_STOP_SEC and pnl < self.TIME_STOP_MIN_PNL:
                print(f"‚è±Ô∏è TIME STOP mint={mint} pnl={pnl:.2%}")
                self.db.close_position(mint, reason="time_stop")
                return

        # --- TP1 ---
        if not pos["tp1_done"] and pnl >= self.TP1_PCT:
            qty = size * self.TP1_SIZE
            print(f"üü¢ TP1 mint={mint} qty={qty:.4f}")
            self.db.mark_tp1(mint)
            return

        # --- TP2 ---
        if pos["tp1_done"] and not pos["tp2_done"] and pnl >= self.TP2_PCT:
            qty = size * self.TP2_SIZE
            print(f"üü¢ TP2 mint={mint} qty={qty:.4f}")
            self.db.mark_tp2(mint)
            return

        # --- TRAILING STOP ---
        trail = self.TRAIL_WIDE if pos["tp2_done"] else self.TRAIL_TIGHT
        stop_price = highest * (1 - trail)

        if price <= stop_price:
            print(f"üü† TRAIL STOP mint={mint} price={price:.6f}")
            self.db.close_position(mint, reason="trailing_stop")
            return
