# core/raydium_client.py

import aiohttp
import asyncio
import base64
from typing import Any, Dict, Optional

from solana.rpc.async_api import AsyncClient
from solana.rpc.types import TxOpts
from solana.transaction import Transaction

from solders.keypair import Keypair  # IMPORTANT: solders, pas solana.keypair

from config.settings import JUPITER_API_KEY, RPC_URL

JUPITER_BASE_URL = "https://quote-api.jup.ag/v6"
WSOL_MINT = "So11111111111111111111111111111111111111112"


class RaydiumClient:
    """
    Client Jupiter (quote + swap) utilisé par le TradingEngine en mode REAL.

    - swap_sol_to_token : SOL -> token
    - swap_token_to_sol : token -> SOL (préparé pour plus tard)
    """

    def __init__(self, rpc_url: str = RPC_URL) -> None:
        self.rpc = AsyncClient(rpc_url)
        self.headers = {
            "Content-Type": "application/json",
        }
        if JUPITER_API_KEY:
            self.headers["x-api-key"] = JUPITER_API_KEY

    # ------------------------------------------------------------------
    # Helpers HTTP
    # ------------------------------------------------------------------
    async def _get(self, path: str, params: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        url = f"{JUPITER_BASE_URL}{path}"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, headers=self.headers) as resp:
                    if resp.status != 200:
                        body = await resp.text()
                        print(f"[JUPITER ERROR] GET {url} status={resp.status} body={body}")
                        return None
                    return await resp.json()
        except Exception as e:
            print(f"[JUPITER EXCEPTION] GET {path}: {e}")
            return None

    async def _post(self, path: str, payload: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        url = f"{JUPITER_BASE_URL}{path}"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=payload, headers=self.headers) as resp:
                    if resp.status != 200:
                        body = await resp.text()
                        print(f"[JUPITER ERROR] POST {url} status={resp.status} body={body}")
                        return None
                    return await resp.json()
        except Exception as e:
            print(f"[JUPITER EXCEPTION] POST {path}: {e}")
            return None

    # ------------------------------------------------------------------
    # QUOTE / ROUTE
    # ------------------------------------------------------------------
    async def get_quote(
        self,
        input_mint: str,
        output_mint: str,
        amount_lamports: int,
        slippage_bps: int = 100,
    ) -> Optional[Dict[str, Any]]:
        """
        Récupère un quote Jupiter pour une quantité donnée (exactIn).

        amount_lamports : montant en "base units" (lamports pour SOL, décimals pour token).
        slippage_bps    : 100 = 1% de slippage.
        """
        params = {
            "inputMint": input_mint,
            "outputMint": output_mint,
            "amount": str(amount_lamports),
            "slippageBps": str(slippage_bps),
            "onlyDirectRoutes": "false",
        }
        data = await self._get("/quote", params)
        if not data:
            return None

        routes = data.get("data") or data.get("routePlan") or []
        if not routes:
            print(f"[JUPITER] Pas de route trouvée {input_mint} -> {output_mint}")
            return None

        quote = data["data"][0] if isinstance(data.get("data"), list) else data
        print(
            f"[JUPITER] Route trouvée {input_mint} -> {output_mint} "
            f"(in={amount_lamports}, out est.={quote.get('outAmount')})"
        )
        return quote

    async def has_route(
        self,
        input_mint: str,
        output_mint: str,
        amount_lamports: int,
    ) -> bool:
        quote = await self.get_quote(input_mint, output_mint, amount_lamports)
        return quote is not None

    # ------------------------------------------------------------------
    # SWAP SOL -> TOKEN
    # ------------------------------------------------------------------
    async def swap_sol_to_token(
        self,
        keypair: Keypair,
        token_mint: str,
        amount_sol: float,
        slippage_bps: int = 100,
    ) -> bool:
        """
        Swap SOL -> token via Jupiter.

        - amount_sol : montant en SOL (ex: 0.01).
        - keypair    : solders.Keypair du wallet.

        Retourne True si la transaction est envoyée et confirmée.
        """
        try:
            user_pk = str(keypair.pubkey())   # ICI: .pubkey(), pas .public_key
            amount_lamports = int(amount_sol * 1e9)

            print(
                f"[JUPITER] Demande swap SOL->{token_mint} "
                f"pour {amount_sol:.6f} SOL ({amount_lamports} lamports)"
            )

            # 1) Quote
            quote = await self.get_quote(WSOL_MINT, token_mint, amount_lamports, slippage_bps)
            if not quote:
                print("[JUPITER] Aucun quote, swap annulé.")
                return False

            # 2) Demande de transaction de swap
            payload = {
                "quoteResponse": quote,
                "userPublicKey": user_pk,
                "wrapAndUnwrapSol": True,
                "dynamicComputeUnitLimit": True,
                "prioritizationFeeLamports": "auto",
            }

            swap_data = await self._post("/swap", payload)
            if not swap_data or "swapTransaction" not in swap_data:
                print("[JUPITER] Pas de champ 'swapTransaction' dans la réponse.")
                return False

            swap_tx_b64 = swap_data["swapTransaction"]
            swap_tx_bytes = base64.b64decode(swap_tx_b64)
            tx = Transaction.deserialize(swap_tx_bytes)

            # 3) Signature locale
            tx.sign(keypair)

            # 4) Envoi de la transaction
            raw_tx = tx.serialize()
            send_resp = await self.rpc.send_raw_transaction(
                raw_tx,
                opts=TxOpts(skip_preflight=False, preflight_commitment="confirmed"),
            )
            sig = send_resp.value
            print(f"[JUPITER] Swap envoyé, signature = {sig}")

            # 5) Confirmation
            await self.rpc.confirm_transaction(sig, commitment="confirmed")
            print("[JUPITER] Swap confirmé.")
            return True

        except Exception as e:
            print(f"[JUPITER SWAP ERROR] SOL->{token_mint}: {e}")
            return False

    # ------------------------------------------------------------------
    # SWAP TOKEN -> SOL (préparé pour plus tard)
    # ------------------------------------------------------------------
    async def swap_token_to_sol(
        self,
        keypair: Keypair,
        token_mint: str,
        amount_in_base_units: int,
        slippage_bps: int = 100,
    ) -> bool:
        """
        Swap token -> SOL via Jupiter.
        """
        try:
            user_pk = str(keypair.pubkey())   # ICI aussi .pubkey()

            print(
                f"[JUPITER] Demande swap {token_mint}->SOL "
                f"pour {amount_in_base_units} base units"
            )

            quote = await self.get_quote(token_mint, WSOL_MINT, amount_in_base_units, slippage_bps)
            if not quote:
                print("[JUPITER] Aucun quote, swap token->SOL annulé.")
                return False

            payload = {
                "quoteResponse": quote,
                "userPublicKey": user_pk,
                "wrapAndUnwrapSol": True,
                "dynamicComputeUnitLimit": True,
                "prioritizationFeeLamports": "auto",
            }

            swap_data = await self._post("/swap", payload)
            if not swap_data or "swapTransaction" not in swap_data:
                print("[JUPITER] Pas de champ 'swapTransaction' dans la réponse (token->SOL).")
                return False

            swap_tx_b64 = swap_data["swapTransaction"]
            swap_tx_bytes = base64.b64decode(swap_tx_b64)
            tx = Transaction.deserialize(swap_tx_bytes)

            tx.sign(keypair)

            raw_tx = tx.serialize()
            send_resp = await self.rpc.send_raw_transaction(
                raw_tx,
                opts=TxOpts(skip_preflight=False, preflight_commitment="confirmed"),
            )
            sig = send_resp.value
            print(f"[JUPITER] Swap token->SOL envoyé, signature = {sig}")

            await self.rpc.confirm_transaction(sig, commitment="confirmed")
            print("[JUPITER] Swap token->SOL confirmé.")
            return True

        except Exception as e:
            print(f"[JUPITER SWAP ERROR] {token_mint}->SOL: {e}")
            return False

    # ------------------------------------------------------------------
    # Cleanup
    # ------------------------------------------------------------------
    async def close(self) -> None:
        await self.rpc.close()
