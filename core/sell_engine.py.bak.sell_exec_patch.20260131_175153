import os
import time as _time
import subprocess
import traceback

class SellEngine:
    """
    Sell engine autonome (compatible DB actuelle):
    - lit qty_token (fallback qty)
    - exÃ©cute src/sell_exec.py (Jupiter)
    - TP1 / TP2 partiels + hard SL + time stop + trailing
    """

    def __init__(self, db, price_feed, trader=None):
        self.db = db
        self.price_feed = price_feed
        self.trader = trader  # ignored (compat)

        # Fractions (0.01 = 1%)
        self.TP1_PCT = float(os.getenv("SELL_TP1_PCT", "0.30"))
        self.TP1_SIZE = float(os.getenv("SELL_TP1_SIZE", "0.35"))
        self.TP2_PCT = float(os.getenv("SELL_TP2_PCT", "0.80"))
        self.TP2_SIZE = float(os.getenv("SELL_TP2_SIZE", "0.35"))

        self.HARD_SL_PCT = -abs(float(os.getenv("SELL_HARD_SL_PCT", "0.25")))
        self.TRAIL_TIGHT = float(os.getenv("SELL_TRAIL_TIGHT", "0.10"))
        self.TRAIL_WIDE  = float(os.getenv("SELL_TRAIL_WIDE",  "0.20"))

        self.TIME_STOP_SEC = int(os.getenv("SELL_TIME_STOP_SEC", "900"))
        self.TIME_STOP_MIN_PNL = float(os.getenv("SELL_TIME_STOP_MIN_PNL", "0.05"))

        self._cfg_logged = False
        self._blocked_until = {}  # mint -> ts until which we skip (e.g. no SOL)

    def _ui_qty(self, pos) -> float:
        try:
            return float(pos.get("qty_token") or pos.get("qty") or 0.0)
        except Exception:
            return 0.0

    def _entry(self, pos) -> float:
        try:
            return float(pos.get("entry_price") or pos.get("entry_price_usd") or 0.0)
        except Exception:
            return 0.0
    def _onchain_ui_balance_simple(self, mint: str) -> float:
        import os, json, requests
        pub = os.getenv("WALLET_PUBKEY", "").strip()
        if not pub:
            # fallback: try to read pubkey from keypair
            try:
                from solders.keypair import Keypair
                import json as _json
                kp_path = os.getenv("KEYPAIR_PATH", os.getenv("KEYPATH", "/home/tng25/lino/keypair.json"))
                kp = Keypair.from_bytes(bytes(_json.load(open(kp_path))))
                pub = str(kp.pubkey())
            except Exception:
                return 0.0
        rpc = os.getenv("SOLANA_RPC_URL", os.getenv("RPC_URL", "https://api.mainnet-beta.solana.com"))
        payload = {
            "jsonrpc":"2.0","id":1,"method":"getTokenAccountsByOwner",
            "params":[pub, {"mint": mint}, {"encoding":"jsonParsed"}]
        }
        r = requests.post(rpc, json=payload, timeout=20)
        r.raise_for_status()
        j = r.json()
        vals = (j.get("result",{}) or {}).get("value",[]) or []
        tot = 0.0
        for it in vals:
            try:
                ta = it["account"]["data"]["parsed"]["info"]["tokenAmount"]
                tot += float(ta.get("uiAmount") or 0.0)
            except Exception:
                pass
        return float(tot)

    def _clamp_sell_ui(self, mint: str, ui_db: float) -> float:
        """
        Clamp sell ui to on-chain (prevents oversell -> Jupiter simulation 0x1788).
        """
        try:
            ui_on = float(self._onchain_ui_balance_simple(mint) or 0.0)
        except Exception:
            ui_on = 0.0

        if ui_on > 0:
            ui = min(float(ui_db or 0.0), ui_on)
            # safety epsilon (avoid exact dust/rounding)
            ui = ui * 0.995
            if ui < 0: ui = 0.0
            if ui != float(ui_db or 0.0):
                print(f"ðŸ§© CLAMP_SELL_UI mint={mint} db={ui_db} onchain={ui_on} -> {ui}", flush=True)
            return ui

        return float(ui_db or 0.0)


    def _sell_exec(self, mint: str, ui_amount: float, reason: str) -> str:
        ui_amount = float(ui_amount or 0.0)
        if ui_amount <= 0:
            print(f"ðŸ§¹ SELL_SKIP mint={mint} reason={reason} ui_amount={ui_amount}", flush=True)
            return ""

        cmd = ["python", "-u", "src/sell_exec.py", "--mint", mint, "--ui", str(ui_amount), "--reason", reason]
        print("ðŸ§¾ SELL cmd=" + " ".join(cmd), flush=True)

        proc = subprocess.run(cmd, capture_output=True, text=True)
        out = (proc.stdout or "").strip()
        err = (proc.stderr or "").strip()

        if out:
            print("ðŸ“¤ sell_exec stdout:\n" + out, flush=True)
        if err:
            print("ðŸ“¥ sell_exec stderr:\n" + err, flush=True)

        # extract txsig
        txsig = ""
        for line in (proc.stdout or "").splitlines():
            if line.startswith("txsig="):
                txsig = line.split("=", 1)[1].strip()

        if proc.returncode != 0:
            blob = (out + "\n" + err).lower()

            # anti-dust: computed amount <= 0 => close as dust (best effort)
            if "computed amount <= 0" in blob:
                print("âš ï¸ SELL_SKIP_DUST mint=", mint, "ui=", ui_amount, "reason=", reason, "-> CLOSE", flush=True)
                try:
                    self.db.close_position(mint, close_reason="dust", close_ts=int(_time.time()))
                except Exception:
                    pass
                return ""

            # Jupiter error 0x1788 == 6024 == InsufficientFunds => skip (no crash loop)
            # (lack SOL for fees/rent etc)
            if "0x1788" in blob or "6024" in blob or "insufficientfunds" in blob or "insufficient funds" in blob:
                block_sec = int(os.getenv("SELL_BLOCK_NO_SOL_SEC", "600"))
                self._blocked_until[mint] = _time.time() + block_sec
                print(f"âš ï¸ JUP_INSUFFICIENT_FUNDS -> cooldown {block_sec}s (need SOL for fees/rent)", flush=True)
                return ""

            raise RuntimeError(f"sell_exec failed rc={proc.returncode} txsig={txsig}")

        return txsig or "NO_TXSIG"

    def run_once(self):
        only_mint = (os.getenv("SELL_ONLY_MINT", "") or "").strip()
        if only_mint:
            print("ðŸ§ª SELL_ONLY_MINT=", only_mint, flush=True)

        # log SELL_* once
        if not self._cfg_logged:
            self._cfg_logged = True
            keys = sorted([k for k in os.environ.keys() if k.startswith("SELL_")])
            snap = {k: os.getenv(k) for k in keys}
            print("ðŸ§¾ SELL_ENGINE_CFG " + " ".join([k + "=" + str(snap.get(k)) for k in keys]), flush=True)
            want = ("hard", "sl", "tp", "trail", "time_stop")
            for name in sorted(dir(self)):
                ln = name.lower()
                if any(w in ln for w in want):
                    try:
                        v = getattr(self, name)
                        if isinstance(v, (int, float, str, bool)):
                            print("ðŸ§¾ SELL_ENGINE_ATTR " + name + "=" + str(v), flush=True)
                    except Exception:
                        pass

        now = _time.time()
        positions = self.db.get_open_positions() or []
        print(f"ðŸ’° sell_engine: open_positions={len(positions)}", flush=True)

        for pos in positions:
            mint = str(pos.get("mint") or "")
            if not mint:
                continue
            if only_mint and mint != only_mint:
                continue
            # cooldown if last attempt failed due to missing SOL fees/rent
            bu = float(self._blocked_until.get(mint, 0) or 0)
            if bu and _time.time() < bu:
                print(f"â³ SKIP mint={mint} reason=insufficient_funds cooldown_left={int(bu-_time.time())}s", flush=True)
                continue
            try:
                self._handle_one(pos, now)
            except Exception as e:
                print(f"âŒ sell_engine error mint={mint}: {e}", flush=True)
                print(traceback.format_exc(), flush=True)

    def _handle_one(self, pos, now: float):
        mint = str(pos.get("mint") or "")
        entry = self._entry(pos)
        qty_total = self._ui_qty(pos)
        entry_ts = float(pos.get("entry_ts") or pos.get("opened_ts") or 0.0)

        price = float(self.price_feed.get_price(mint) or 0.0)
        if price <= 0:
            return

        if entry <= 0:
            entry = price
            try:
                self.db.update_position(mint, entry_price=entry, entry_price_usd=entry)
            except Exception:
                pass
            pos["entry_price"] = entry
            print(f"ðŸ§© BOOTSTRAP_ENTRY_FROM_PRICE mint={mint} entry={entry}", flush=True)

        pnl = (price - entry) / entry

        # high water
        hw = float(pos.get("high_water") or pos.get("highest_price") or entry)
        if price > hw:
            hw = price
            try:
                self.db.update_position(mint, high_water=hw, highest_price=hw)
            except Exception:
                pass

        tp1 = bool(pos.get("tp1_done"))
        tp2 = bool(pos.get("tp2_done"))

        print(
            "ðŸ“ˆ PRICE mint=%s entry=%s price=%s pnl=%.2f%% tp1=%s tp2=%s hw=%s"
            % (mint, entry, price, pnl * 100.0, int(tp1), int(tp2), hw),
            flush=True,
        )

        # HARD SL (sell ALL)
        if pnl <= self.HARD_SL_PCT:
            print(f"ðŸ”´ HARD_SL mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip HARD_SL sell", flush=True)
                return
            sell_qty = qty_total
            txsig = self._sell_exec(mint, sell_qty, "hard_sl")
            if not txsig:
                return
            print(f"âœ… SOLD HARD_SL txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="hard_sl")
            except Exception:
                pass
            return

        # TIME STOP (sell ALL)  (condition: age > TIME_STOP_SEC AND pnl < TIME_STOP_MIN_PNL)
        if entry_ts > 0 and (now - entry_ts) > self.TIME_STOP_SEC and pnl < self.TIME_STOP_MIN_PNL:
            print(f"â±ï¸ TIME_STOP mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TIME_STOP sell", flush=True)
                return
            sell_qty = qty_total
            txsig = self._sell_exec(mint, sell_qty, "time_stop")
            if not txsig:
                return
            print(f"âœ… SOLD TIME_STOP txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="time_stop")
            except Exception:
                pass
            return

        # TP1
        if (not tp1) and pnl >= self.TP1_PCT:
            sell_qty = qty_total * float(self.TP1_SIZE)
            if sell_qty <= 0:
                print(f"â­ï¸ TP1 SKIP qty<=0 mint={mint}", flush=True)
                return
            print(f"ðŸŸ¢ TP1 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TP1 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp1")
            if not txsig:
                return
            print(f"âœ… SOLD TP1 txsig={txsig}", flush=True)
            try:
                self.db.mark_tp1(mint)
            except Exception:
                pass
            return

        # TP2
        if tp1 and (not tp2) and pnl >= self.TP2_PCT:
            sell_qty = qty_total * float(self.TP2_SIZE)
            if sell_qty <= 0:
                print(f"â­ï¸ TP2 SKIP qty<=0 mint={mint}", flush=True)
                return
            print(f"ðŸŸ¢ TP2 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TP2 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp2")
            if not txsig:
                return
            print(f"âœ… SOLD TP2 txsig={txsig}", flush=True)
            try:
                self.db.mark_tp2(mint)
            except Exception:
                pass
            return

        # TRAIL (sell ALL)
        trail = self.TRAIL_WIDE if tp2 else self.TRAIL_TIGHT
        stop_price = hw * (1 - trail)
        if hw > 0 and price <= stop_price:
            print(f"ðŸŸ  TRAIL_STOP mint={mint} price={price} stop={stop_price} hw={hw}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TRAIL sell", flush=True)
                return
            sell_qty = qty_total
            txsig = self._sell_exec(mint, sell_qty, "trailing_stop")
            if not txsig:
                return
            print(f"âœ… SOLD TRAIL txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="trailing_stop")
            except Exception:
                pass
            return
