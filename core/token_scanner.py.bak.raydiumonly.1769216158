from __future__ import annotations

import asyncio
import os
import time
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

import httpx


@dataclass
class ScannerConfig:
    # DexScreener (free)
    dexscreener_base_url: str = "https://api.dexscreener.com"
    chain_id: str = "solana"

    # Loop config
    new_listing_limit: int = 5
    global_rps: float = 0.2
    max_concurrency: int = 1

    # Filters (applied in scanner)
    min_liquidity_usd: float = 1000.0
    max_market_cap_usd: float = 300000.0


class _RateLimiter:
    def __init__(self, rps: float) -> None:
        self.rps = max(0.01, float(rps))
        self._next = 0.0

    async def wait(self) -> None:
        now = time.time()
        if self._next > now:
            await asyncio.sleep(self._next - now)
        self._next = time.time() + (1.0 / self.rps)


class TokenScanner:
    """
    Scanner stable basé sur DexScreener (free):
      - discovery via /token-profiles/latest/v1  (liste des derniers tokens/pairs)
      - details via /latest/dex/tokens/{mint}
    On retourne une liste d'overviews (dict) compatibles avec ton TradingEngine.
    """

    def __init__(self, cfg: ScannerConfig) -> None:
        self.cfg = cfg
        self._rl = _RateLimiter(cfg.global_rps)
        self._client = httpx.AsyncClient(timeout=20.0, headers={"accept": "application/json"})

        # Petit semaphore pour éviter d'exploser le rate limit
        self._sem = asyncio.Semaphore(max(1, int(cfg.max_concurrency)))

    async def aclose(self) -> None:
        await self._client.aclose()

    def close(self) -> None:
        try:
            # fallback sync
            asyncio.get_event_loop().create_task(self.aclose())
        except Exception:
            pass

    async def _get_json(self, url: str) -> Any:
        async with self._sem:
            await self._rl.wait()
            r = await self._client.get(url)
            r.raise_for_status()
            return r.json()

    async def _latest_profiles(self) -> List[Dict[str, Any]]:
        # DexScreener: latest token profiles (v1)
        url = f"{self.cfg.dexscreener_base_url}/token-profiles/latest/v1"
        data = await self._get_json(url)
        if not isinstance(data, list):
            return []
        # filter chain
        out = [x for x in data if str(x.get("chainId", "")).lower() == self.cfg.chain_id]
        return out

    async def _overview_from_token(self, mint: str) -> Optional[Dict[str, Any]]:
        # DexScreener: token details / pairs
        url = f"{self.cfg.dexscreener_base_url}/latest/dex/tokens/{mint}"
        data = await self._get_json(url)
        pairs = data.get("pairs") if isinstance(data, dict) else None
        if not pairs or not isinstance(pairs, list):
            return None

        # pick best pair: highest liquidity USD
        best = None
        best_liq = -1.0
        for p in pairs:
            liq = (p.get("liquidity") or {}).get("usd")
            try:
                liq = float(liq) if liq is not None else 0.0
            except Exception:
                liq = 0.0
            if liq > best_liq:
                best_liq = liq
                best = p

        if not best:
            return None

        # Extract metrics
        base = best.get("baseToken") or {}
        symbol = base.get("symbol") or ""
        name = base.get("name") or ""
        price_usd = best.get("priceUsd")
        try:
            price_usd_f = float(price_usd) if price_usd is not None else 0.0
        except Exception:
            price_usd_f = 0.0

        liq_usd = best_liq

        # DexScreener uses fdv (fully diluted valuation) often; treat as "marketcap proxy"
        fdv = best.get("fdv")
        try:
            mcap = float(fdv) if fdv is not None else 0.0
        except Exception:
            mcap = 0.0

        # Apply filters here (so TradingEngine receives only candidates)
        if liq_usd < float(self.cfg.min_liquidity_usd):
            return None
        if mcap > 0 and mcap > float(self.cfg.max_market_cap_usd):
            return None

        # Build overview compatible-ish with your logs/engine
        ov: Dict[str, Any] = {
            "mint": mint,
            "token": mint,
            "symbol": symbol,
            "name": name,
            "price_usd": price_usd_f,
            "liquidity_usd": liq_usd,
            "marketcap_usd": mcap,
            "data": {"liquidity": liq_usd, "marketCap": mcap, "price": price_usd_f},
            "source": "dexscreener",
            "pair_address": best.get("pairAddress"),
            "dex_id": best.get("dexId"),
            "url": best.get("url"),
        }
        return ov

    async def scan_once_async(self) -> List[Dict[str, Any]]:
        try:
            profiles = await self._latest_profiles()
        except Exception as e:
            raise RuntimeError(f"DEXSCREENER_LATEST_ERROR: {e}")

        # Take latest N
        profiles = profiles[: int(self.cfg.new_listing_limit)]
        mints: List[str] = []
        for x in profiles:
            addr = x.get("tokenAddress") or x.get("address")
            if addr and isinstance(addr, str):
                mints.append(addr)

        # Dedup while preserving order
        seen = set()
        mints2 = []
        for m in mints:
            if m not in seen:
                seen.add(m)
                mints2.append(m)

        out: List[Dict[str, Any]] = []
        for mint in mints2:
            try:
                ov = await self._overview_from_token(mint)
                if ov:
                    out.append(ov)
            except Exception:
                # ignore per-token errors
                continue

        return out
