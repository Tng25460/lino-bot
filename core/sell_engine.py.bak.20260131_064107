import os
import time as _time
import subprocess
import traceback

class SellEngine:
    """
    Sell engine autonome (compatible DB actuelle):
    - lit qty_token (fallback qty)
    - utilise src/sell_exec.py pour ex√©cuter les SELL via Jupiter
    - TP1 / TP2 partiels + hard SL + time stop + trailing
    """

    def __init__(self, db, price_feed, trader=None):
        self.db = db
        self.price_feed = price_feed
        self.trader = trader  # ignored (compat)

        # Fractions (0.01 = 1%)
        self.TP1_PCT = float(os.getenv("SELL_TP1_PCT", "0.30"))
        self.TP1_SIZE = float(os.getenv("SELL_TP1_SIZE", "0.35"))
        self.TP2_PCT = float(os.getenv("SELL_TP2_PCT", "0.80"))
        self.TP2_SIZE = float(os.getenv("SELL_TP2_SIZE", "0.35"))

        self.HARD_SL_PCT = -abs(float(os.getenv("SELL_HARD_SL_PCT", "0.25")))  # e.g 0.25 => -0.25
        self.TRAIL_TIGHT = float(os.getenv("SELL_TRAIL_TIGHT", "0.10"))
        self.TRAIL_WIDE  = float(os.getenv("SELL_TRAIL_WIDE",  "0.20"))

        self.TIME_STOP_SEC = int(os.getenv("SELL_TIME_STOP_SEC", "900"))
        self.TIME_STOP_MIN_PNL = float(os.getenv("SELL_TIME_STOP_MIN_PNL", "0.05"))

    def _ui_qty(self, pos) -> float:
        try:
            return float(pos.get("qty_token") or pos.get("qty") or 0.0)
        except Exception:
            return 0.0

    def _entry(self, pos) -> float:
        try:
            return float(pos.get("entry_price") or pos.get("entry_price_usd") or 0.0)
        except Exception:
            return 0.0

    def _sell_exec(self, mint: str, ui_amount: float, reason: str) -> str:
        if ui_amount <= 0:
            # PATCH: no-crash when qty is 0 (skip)
            print(f"üßπ SELL_SKIP mint={mint} reason={reason} ui_amount={ui_amount}", flush=True)
            return ""
        cmd = ["python", "-u", "src/sell_exec.py", "--mint", mint, "--ui", str(ui_amount), "--reason", reason]
        print("üßæ SELL cmd=" + " ".join(cmd), flush=True)
        proc = subprocess.run(cmd, capture_output=True, text=True)

        out = (proc.stdout or "").strip()
        err = (proc.stderr or "").strip()
        if out:
            print("üì§ sell_exec stdout:\n" + out, flush=True)
        if err:
            print("üì• sell_exec stderr:\n" + err, flush=True)

        txsig = ""
        for line in (proc.stdout or "").splitlines():
            if line.startswith("txsig="):
                txsig = line.split("=", 1)[1].strip()

        if proc.returncode != 0:
            # ANTI_DUST_FROM_SELL_EXEC_V1
            stderr_txt = (proc.stderr or '').strip()
            if 'computed amount <= 0' in stderr_txt:
                print('‚ö†Ô∏è SELL_SKIP_DUST mint=', mint, 'ui=', ui_amount, 'reason=', reason, '-> CLOSE', flush=True)
                # ANTI_DUST_SQLITE_FALLBACK_V1
                try:
                    import sqlite3, os, time as _t
                    dbp = os.getenv('TRADES_DB_PATH', os.getenv('DB_PATH','state/trades.sqlite'))
                    con = sqlite3.connect(dbp, timeout=30)
                    cur = con.cursor()
                    cur.execute("""
                      UPDATE positions
                      SET status='CLOSED', close_reason='dust', close_ts=?
                      WHERE mint=? AND UPPER(status)='OPEN'
                    """, (int(_t.time()), mint))
                    con.commit(); con.close()
                except Exception:
                    pass
                return ''
            raise RuntimeError(f"sell_exec failed rc={proc.returncode} txsig={txsig}")

        return txsig or "NO_TXSIG"

    def run_once(self):
        _os = __import__("os")
        only_mint = (_os.getenv("SELL_ONLY_MINT","") or "").strip()
        if only_mint:
            print("üß™ SELL_ONLY_MINT=", only_mint, flush=True)

        # CFG_LOG_V3: log SELL_* env + key thresholds once
        try:
            if not getattr(self, "_cfg_logged", False):
                self._cfg_logged = True
                keys = sorted([k for k in _os.environ.keys() if k.startswith("SELL_")])
                snap = {k: _os.getenv(k) for k in keys}
                print("üßæ SELL_ENGINE_CFG " + " ".join([k+"="+str(snap.get(k)) for k in keys]), flush=True)
                want = ("hard","sl","tp","trail","time_stop")
                for name in sorted(dir(self)):
                    ln = name.lower()
                    if any(w in ln for w in want):
                        try:
                            v = getattr(self, name)
                            if isinstance(v, (int, float, str, bool)):
                                print("üßæ SELL_ENGINE_ATTR " + name + "=" + str(v), flush=True)
                        except Exception:
                            pass
        except Exception as _e:
            print("‚ö†Ô∏è cfg log failed " + str(_e), flush=True)

        now = _time.time()
        positions = self.db.get_open_positions() or []
        print(f"üí∞ sell_engine: open_positions={len(positions)}", flush=True)
        for pos in positions:
            mint = str(pos.get("mint") or "")
            # SELL_ONLY_MINT filter
            if only_mint and mint != only_mint:
                continue
            if not mint:
                continue
            try:
                self._handle_one(pos, now)
            except Exception as e:
                print(f"‚ùå sell_engine error mint={mint}: {e}", flush=True)
                print(traceback.format_exc(), flush=True)

    def _handle_one(self, pos, now: float):
        mint = str(pos.get("mint"))
        entry = self._entry(pos)
        qty = self._ui_qty(pos)
        entry_ts = float(pos.get("entry_ts") or pos.get("opened_ts") or 0.0)

        price = float(self.price_feed.get_price(mint) or 0.0)
        if price <= 0:
            return

        if entry <= 0:
            # bootstrap minimal: set entry=price so pnl=0
            entry = price
            try:
                self.db.update_position(mint, entry_price=entry, entry_price_usd=entry)
            except Exception:
                pass
            pos["entry_price"] = entry
            print(f"üß© BOOTSTRAP_ENTRY_FROM_PRICE mint={mint} entry={entry}", flush=True)

        pnl = (price - entry) / entry

        # high water
        hw = float(pos.get("high_water") or pos.get("highest_price") or entry)
        if price > hw:
            hw = price
            try:
                self.db.update_position(mint, high_water=hw, highest_price=hw)
            except Exception:
                pass

        tp1 = bool(pos.get("tp1_done"))
        tp2 = bool(pos.get("tp2_done"))

        print("üìà PRICE mint=%s entry=%s price=%s pnl=%.2f%% tp1=%s tp2=%s hw=%s" %
              (mint, entry, price, pnl*100.0, int(tp1), int(tp2), hw), flush=True)

        # HARD SL
        if pnl <= self.HARD_SL_PCT:
            print(f"üî¥ HARD_SL mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip HARD_SL sell", flush=True)
                return
            txsig = self._sell_exec(mint, qty, "hard_sl")
            sell_qty = qty
            if not txsig:
                return
# TIME STOP
        if entry_ts > 0 and (now - entry_ts) > self.TIME_STOP_SEC and pnl < self.TIME_STOP_MIN_PNL:
            print(f"‚è±Ô∏è TIME_STOP mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TIME_STOP sell", flush=True)
                return
            txsig = self._sell_exec(mint, qty, "time_stop")
            sell_qty = qty
            if not txsig:
                return
# TP1
        if (not tp1) and pnl >= self.TP1_PCT:
            sell_qty = qty * float(self.TP1_SIZE)
            # --- qty guard: DB may have 0 -> resync on-chain and recompute ---
            try:
                if float(qty) <= 0:
                    qty_on = self._onchain_ui_balance_stable(mint)
                    if qty_on and float(qty_on) > 0:
                        qty_token = float(qty_on)
                        pos['qty_token'] = qty_token
                        try:
                            self._sync_qty_db(mint, qty_token)
                            print(f"üß© RESYNC_QTY_DB mint={mint} qty_token={qty_token}", flush=True)
                        except Exception as _e2:
                            print(f"‚ö†Ô∏è RESYNC_QTY_DB sync fail mint={mint} err={_e2}", flush=True)
                        qty = qty_token * float(getattr(self, 'TP1_SIZE'))
                if float(qty) <= 0:
                    print(f"‚è≠Ô∏è TP1 SKIP qty<=0 mint={mint}", flush=True)
                    return
            except Exception as _e:
                print(f"‚ö†Ô∏è TP1 qty-guard error mint={mint} err={_e}", flush=True)
                return
            # --- end qty guard ---
            print(f"üü¢ TP1 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TP1 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp1")
            if not txsig:
                return
# TP2
        if tp1 and (not tp2) and pnl >= self.TP2_PCT:
            sell_qty = qty * float(self.TP2_SIZE)
            # --- qty guard: DB may have 0 -> resync on-chain and recompute ---
            try:
                if float(qty) <= 0:
                    qty_on = self._onchain_ui_balance_stable(mint)
                    if qty_on and float(qty_on) > 0:
                        qty_token = float(qty_on)
                        pos['qty_token'] = qty_token
                        try:
                            self._sync_qty_db(mint, qty_token)
                            print(f"üß© RESYNC_QTY_DB mint={mint} qty_token={qty_token}", flush=True)
                        except Exception as _e2:
                            print(f"‚ö†Ô∏è RESYNC_QTY_DB sync fail mint={mint} err={_e2}", flush=True)
                        qty = qty_token * float(getattr(self, 'TP2_SIZE'))
                if float(qty) <= 0:
                    print(f"‚è≠Ô∏è TP2 SKIP qty<=0 mint={mint}", flush=True)
                    return
            except Exception as _e:
                print(f"‚ö†Ô∏è TP2 qty-guard error mint={mint} err={_e}", flush=True)
                return
            # --- end qty guard ---
            print(f"üü¢ TP2 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TP2 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp2")
            if not txsig:
                return
# TRAIL
        trail = self.TRAIL_WIDE if tp2 else self.TRAIL_TIGHT
        stop_price = hw * (1 - trail)
        if price <= stop_price and hw > 0:
            print(f"üü† TRAIL_STOP mint={mint} price={price} stop={stop_price} hw={hw}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip TRAIL sell", flush=True)
                return
            txsig = self._sell_exec(mint, qty, "trailing_stop")
            sell_qty = qty
            if not txsig:
                return
# ANTI_DUST_CLOSE_V2
# ANTI_DUST_FROM_SELL_EXEC_V1

# ANTI_DUST_SQLITE_FALLBACK_V1

# NO_SOLD_WHEN_EMPTY_TXSIG_V1
