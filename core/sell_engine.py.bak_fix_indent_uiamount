import os
import time as _time
import subprocess
import traceback

class SellEngine:
    """
    Sell engine autonome (compatible DB actuelle):
    - lit qty_token (fallback qty)
    - utilise src/sell_exec.py pour exÃ©cuter les SELL via Jupiter
    - TP1 / TP2 partiels + hard SL + time stop + trailing
    """

    def __init__(self, db, price_feed, trader=None):
        self.db = db
        self.price_feed = price_feed
        self.trader = trader  # ignored (compat)

        # Fractions (0.01 = 1%)
        self.TP1_PCT = float(os.getenv("SELL_TP1_PCT", "0.30"))
        self.TP1_SIZE = float(os.getenv("SELL_TP1_SIZE", "0.35"))
        self.TP2_PCT = float(os.getenv("SELL_TP2_PCT", "0.80"))
        self.TP2_SIZE = float(os.getenv("SELL_TP2_SIZE", "0.35"))

        self.HARD_SL_PCT = -abs(float(os.getenv("SELL_HARD_SL_PCT", "0.25")))  # e.g 0.25 => -0.25
        self.TRAIL_TIGHT = float(os.getenv("SELL_TRAIL_TIGHT", "0.10"))
        self.TRAIL_WIDE  = float(os.getenv("SELL_TRAIL_WIDE",  "0.20"))

        self.TIME_STOP_SEC = int(os.getenv("SELL_TIME_STOP_SEC", "900"))
        self.TIME_STOP_MIN_PNL = float(os.getenv("SELL_TIME_STOP_MIN_PNL", "0.05"))

    def _ui_qty(self, pos) -> float:
        try:
            return float(pos.get("qty_token") or pos.get("qty") or 0.0)
        except Exception:
            return 0.0

    def _entry(self, pos) -> float:
        try:
            return float(pos.get("entry_price") or pos.get("entry_price_usd") or 0.0)
        except Exception:
            return 0.0

    def _sell_exec(self, mint: str, ui_amount: float, reason: str) -> str:
        if ui_amount <= 0:
            
# ui_amount can be 0 if DB qty is stale; resync on-chain before failing
try:
    if ui_amount is None or float(ui_amount) <= 0:
        try:
            ui_amount = float(self._onchain_ui_balance_stable(mint))
        except Exception:
            try:
                ui_amount = float(self._onchain_ui_balance(mint))
            except Exception:
                ui_amount = 0.0
except Exception:
    ui_amount = 0.0

if float(ui_amount) <= 0:
    print(f"âš ï¸ sell_engine: skip SELL mint={mint} ui_amount<=0 (no crash)", flush=True)
    return ""

        cmd = ["python", "-u", "src/sell_exec.py", "--mint", mint, "--ui", str(ui_amount), "--reason", reason]
        print("ðŸ§¾ SELL cmd=" + " ".join(cmd), flush=True)
        proc = subprocess.run(cmd, capture_output=True, text=True)

        out = (proc.stdout or "").strip()
        err = (proc.stderr or "").strip()
        if out:
            print("ðŸ“¤ sell_exec stdout:\n" + out, flush=True)
        if err:
            print("ðŸ“¥ sell_exec stderr:\n" + err, flush=True)

        txsig = ""
        for line in (proc.stdout or "").splitlines():
            if line.startswith("txsig="):
                txsig = line.split("=", 1)[1].strip()

        if proc.returncode != 0:
            raise RuntimeError(f"sell_exec failed rc={proc.returncode} txsig={txsig}")

        return txsig or "NO_TXSIG"

    def run_once(self):
        now = _time.time()
        positions = self.db.get_open_positions() or []
        print(f"ðŸ’° sell_engine: open_positions={len(positions)}", flush=True)
        for pos in positions:
            mint = str(pos.get("mint") or "")
            if not mint:
                continue
            try:
                self._handle_one(pos, now)
            except Exception as e:
                print(f"âŒ sell_engine error mint={mint}: {e}", flush=True)
                print(traceback.format_exc(), flush=True)

    def _handle_one(self, pos, now: float):
        mint = str(pos.get("mint"))
        entry = self._entry(pos)
        qty = self._ui_qty(pos)
        entry_ts = float(pos.get("entry_ts") or pos.get("opened_ts") or 0.0)

        price = float(self.price_feed.get_price(mint) or 0.0)
        if price <= 0:
            return

        if entry <= 0:
            # bootstrap minimal: set entry=price so pnl=0
            entry = price
            try:
                self.db.update_position(mint, entry_price=entry, entry_price_usd=entry)
            except Exception:
                pass
            pos["entry_price"] = entry
            print(f"ðŸ§© BOOTSTRAP_ENTRY_FROM_PRICE mint={mint} entry={entry}", flush=True)

        pnl = (price - entry) / entry

        # high water
        hw = float(pos.get("high_water") or pos.get("highest_price") or entry)
        if price > hw:
            hw = price
            try:
                self.db.update_position(mint, high_water=hw, highest_price=hw)
            except Exception:
                pass

        tp1 = bool(pos.get("tp1_done"))
        tp2 = bool(pos.get("tp2_done"))

        print("ðŸ“ˆ PRICE mint=%s entry=%s price=%s pnl=%.2f%% tp1=%s tp2=%s hw=%s" %
              (mint, entry, price, pnl*100.0, int(tp1), int(tp2), hw), flush=True)

        # HARD SL
        if pnl <= self.HARD_SL_PCT:
            print(f"ðŸ”´ HARD_SL mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip HARD_SL sell", flush=True)
                return
            txsig = self._sell_exec(mint, qty, "hard_sl")
            print(f"âœ… SOLD HARD_SL txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="hard_sl")
            except Exception:
                pass
            return

        # TIME STOP
        if entry_ts > 0 and (now - entry_ts) > self.TIME_STOP_SEC and pnl < self.TIME_STOP_MIN_PNL:
            print(f"â±ï¸ TIME_STOP mint={mint} pnl={pnl:.2%}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TIME_STOP sell", flush=True)
                return
            txsig = self._sell_exec(mint, qty, "time_stop")
            print(f"âœ… SOLD TIME_STOP txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="time_stop")
            except Exception:
                pass
            return

        # TP1
        if (not tp1) and pnl >= self.TP1_PCT:
            sell_qty = qty * float(self.TP1_SIZE)
            print(f"ðŸŸ¢ TP1 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TP1 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp1")
            print(f"âœ… SOLD TP1 txsig={txsig}", flush=True)
            try:
                self.db.mark_tp1(mint)
            except Exception:
                pass
            return

        # TP2
        if tp1 and (not tp2) and pnl >= self.TP2_PCT:
            sell_qty = qty * float(self.TP2_SIZE)
            print(f"ðŸŸ¢ TP2 mint={mint} qty={sell_qty}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TP2 sell", flush=True)
                return
            txsig = self._sell_exec(mint, sell_qty, "tp2")
            print(f"âœ… SOLD TP2 txsig={txsig}", flush=True)
            try:
                self.db.mark_tp2(mint)
            except Exception:
                pass
            return

        # TRAIL
        trail = self.TRAIL_WIDE if tp2 else self.TRAIL_TIGHT
        stop_price = hw * (1 - trail)
        if price <= stop_price and hw > 0:
            print(f"ðŸŸ  TRAIL_STOP mint={mint} price={price} stop={stop_price} hw={hw}", flush=True)
            if os.getenv("SELL_DRY_RUN", "0") == "1":
                print("ðŸ§ª SELL_DRY_RUN=1 -> skip TRAIL sell", flush=True)
                return
            txsig = self._sell_exec(mint, qty, "trailing_stop")
            print(f"âœ… SOLD TRAIL txsig={txsig}", flush=True)
            try:
                self.db.close_position(mint, reason="trailing_stop")
            except Exception:
                pass
            return
