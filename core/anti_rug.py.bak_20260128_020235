from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

from core.solana_rpc_async import SolanaRPCAsync, TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID


@dataclass
class AntiRugResult:
    ok: bool
    reason: str
    details: Dict[str, Any]


class AntiRug:
    """
    On-chain safety checks (fast + strict by default):
      - token program must be SPL-Token (or Token-2022 if allowed)
      - mintAuthority / freezeAuthority must be None if require_renounced
      - holder concentration (top1 / top10) via getTokenLargestAccounts
    """

    def __init__(self, rpc: SolanaRPCAsync, logger: Any = None, *, block_token_2022: bool = True) -> None:
        self.rpc = rpc
        self.logger = logger
        self.block_token_2022 = bool(block_token_2022)

    def _log(self, level: str, msg: str) -> None:
        try:
            if self.logger:
                getattr(self.logger, level)(msg)
        except Exception:
            pass

    @staticmethod
    def _safe_float(x: Any, default: float = 0.0) -> float:
        try:
            if x is None:
                return default
            return float(x)
        except Exception:
            return default

    async def _get_mint_auths(self, mint: str) -> Tuple[Optional[str], Optional[str], Dict[str, Any]]:
        """
        Returns (mintAuthority, freezeAuthority, details)
        """
        details: Dict[str, Any] = {}
        val = await self.rpc.get_account_info(mint, encoding="jsonParsed")
        if not val:
            return None, None, {"error": "account_not_found"}

        owner = (val.get("owner") or "").strip()
        details["program_owner"] = owner

        # SPL token mint should have parsed data
        data = val.get("data") or {}
        parsed = (data.get("parsed") or {}) if isinstance(data, dict) else {}
        info = (parsed.get("info") or {}) if isinstance(parsed, dict) else {}

        mint_auth = info.get("mintAuthority")
        freeze_auth = info.get("freezeAuthority")
        details["mintAuthority"] = mint_auth
        details["freezeAuthority"] = freeze_auth
        details["decimals"] = info.get("decimals")

        return mint_auth, freeze_auth, details

    async def check(
        self,
        mint: str,
        *,
        max_top1: float = 0.25,
        max_top10: float = 0.60,
        require_renounced: bool = True,
        allow_token_2022: bool = False,
    ) -> AntiRugResult:
        details: Dict[str, Any] = {}

        # owner program
        val = await self.rpc.get_account_info(mint, encoding="jsonParsed")
        if not val:
            return AntiRugResult(False, "mint introuvable (RPC)", {"program_owner": None})

        owner = (val.get("owner") or "").strip()
        details["program_owner"] = owner

        if owner == TOKEN_2022_PROGRAM_ID:
            if self.block_token_2022 and not allow_token_2022:
                return AntiRugResult(False, "Token-2022 bloqué (risque fees/extensions)", details)
        elif owner != TOKEN_PROGRAM_ID:
            return AntiRugResult(False, f"programme token inconnu: {owner}", details)

        # auth renounced
        mint_auth, freeze_auth, auth_details = await self._get_mint_auths(mint)
        details.update(auth_details)

        if require_renounced:
            if mint_auth:
                return AntiRugResult(False, "mint authority active (remint possible)", details)
            if freeze_auth:
                return AntiRugResult(False, "freeze authority active (gel possible)", details)

        # holder concentration
        try:
            largest = await self.rpc.get_token_largest_accounts(mint)
            vals = largest.get("value") or []
            ui_amounts = []
            for a in vals:
                if not isinstance(a, dict):
                    continue
                ui = a.get("uiAmount")
                if ui is None:
                    ui = a.get("uiAmountString")
                ui_amounts.append(self._safe_float(ui, 0.0))

            total_supply = sum(ui_amounts) if ui_amounts else 0.0
            details["largest_count"] = len(ui_amounts)
            details["largest_sum_ui"] = total_supply

            if total_supply > 0 and ui_amounts:
                top1 = ui_amounts[0] / total_supply
                top10 = sum(ui_amounts[:10]) / total_supply
                details["top1_pct"] = top1
                details["top10_pct"] = top10

                if top1 > max_top1:
                    return AntiRugResult(False, f"top1 trop concentré ({top1:.1%})", details)
                if top10 > max_top10:
                    return AntiRugResult(False, f"top10 trop concentré ({top10:.1%})", details)
        except Exception as e:
            details["holders_exc"] = repr(e)
            return AntiRugResult(False, f"holders check fail: {e}", details)

        return AntiRugResult(True, "ok", details)
