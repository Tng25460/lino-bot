import asyncio
import time
import logging
from dataclasses import dataclass, field
from typing import Any, Dict, List, Tuple

import aiohttp


# -----------------------
# Public config object (compat src/main.py import)
# -----------------------
@dataclass
class ScannerConfig:
    # compat names already used in your project
    global_rps: float = 2.0
    max_concurrency: int = 2
    scan_limit: int = 30

    # scope
    SCANNER_CHAIN: str = "solana"
    SCANNER_DEXES: List[str] = field(default_factory=lambda: ["raydium", "pumpfun"])
    SCANNER_QUERIES: List[str] = field(default_factory=lambda: ["pump", "raydium", "bonk", "wif", "sol"])

    # quality filters (m5)
    MIN_LIQUIDITY_USD: float = 5000
    MIN_VOLUME_M5_USD: float = 2000
    MIN_TXNS_M5: int = 20
    MIN_MARKETCAP_USD: float = 20000


# -----------------------
# Logging (safe)
# -----------------------
try:
    from core.logger import get_logger  # type: ignore
    log = get_logger("Scanner")
except Exception:
    log = logging.getLogger("Scanner")
    if not log.handlers:
        logging.basicConfig(level=logging.INFO)


# -----------------------
# Helpers
# -----------------------
DEFAULT_HEADERS = {
    "Accept": "application/json",
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) LinoBot/1.0",
}

DEX_SEARCH_URL = "https://api.dexscreener.com/latest/dex/search/?q={q}"


def _cfg_get(cfg, *names, default=None):
    """Retourne cfg.<name> pour le 1er name existant, sinon default."""
    for n in names:
        if hasattr(cfg, n):
            return getattr(cfg, n)
    return default


def _safe_float(x, default=0.0) -> float:
    try:
        if x is None:
            return float(default)
        return float(x)
    except Exception:
        return float(default)


def _safe_int(x, default=0) -> int:
    try:
        if x is None:
            return int(default)
        return int(x)
    except Exception:
        return int(default)


def _m5_txns(pair: Dict[str, Any]) -> int:
    tx = (pair.get("txns") or {}).get("m5") or {}
    return _safe_int(tx.get("buys"), 0) + _safe_int(tx.get("sells"), 0)


def _m5_volume(pair: Dict[str, Any]) -> float:
    vol = (pair.get("volume") or {}).get("m5")
    return _safe_float(vol, 0.0)


def _liq_usd(pair: Dict[str, Any]) -> float:
    liq = (pair.get("liquidity") or {}).get("usd")
    return _safe_float(liq, 0.0)


def _mc_or_fdv(pair: Dict[str, Any]) -> float:
    mc = pair.get("marketCap")
    if mc is None:
        mc = pair.get("fdv")
    return _safe_float(mc, 0.0)


# -----------------------
# Rate limiter (simple)
# -----------------------
class _RateLimiter:
    def __init__(self, rps: float):
        self.rps = max(0.1, float(rps))
        self.min_delay = 1.0 / self.rps
        self._lock = asyncio.Lock()
        self._last = 0.0

    async def wait(self):
        async with self._lock:
            now = time.time()
            dt = now - self._last
            if dt < self.min_delay:
                await asyncio.sleep(self.min_delay - dt)
            self._last = time.time()


# -----------------------
# TokenScanner (DexScreener)
# -----------------------
class TokenScanner:
    """
    Scanner DexScreener:
    - Cherche via /search?q=...
    - Filtre chainId/dexId
    - Filtre qualité: liquidité, volume m5, txns m5, marketcap/fdv
    - Retourne une liste de "pairs" DexScreener (dict)
    """

    def __init__(self, cfg):
        # cfg peut être: config.settings (module) OU ScannerConfig()
        self.cfg = cfg

        self.limit = int(_cfg_get(cfg, "scan_limit", "SCAN_LIMIT", default=30))
        self.rps = float(_cfg_get(cfg, "global_rps", "scanner_rps", "RPS", default=2.0))
        self.conc = int(_cfg_get(cfg, "max_concurrency", "MAX_CONCURRENCY", default=2))

        # qualité
        self.min_liq = float(_cfg_get(cfg, "MIN_LIQUIDITY_USD", default=5000))
        self.min_vol_m5 = float(_cfg_get(cfg, "MIN_VOLUME_M5_USD", default=2000))
        self.min_txns_m5 = int(_cfg_get(cfg, "MIN_TXNS_M5", default=20))
        self.min_mc = float(_cfg_get(cfg, "MIN_MARKETCAP_USD", default=20000))

        # scope
        self.chain = str(_cfg_get(cfg, "SCANNER_CHAIN", default="solana")).lower()
        self.dexes = [str(x).lower() for x in (_cfg_get(cfg, "SCANNER_DEXES", default=["raydium", "pumpfun"]) or [])]
        self.queries = [str(x) for x in (_cfg_get(cfg, "SCANNER_QUERIES", default=["pump", "raydium", "bonk", "wif", "sol"]) or [])]

        self._rl = _RateLimiter(self.rps)
        self._sem = asyncio.Semaphore(max(1, self.conc))

        log.info(f"[Scanner] ✅ limit={self.limit} rps={self.rps} conc={self.conc}")

    # ---- Public API (compat) ----
    async def get_overviews(self) -> List[Dict[str, Any]]:
        return await self.scan_overviews()

    async def fetch_overviews(self) -> List[Dict[str, Any]]:
        return await self.scan_overviews()

    async def scan_overviews(self) -> List[Dict[str, Any]]:
        pairs = await self._search_many(self.queries)

        if not pairs:
            log.info("[DBG_OV] []")
            return []

        kept: List[Tuple[float, Dict[str, Any]]] = []
        for p in pairs:
            if not self._pass_basic_filters(p):
                continue
            kept.append((self._score(p), p))

        kept.sort(key=lambda t: t[0], reverse=True)
        out = [p for _, p in kept[: self.limit]]

        if not out:
            log.info("[DBG_OV] []")
        else:
            sample = []
            for x in out[:3]:
                sample.append({
                    "dexId": x.get("dexId"),
                    "pair": x.get("pairAddress"),
                    "liq": _liq_usd(x),
                    "vol_m5": _m5_volume(x),
                    "txns_m5": _m5_txns(x),
                    "mc": _mc_or_fdv(x),
                    "url": x.get("url"),
                })
            log.info(f"[DBG_OV] top={sample}")

        return out

    # ---- Internal ----
    def _pass_basic_filters(self, p: Dict[str, Any]) -> bool:
        if str(p.get("chainId", "")).lower() != self.chain:
            return False

        dex = str(p.get("dexId", "")).lower()
        if self.dexes and dex not in self.dexes:
            return False

        liq = _liq_usd(p)
        vol = _m5_volume(p)
        txm5 = _m5_txns(p)
        mc = _mc_or_fdv(p)

        if liq < self.min_liq:
            return False
        if vol < self.min_vol_m5:
            return False
        if txm5 < self.min_txns_m5:
            return False
        if mc > 0 and mc < self.min_mc:
            return False

        price_usd = _safe_float(p.get("priceUsd"), 0.0)
        if price_usd <= 0:
            return False

        return True

    def _score(self, p: Dict[str, Any]) -> float:
        txm5 = _m5_txns(p)
        vol = _m5_volume(p)
        liq = _liq_usd(p)

        s_tx = min(100.0, txm5 * 2.0)       # 50 txns => 100
        s_vol = min(100.0, vol / 200.0)     # 20k => 100
        s_liq = min(100.0, liq / 500.0)     # 50k => 100

        pc = (p.get("priceChange") or {}).get("m5")
        pc = _safe_float(pc, 0.0)
        s_pc = min(20.0, max(-20.0, pc))

        return (0.45 * s_tx) + (0.35 * s_vol) + (0.20 * s_liq) + (0.10 * s_pc)

    async def _search_many(self, queries: List[str]) -> List[Dict[str, Any]]:
        seen = set()
        out: List[Dict[str, Any]] = []

        timeout = aiohttp.ClientTimeout(total=15)
        async with aiohttp.ClientSession(timeout=timeout, headers=DEFAULT_HEADERS) as sess:
            tasks = [self._search_one(sess, q) for q in queries]
            results = await asyncio.gather(*tasks, return_exceptions=True)

        for r in results:
            if isinstance(r, Exception) or not r:
                continue
            for p in r:
                addr = p.get("pairAddress")
                if not addr or addr in seen:
                    continue
                seen.add(addr)
                out.append(p)

        return out

    async def _search_one(self, sess: aiohttp.ClientSession, q: str) -> List[Dict[str, Any]]:
        url = DEX_SEARCH_URL.format(q=q)
        async with self._sem:
            await self._rl.wait()
            try:
                async with sess.get(url) as resp:
                    if resp.status != 200:
                        log.info(f"[DBG_DEX_HTTP] q={q} status={resp.status}")
                        return []
                    data = await resp.json(content_type=None)
            except Exception as e:
                log.info(f"[DBG_DEX_ERR] q={q} err={e}")
                return []

        pairs = data.get("pairs") or []
        if not pairs:
            log.info(f"[DBG_DEX_EMPTY] q={q} -> []")
            return []
        return pairs
