import traceback
import os
import json
import requests
from solders.keypair import Keypair
import subprocess
import time as _time
from typing import Dict

class SellEngine:

    def _onchain_ui_balance(self, mint: str) -> float:
        """Return on-chain uiAmount total for mint for our owner."""
        rpc = os.getenv("SOLANA_RPC", "https://api.mainnet-beta.solana.com")
        keypath = os.getenv("KEYPAIR_PATH", "keypair.json")
        try:
            secret = json.load(open(keypath, "r", encoding="utf-8"))
            kp = Keypair.from_bytes(bytes(secret))
            owner = str(kp.pubkey())
        except Exception as e:
            print(f"‚ùå onchain_ui_balance: keypair load failed err={e}", flush=True)
            return 0.0

        payload = {"jsonrpc":"2.0","id":1,"method":"getTokenAccountsByOwner",
                   "params":[owner, {"mint": mint}, {"encoding":"jsonParsed"}]}
        try:
            j = requests.post(rpc, json=payload, timeout=25).json()
        except Exception as e:
            print(f"‚ùå onchain_ui_balance: rpc call failed err={e}", flush=True)
            return 0.0

        total = 0.0
        for a in j.get("result",{}).get("value",[]):
            try:
                ui = a["account"]["data"]["parsed"]["info"]["tokenAmount"]["uiAmount"] or 0
                total += float(ui)
            except Exception:
                pass
        return float(total)


    """
    Sell Engine simple et robuste
    - TP partiel
    - Trailing stop
    - Hard stop
    """

    def __init__(self, db, price_feed):
        self.db = db
        self.price_feed = price_feed

        # Config (env)
        self.TP1_PCT = float(os.getenv("SELL_TP1_PCT", "0.30"))      # +30%
        self.TP1_SIZE = float(os.getenv("SELL_TP1_SIZE", "0.50"))   # 50%
        self.TP2_PCT = float(os.getenv("SELL_TP2_PCT", "1.00"))     # +100%
        self.TP2_SIZE = float(os.getenv("SELL_TP2_SIZE", "0.25"))   # 25%

        self.HARD_SL_PCT = -abs(float(os.getenv("SELL_HARD_SL_PCT", "0.25")))  # loss, e.g. 0.25 => -0.25
        self.TRAIL_TIGHT = float(os.getenv("SELL_TRAIL_TIGHT", "0.10"))  # 10%
        self.TRAIL_WIDE  = float(os.getenv("SELL_TRAIL_WIDE",  "0.20"))  # 20%

        self.TIME_STOP_SEC = int(os.getenv("SELL_TIME_STOP_SEC", "1800"))  # 30 min
        self.TIME_STOP_MIN_PNL = float(os.getenv("SELL_TIME_STOP_MIN_PNL", "0.05"))
    def _sell_ui_via_exec(self, mint: str, ui_amount: float, reason: str) -> str:
        """Execute SELL via Jupiter by calling src/sell_exec.py.
        Logs stdout/stderr and returns txsig string (or DRY_RUN_NO_TX_SENT).
        """
        if ui_amount <= 0:
            raise ValueError("ui_amount must be > 0")

        cmd = ["python","-u","src/sell_exec.py","--mint",mint,"--ui",str(ui_amount),"--reason",reason]
        print("üßæ SELL cmd=" + " ".join(cmd), flush=True)

        proc = subprocess.run(cmd, capture_output=True, text=True)
        out = (proc.stdout or "").strip()
        err = (proc.stderr or "").strip()

        if out:
            print("üì§ sell_exec stdout:\n" + out, flush=True)
        if err:
            print("üì• sell_exec stderr:\n" + err, flush=True)

        # parse txsig from stdout
        txsig = ""
        for line in (proc.stdout or "").splitlines():
            if line.startswith("txsig="):
                txsig = line.split("=",1)[1].strip()

        if proc.returncode != 0:
            raise RuntimeError(f"sell_exec failed rc={proc.returncode} txsig={txsig}")

        if not txsig:
            raise RuntimeError("sell_exec returned success but no txsig=... found")

        return txsig


    def run_once(self):
        now = _time.time()
        positions = self.db.get_open_positions()
        print(f"üí∞ sell_engine: open_positions={len(positions)}", flush=True)
        if not positions:
            print("üí§ sell_engine: no open positions -> skip", flush=True)
            return

        for pos in positions:
            try:
                self._handle_position(pos, now)
            except Exception as e:
                print(f"‚ùå sell_engine error mint={pos.get('mint')}: {e}")
                print(traceback.format_exc(), flush=True)


    def _handle_position(self, pos: Dict, now: float):
        mint = pos["mint"]
        # === BOOTSTRAP_ENTRY_PRICE_USD_VIA_GET_PRICE (avoid div0) ===
        try:
            _entry = float((pos.get("entry_price_usd") or pos.get("entry_price") or 0) or 0)
        except Exception:
            _entry = 0.0
        if _entry <= 0.0:
            _p = 0.0
            try:
                pf = getattr(self, "price_feed", None)
                if pf is not None and hasattr(pf, "get_price"):
                    _p = float(pf.get_price(mint) or 0.0)
            except Exception:
                _p = 0.0
            if _p > 0.0:
                try:
                    self.db.update_position(mint, entry_price_usd=_p, entry_price=_p)
                except Exception:
                    pass
                # force local vars (si utilis√©s plus bas)
                try: entry_price_usd = _p
                except Exception: pass
                try: entry_price = _p
                except Exception: pass
                print(f"üß© BOOTSTRAP_ENTRY_PRICE_USD mint={mint} entry_price_usd={_p}", flush=True)
            else:
                print(f"‚ö†Ô∏è BOOTSTRAP_ENTRY_PRICE_USD failed mint={mint} (get_price=0)", flush=True)
        # === end BOOTSTRAP_ENTRY_PRICE_USD_VIA_GET_PRICE ===

        entry = float(pos["entry_price"])
        size = float(pos.get("qty_token") or pos.get("qty") or 0.0)
        entry_ts = float(pos["entry_ts"])

        price = self.price_feed.get_price(mint)
        if not price or price <= 0:
            return

        # --- SAFE pnl (no div0) ---

        if float(entry or 0.0) <= 0.0:

            print(f"üßØ SKIP pnl div0 mint={mint} entry={entry} price={price}", flush=True)

            return

        # --- SAFE pnl (no div0) ---

        if float(entry or 0.0) <= 0.0:

            print(f"üßØ SKIP pnl div0 mint={mint} entry={entry} price={price}", flush=True)

            return

        # --- BOOTSTRAP qty/entry from on-chain if DB has zeros ---

        # --- SAFE PnL calc (after bootstrap) ---

        if entry <= 0:

            print(f"üßØ SKIP pnl div0 mint={mint} entry={entry} price={price}", flush=True)

            return

        pnl = (price - entry) / entry

        print("üìà PRICE mint=%s entry=%s price=%s pnl=%.2f%% tp1=%s tp2=%s hw=%s" % (mint, entry, price, pnl*100.0, pos.get("tp1_done"), pos.get("tp2_done"), pos.get("high_water")), flush=True)

        highest = float(pos.get("high_water") or entry)
        if price > highest:
            highest = price
            self.db.update_position(mint, high_water=highest)

        # --- HARD STOP ---
        if pnl <= self.HARD_SL_PCT:
            print(f"üî¥ HARD SL mint={mint} pnl={pnl:.2%}", flush=True)
            try:
                txsig = self._sell_ui_via_exec(mint, float(pos.get("qty_token") or 0.0), "hard_sl")
                print(f"‚úÖ SELL HARD_SL txsig={txsig}", flush=True)
                self.db.close_position(mint, reason="hard_sl")
                return
            except Exception as e:
                print(f"‚ùå SELL HARD_SL failed mint={mint} err={e}", flush=True)
                return

        # --- TIME STOP ---
        if True:  # allow TIME STOP even after TP1
            if now - entry_ts > self.TIME_STOP_SEC and pnl < self.TIME_STOP_MIN_PNL:
                print(f"‚è±Ô∏è TIME STOP mint={mint} pnl={pnl:.2%}", flush=True)
                # sell remaining fraction based on TP flags
                rem_frac = 1.0
                if pos.get('tp1_done'):
                    rem_frac -= float(self.TP1_SIZE)
                if pos.get('tp2_done'):
                    rem_frac -= float(self.TP2_SIZE)
                if rem_frac < 0:
                    rem_frac = 0.0
                ui_sell = float(size) * rem_frac
                try:
                    txsig = self._sell_ui_via_exec(mint, ui_sell, reason='time_stop')
                    print(f"‚úÖ TIME_STOP sell txsig={txsig}", flush=True)
                except Exception as e:
                    print(f"‚ùå TIME_STOP sell error: {e}", flush=True)
                    return
                if os.getenv("SELL_DRY_RUN","0") == "1":
                    print("üß™ SELL_DRY_RUN=1 -> skip close_position on TIME STOP", flush=True)
                    return
                self.db.close_position(mint, reason="time_stop")
                return
        if not pos["tp1_done"] and pnl >= self.TP1_PCT:
            qty = size * self.TP1_SIZE
            print(f"üü¢ TP1 mint={mint} qty={qty:.4f}")
            self.db.mark_tp1(mint)
            return

        # --- TP2 ---
        if pos["tp1_done"] and not pos["tp2_done"] and pnl >= self.TP2_PCT:
            qty = size * self.TP2_SIZE
            print(f"üü¢ TP2 mint={mint} qty={qty:.4f}")
            txsig = self._sell_ui_via_exec(mint, float(qty), 'tp2')
            print(f"‚úÖ TP2 sell txsig={txsig}", flush=True)
            self.db.mark_tp2(mint)
            return

        # --- TRAILING STOP ---
        trail = self.TRAIL_WIDE if pos["tp2_done"] else self.TRAIL_TIGHT
        stop_price = highest * (1 - trail)

        if price <= stop_price:
            print(f"üü† TRAIL STOP mint={mint} price={price:.6f}", flush=True)
            # sell remaining fraction based on TP flags
            rem_frac = 1.0
            if pos.get('tp1_done'):
                rem_frac -= float(self.TP1_SIZE)
            if pos.get('tp2_done'):
                rem_frac -= float(self.TP2_SIZE)
            if rem_frac < 0:
                rem_frac = 0.0
            ui_sell = float(size) * rem_frac
            try:
                txsig = self._sell_ui_via_exec(mint, ui_sell, reason='trail')
                print(f"‚úÖ TRAIL sell txsig={txsig}", flush=True)
            except Exception as e:
                print(f"‚ùå TRAIL sell error: {e}", flush=True)
                return
            if os.getenv("SELL_DRY_RUN","0") == "1":
                print("üß™ SELL_DRY_RUN=1 -> skip close_position on TRAIL", flush=True)
                return
            self.db.close_position(mint, reason="trailing_stop")
            return
